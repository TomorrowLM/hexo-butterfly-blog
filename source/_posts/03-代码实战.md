---
slug: 代码片段
title: 代码片段
description: 代码实战
keywords: html css es5 jq
category: 实战
tags: [实战,代码片段]
author: liming
date: 25-September-2020
---

# 代码合集收藏

https://mp.weixin.qq.com/s/w9iLd56H4xyXSlRwiKs04g

# css

​     <!-- <div class="dash" style="position: absolute; bottom: 0; width: 150px; height: 150px; margin-right: 20px">

            <div style="width: 150px; height: 150px; background: rgb(204 204 204 / 35%)"></div>

​     </div> -->

## 蒙版

```css
.page{
    position:relative;
    overflow: hidden;
}
.page:after{
    position:absolute;
    left: 0;
    top:0;
    display: block;
    width:100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    content: attr(data-text);
    /* transition:all 1s ease; */
    transform: translateY(-100%);
    color: #FFF;
}
/* .page:hover:after{
    transform: translateY(0);
} */
```

## 三角形

```css
#box {
    width: 0px;
    height: 0px;

    border: 100px solid transparent;

    border-top-color: deeppink;
    border-left-color: deeppink;
    /*border-right-color: deeppink;*/
    /*border-bottom-color: deeppink;*/
}
```

# js

## 内置方法

### Math



```js
Math.PI						// 圆周率
Math.random()				// 返回介于0（包含） ~ 1（不包含） 之间的一个随机数
Math.floor()/Math.ceil()	 // 向下取整/向上取整
Math.round()				// 取整，四舍五入
Math.abs()					// 绝对值
Math.max()/Math.min()		 // 求最大和最小值                                                                                                           
Math.sin()Math.cos()		 // 正弦/余弦
Math.power(基数，指数)/Math.sqrt()	 // 求指数次幂/求平方根
```

#### round

```
Math.ceil(Math.random()*10);     // 获取从 1 到 10 的随机整数，取 0 的概率极小。

Math.round(Math.random());       // 可均衡获取 0 到 1 的随机整数。

Math.floor(Math.random()*10);    // 可均衡获取 0 到 9 的随机整数。

Math.round(Math.random()*10);    // 基本均衡获取 0 到 10 的随机整数，其中获取最小值 0 和最大值 10 的几率少一半。
```

#### Math.trunc()

```js
//1.
//Math.trunc方法用于去除一个数的小数部分，返回整数部分。
Math.trunc(4.1) // 4
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4
Math.trunc(-4.9) // -4
Math.trunc(-0.1234) // -0
//对于非数值，Math.trunc内部使用Number方法将其先转为数值。
Math.trunc('123.456') // 123
Math.trunc(true) //1
Math.trunc(false) // 0
Math.trunc(null) // 0
//对于空值和无法截取整数的值，返回NaN。
Math.trunc(NaN);      // NaN
Math.trunc('foo');    // NaN
Math.trunc();         // NaN
Math.trunc(undefined) // NaN
```

#### Math.sign()

`Math.sign`方法用来判断一个数到底是正数、负数、还是零。

它会返回五种值。

- 参数为正数，返回+1；
- 参数为负数，返回-1；
- 参数为0，返回0；
- 参数为-0，返回-0;
- 其他值，返回NaN。

```js
Math.sign('')  // 0
Math.sign(true)  // +1
Math.sign(false)  // 0
Math.sign(null)  // 0
Math.sign('9')  // +1
Math.sign('foo')  // NaN
Math.sign()  // NaN
Math.sign(undefined)  // NaN
```

#### Math.cbrt()

方法用于计算一个数的立方根。对于非数值，Math.cbrt()方法内部也是先使用Number()方法将其转为数值。



#### 实战

##### 生成从minNum到maxNum的随机数

```
//生成从minNum到maxNum的随机数
function randomNum(minNum,maxNum){ 
    switch(arguments.length){ 
        case 1: 
            return parseInt(Math.random()*minNum+1,10); 
        break; 
        case 2: 
            return parseInt(Math.random()*(maxNum-minNum+1)+minNum,10); 
        break; 
            default: 
                return 0; 
            break; 
    } 
} 
```

### Date

#### **new Date()**创建新的日期对象

1. 用整数初始化日期对象

   new Date(yyyy,mth,dd,hh,mm,ss); 
   new Date(yyyy,mth,dd); 

   注意：

   - 您不能省略月份。如果只提供一个参数，则将其视为毫秒。
   - 一位和两位数年份将被解释为 19xx 年：

   ```
   yyyy:四位数表示的年份
   mth:用整数表示月份，从（１月）0到１１（１２月）
   dd:表示一个 月中的第几天，从1到31
   hh:小时数，从0（午夜）到23（晚11点）
   mm: 分钟数，从0到59的整数
   ss:秒数，从0到59的整数
   ```

2. 用字符串初始化日期对象

   new Date("2017/06/06"); 

   new Date(“2017-08-08”); 

   new Date("month dd,yyyy hh:mm:ss");  

   new Date("month dd,yyyy");

3. 用毫秒时间戳初始化日期对象

   new Date(ms);

   ```
   JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。
   零时间是 1970 年 1 月 1 日 00:00:00 UTC。
   ```




#### 获取日期方法

| 方法              | 描述                                 |
| :---------------- | :----------------------------------- |
| getDate()         | 以数值返回天（1-31）                 |
| getDay()          | 以数值获取周名（0-6）                |
| getFullYear()     | 获取四位的年（yyyy）                 |
| getHours()        | 获取小时（0-23）                     |
| getMilliseconds() | 获取毫秒（0-999）                    |
| getMinutes()      | 获取分（0-59）                       |
| getMonth()        | 获取月（0-11）                       |
| getSeconds()      | 获取秒（0-59）                       |
| getTime()         | 获取时间（从 1970 年 1 月 1 日至今） |

```
date.getFullYear()//获取完整的年份(4位,1970-????)
date.getMonth() //获取当前月份(0-11,0代表1月)
date.getDate()//获取几号   - 0 - 31 比如25
date.getDay()//获取星期几 - 比如星期3的3
date.getHours()//获取小时
date.getTime()// 获取相对于1970-01-01的毫秒值
```

#### 日期设置方法

设置方法用于设置日期的某个部分。下面是最常用的方法（按照字母顺序排序）：

| 方法              | 描述                                         |
| :---------------- | :------------------------------------------- |
| setDate()         | 以数值（1-31）设置日                         |
| setFullYear()     | 设置年（可选月和日）                         |
| setHours()        | 设置小时（0-23）                             |
| setMilliseconds() | 设置毫秒（0-999）                            |
| setMinutes()      | 设置分（0-59）                               |
| setMonth()        | 设置月（0-11）                               |
| setSeconds()      | 设置秒（0-59）                               |
| setTime()         | 设置时间（从 1970 年 1 月 1 日至今的毫秒数） |

#### **时间戳转化为日期的方式**

```
// Mon May 28 2018
console.log(newDate.toDateString());
 
// Mon, 28 May 2018 15:24:12 GMT
console.log(newDate.toGMTString());
 
// 2018-05-28T15:24:12.000Z
console.log(newDate.toISOString());
 
// 2018-05-28T15:24:12.000Z
console.log(newDate.toJSON());

// 2018/5/28
console.log(newDate.toLocaleDateString());
 
// 2018/5/28 下午11:24:12
console.log(newDate.toLocaleString());
 
// 下午11:24:12
console.log(newDate.toLocaleTimeString());
 
// Mon May 28 2018 23:24:12 GMT+0800 (中国标准时间)
console.log(newDate.toString());
 
// 23:24:12 GMT+0800 (中国标准时间)
console.log(newDate.toTimeString());
 
// Mon, 28 May 2018 15:24:12 GMT
console.log(newDate.toUTCString());
```

### console

```js
console.log(window.console);//打印信息
console.error('报错信息');//打印报错，但是不会影响代码继续执行
console.warn('警告信息');//警告信息
let isDebug = false
console.assert(isDebug, '打印报错信息')//断言，判断当条件为false，会打印错误信息（不影响代码继续执行）

function Myfn() {
  console.count('My被执行的次数：')
}
Myfn()
Myfn()
Myfn()


let array = new Array(10000)
let obj;
let obj1 = {}
for (let index = 0; index < 10000; index++) {
  obj1[`obj_${index}`] = index
}
// 启动计时器
console.time('testForEach');
// (写一些测试用代码)
for (let index = 0; index < array.length; index++) {
  if (index === 9999) {
    console.log(index);
  }
}
// 停止计时，输出时间
console.timeEnd('testForEach');
// 启动计时器
console.time('testForEach');
console.log(obj1['obj_9999']);
// 停止计时，输出时间
console.timeEnd('testForEach');


console.time('for')
let array = new Array(100000)
for (let index = 0; index < array.length; index++) {
  let obj = new Object()
}
console.timeEnd('for');//循环执行需要多少时间


let list = [{ name: '张三', age: 18, sex: '男' }, { name: '王美丽', age: 19, sex: '女' }, {}]//这里不知道为什么我的浏览器不显示最后一个，所以我就在数组后面加了一个空对象

console.table(list);//让数组和对象数据更加直观的可以看到
```

### defer和async

页面的加载和渲染过程：

1. 浏览器通过HTTP协议请求服务器，获取HMTL文档并开始从上到下解析，构建DOM树；
2. 在构建DOM过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件；
3. 样式文件下载完成后，构建样式表；脚本文件下载完成后，解释并执行，然后继续解析文档构建DOM
4. 完成文档解析后，将DOM树和样式表进行关联和映射，最后将视图渲染到浏览器窗口

> defer和async只对外部脚本有效（引入的js文件）

- `defer`script异步加载，html解析完,DomCOntentLoaded之前执行
- `async`script加载完后会立即执行,执行的过程仍会阻塞后续html的解析

![img](https://img2018.cnblogs.com/blog/1237064/201902/1237064-20190225103106193-1835436522.jpg)

- 蓝色线代表网络读取，
- 红色线代表js执行时间
- 绿色线代表 HTML 解析。

1. 通常情况下defer的使用频率较高,它能保证script之间的变量依赖。
2. 需要注意的是:async script的资源请求时异步的,但script的执行仍然会阻塞后续渲染(单线程),defer是在html渲染完之后执行的所以不会阻塞后续html的解析。

### setTimeout

setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式

| 参数                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| function            | 必需。要调用的函数后要执行的 JavaScript 代码串。             |
| millisec            | 可选。执行或调用 code/function 需要等待的时间，以毫秒计。默认为 0。 |
| param1, param2, ... | 可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数） |

```
function show(x, y, z) {
  console.log(x, y, z)
}
//第三个及以后的参数都可以作为show函数的参数
setTimeout(show, 100, 1, 2, 3)
```

**实例**

看以下例子可以知道，代码运行为6次打印了6。因为setTimeout因为是一个异步函数，var变量存在变量提升、无块级作用域等，等执行到setTimeout时，for循环已经遍历结束，i的值已经是6。

```js
for (var i = 0; i < 6; i++) {
  setTimeout(() => {
    console.log(i) //6,6,6,6,6,6
  }, 1000)
}
```

解决办法

1、闭包；使用闭包将i的值驻留在内存中，打印j的值（形成了自己的作用域），实际的外部函数的变量i

```js
for (var i = 0; i < 6; i++) {
  (function (j) {
    setTimeout(() => {
      console.log(j)// 0,1,2,3,4,5
    }, 1000)
  })(i)
}
```

2、setTimeout的第三个参数，该参数就是给setTimeout第一个函数的参数。每次传入setTimeout第一个函数的j值是for遍历的值，个人认为还是作用域的问题。

```js
for (var i = 0; i < 6; i++) {
  setTimeout(
    (j) => {
      console.log(j)// 0,1,2,3,4,5
    },
    1000,
    i
  )
}
```

### MutationObserver

https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/MutationObserver

当父元素中的元素有删减，会调用该函数。

eg：点击按钮，table中添加tr，调用该函数，可以为tr中的input设置disabled

tip: 添加合理的判断条件，否则会执行死循环

## 数据类型

**JS的基本数据类型和引用数据类型**

- 基本数据类型：`undefined`、`null`、`boolean`、`number`、`string`、`symbol`
- 引用数据类型：`object`、`array`、`function`

### number

#### **数值判断转换**

- NaN：not a number 该属性用于指示某个值不是数字。 

  - NaN 与任何值都不相等，包括他本身

- isNaN: is not a number判断是否是数字，若是数字返回false

- isFinite(number ) 函数用于检查其参数是否是无穷大。

  **提示：** 如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。

```
undefined表示一个声明了没有初始化的变量，变量只声明的时候值默认是undefined
null表示一个空，变量的值如果想为null，必须手动设置
```

```
布尔类型的隐式转换：转换为true   非空字符串  非0数字  true 任何对象
				转换成false  空字符串  0  false  null  undefined
```

转换成字符串类型：

- toString() String() 拼接字符串方式

**转换成数值类型：**

- 1.Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN 

- 2.parseInt() 

- 3.parseFloat()

#### 实战

##### 判断字符串或者数字是否是正整数

```
const isInteger = (s) => {
    var re = /^[0-9]+$/;
    return re.test(s)
}
```

判断字符串或者数字是否是小数

```
const isDecimal = (s) => {
	var re1 = /^[0-9]+$/;
	var re2 = /^[0-9]+\.?[0-9]+?$/;
    return !re.test(s) && re2.test(s)
}
```

### 字符串

**不会改变原来的字符串**

#### charAt

charAt(index)

```
获取指定位置处字符 myString.charAt(1)
```

charCodeAt()  	//获取指定位置处字符的ASCII码

#### indexOf

indexOf('',[index] )   	

返回指定内容在元字符串中的位置，只找第一个匹配的，若没有则返回-1

indexOf('a',2);从位置2开始找到a的位置
lastIndexOf() 	//从后往前找，只找第一个匹配的

#### lastIndexOf

lastIndexOf('')

#### concat

拼接字符串，等效于+，+更常用

#### slice

提取字符串的一部分，并返回新的字符串

str.slice(start, end) 

end 参数可选，start可取正值，也可取负值。

取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符，如果end省略则截取到字符串末尾）
取负值时表示从索引为 length+start 位置截取到end所在位置的字符

```
ar str = "It is our choices that show what we truly are, far more than our abilities.";
console.log(str.slice(0,-30)); // It is our choices that show what we truly are
console.log(str.slice(-30)); // , far more than our abilities.
```

#### substring

str.slice(start, end)
取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符，如果end省略则截取到字符串末尾）
取负值时表示从索引为 length+start 位置截取到end所在位置的字符

#### substr

返回字符串指定位置开始的指定数量的字符。

substr(fromIndex,length)   		

start 表示开始截取字符的位置，可取正值或负值。取正值时表示start位置的索引，取负值时表示 length+start位置的索引。

length 表示截取的字符长度。

#### trim

trim()去除空白   
只能去除字符串前后的空白，字符之间的空格不能去掉

#### **toLocaleUpperCase**

toLocaleLowerCase() 方法返回调用该方法的字符串被转换成小写的值，转换规则根据本地化的大小写映射toLocaleUpperCase() 方法则是转换成大写的值。

语法：*str.toLocaleLowerCase()*, *str.toLocaleUpperCase()*

```
console.log('ABCDEFG'.toLocaleLowerCase()); // abcdefg
console.log('abcdefg'.toLocaleUpperCase()); // ABCDEFG
```

#### split

split()字符转换为数组 split()还可以结合正则表达式

```js
var str='a,b,c,d';
var arr=str.split(',');//以逗号为分割成数组
arr.join('');
```

#### includes(ES6)

includes() 方法基于**ECMAScript 2015（ES6）规范**，它用来判断一个字符串是否属于另一个字符。如果是，则返回true，否则返回false。

语法：*str.includes(subString [, position])*

subString 表示要搜索的字符串，position 表示从当前字符串的哪个位置开始搜索字符串，默认值为0。

```js
var str = "Practice makes perfect.";
console.log(str.includes("perfect")); // true
console.log(str.includes("perfect",100)); 
```

#### endsWith(ES6)

endsWith() 方法基于**ECMAScript 2015（ES6）规范**，它基本与 contains() 功能相同，不同的是，它用来判断一个字符串是否是原字符串的结尾。若是则返回true，否则返回false。

语法：*str.endsWith(substring [, position])*

与contains 方法不同，position 参数的默认值为字符串长度。

```js
var str = "Learn and live.";
console.log(str.endsWith("live.")); // true
console.log(str.endsWith("Learn",5)); 
```

startsWith() 方法基于**ECMAScript 2015（ES6）规范**，它用来判断当前字符串是否是以给定字符串开始的，若是则返回true，否则返回false。

语法：*str.startsWith(subString [, position])*

```
var str = "Where there is a will, there is a way.";
console.log(str.startsWith("Where")); // true
console.log(str.startsWith("there",6)); 
```

#### 实战

##### 找到第一个不重复的字符，并返回它的索引

```js
const firstUniqChar = (s) => {
  const position = new Map();
  for (let i of s) {
    if (position.has(i)) {
      position.set(i, position.get(i) + 1);
    } else {
      position.set(i, 1)
    }
  }
  for(let i = 0; i < s.length; i++) {  
    if (position.get(s[i]) === 1) 
      return i
  }
  return -1
};
//s = "leetcode"
返回 0

//s = "loveleetcode"
返回 2

```



### 数组

#### 会改变原来数组的有：

##### pop()

删除数组的最后一个元素并返回删除的元素。

##### push()

向数组的末尾添加一个或更多元素，并返回新的长度。

##### shift()

删除并返回数组的第一个元素。

##### unshift()

向数组的开头添加一个或更多元素，并返回新的长度。reverse()---反转数组的元素顺序。

##### reverse()	

翻转数组

##### sort() 	

*arr.sort([comparefn])*

- comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序

- 如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素：
  - 若 comparefn(a, b) < 0，那么a 将排到 b 前面；
  - 若 comparefn(a, b) = 0，那么a 和 b 相对位置不变；
  - 若 comparefn(a, b) > 0，那么a , b 将调换位置；

```js
//即使是数组sort也是根据字符，从小到大排序
//采用冒泡排序
sort(fn(a,b){
// 升序
return a - b;
// 倒序
return b - a;
})
fn（a,b）{return <0||>0},返回小于0升序，大于0降序。

```

```js
var a = [2,3,1,0].sort(function(a,b){
    console.log(a,b)
    return a-b
})
:3 2
:1 3 
:1 3 
:1 2 
:0 2
:0 1
```

**sort()方法的比较逻辑为：**
前一半的数组进行比较，并排好序，后一半数组再与前面排序好的数组的中间一个值比较（二分法，判断是与前面还是后面的数组比较，更快），并排序

##### splice()

```
array.splice(index, howmany, item1, ....., itemX)
```

参数值

| 参数                | 描述                                                         |
| :------------------ | :----------------------------------------------------------- |
| *index*             | 必需。整数，指定在什么位置添加/删除项目，使用负值指定从数组末尾开始的位置。 |
| *howmany*           | 可选。要删除的项目数。如果设置为 0，则不会删除任何项目。     |
| *item1, ..., itemX* | 可选。要添加到数组中的新项目。                               |

arr.splice(start,deleteCount[, item1[, item2[, …]]])

**删除**

```js
var array = ["apple","boy"];
var splices = array.splice(1,1);
console.log(array); // ["apple"]
console.log(splices); // ["boy"] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素
```

**插入**

```js
var array = ["one", "two", "four"];
array.splice(2, 0, "three"); // 
array; //["one", "two", "three", "four"]

Array.prototype.insert = function (index, item) {
	this.splice(index, 0, item);
};
var nums = ["one", "two", "four"];
nums.insert(2, 'three'); // 注意数组索引, [0,1,2..]
array // ["one", "two", "three", "four"]
```

#### 不会改变原来数组的有：

##### indexOf和lastIndexOf

indexOf(arr[i],[index] ) 从位置index查找arr[i]在数组中的位置，只找第一个匹配的，如果不存在，则返回-1。

##### concat() 

将传入的数组或者元素与原数组合并，组成一个新的数组并返回。

语法：***arr.concat(value1, value2, …, valueN)***

```
var array = [1, 2, 3];
var array2 = array.concat(4,[5,6],[7,8,9]);
console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(array); // [1, 2, 3], 可见原数组并未被修改
```

若concat方法中不传入参数，那么将基于原数组**浅复制**生成一个一模一样的新数组（指向新的地址空间）。

```js
var array = [{a: 1}];
var array3 = array.concat();
console.log(array3); // [{a: 1}]
console.log(array3 === array); // false
console.log(array[0] === array3[0]); // true，新旧数组第一个元素依旧共用一个同一个对象的引用
```

##### join() 

将数组中的所有元素连接成一个字符串。

语法：*arr.join([separator = ‘,’])* separator可选，缺省默认为逗号。

```
var array = ['We', 'are', 'Chinese'];
console.log(array.join()); // "We,are,Chinese"
console.log(array.join('+')); // "We+are+Chinese"
console.log(array.join('')); // "WeareChinese"
```

##### slice() 

将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。

语法：*arr.slice([start[, end]])*

参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。

如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。

slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。

```js
var array = ["one", "two", "three","four", "five"];
console.log(array.slice()); // ["one", "two", "three","four", "five"]
console.log(array.slice(2,3)); // ["three"]
console.log(array); // ["one", "two", "three","four", "five"]
```

**浅复制** 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象。下面来说明slice为什么是浅复制。

```js
var array = [{color:"yellow"}, 2, 3];
var array2 = array.slice(0,1);
console.log(array2); // [{color:"yellow"}]
array[0]["color"] = "blue";
console.log(array2); // [{color:"bule"}]
12345
```

由于slice是浅复制，复制到的对象只是一个引用，改变原数组array的值，array2也随之改变。

##### toString和toLocaleString

#### ES6

##### from

`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（**iterable**）的对象（包括ES6新增的数据结构Set和Map）。

```javascript
let arrayLike = {
    '0': 'a',
    '1': 'b',
    '2': 'c',
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法
let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']
```

实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的`arguments`对象。`Array.from`都可以将它们转为真正的数组。

只要是部署了**Iterator**接口的数据结构，`Array.from`都能将其转为数组。

```
c
// ['h', 'e', 'l', 'l', 'o']

let namesSet = new Set(['a', 'b'])
Array.from(namesSet) // ['a', 'b']
```

值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。

```javascript
// arguments对象
function foo() {
  var args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll('div')]
```

扩展运算符背后调用的是遍历器接口（`Symbol.iterator`），如果一个对象没有部署这个接口，就无法转换。`Array.from`方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有`length`属性。因此，任何有`length`属性的对象，都可以通过`Array.from`方法转为数组，而此时扩展运算符就无法转换。

```javascript
Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
```

`Array.from`还可以接受第二个参数，作用类似于数组的`map`方法，用来对每个元素进行处理，将处理后的值放入返回的数组。

```javascript
Array.from(arrayLike, x => x * x);
// 等同于
Array.from(arrayLike).map(x => x * x);

Array.from([1, 2, 3], (x) => x * x)
// [1, 4, 9]
```

下面的例子是取出一组DOM节点的文本内容。

```javascript
let spans = document.querySelectorAll('span.name');

// map()
let names1 = Array.prototype.map.call(spans, s => s.textContent);

// Array.from()
let names2 = Array.from(spans, s => s.textContent)
```

##### Array.of

`Array.of`方法用于将一组值，转换为数组。

```javascript
Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
```

这个方法的主要目的，是弥补数组构造函数`Array()`的不足。因为参数个数的不同，会导致`Array()`的行为有差异。

```javascript
Array() // []
//参数个数只有一个时，实际上是指定数组的长度。
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
```

`Array.of`基本上可以用来替代`Array()`或`new Array()`，并且不存在由于参数不同而导致的重载。它的行为非常统一。

```javascript
Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
```

##### copyWithin

数组实例的`copyWithin`方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。

```javascript
Array.prototype.copyWithin(target, start = 0, end = this.length)
```

它接受三个参数。

- target（必需）：从该位置开始替换数据。
- start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。
- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

这三个参数都应该是数值，如果不是，会自动转为数值。

```javascript
[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
```

上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。

```js
// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]
```

##### find和findIndex

数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出**第一个**返回值为`true`的成员，然后**返回该成员**。如果没有符合条件的成员，则返回`undefined`。

```javascript
[1, 4, -5, 10].find((n) => n < 0)
// -5
```

上面代码找出数组中第一个小于0的成员。

```javascript
[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}) // 10
```

上面代码中，`find`方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。

数组实例的`findIndex`方法的用法与`find`方法非常类似，**返回第一个符合条件的数组成员的位置**，如果所有成员都不符合条件，则返回`-1`。

```javascript
[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
}) // 2
```

另外，这两个方法都可以发现`NaN`，弥补了数组的`IndexOf`方法的不足。

```javascript
[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y => Object.is(NaN, y))
// 0
```

上面代码中，`indexOf`方法无法识别数组的`NaN`成员，但是`findIndex`方法可以借助`Object.is`方法做到。

##### fill()

`fill`方法使用给定值，填充一个数组。

```javascript
['a', 'b', 'c'].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
```

上面代码表明，`fill`方法用于空数组的初始化非常方便。

##### entries和keys和values

ES6提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用`for...of`循环进行遍历，唯一的区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。

```js
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

如果不使用`for...of`循环，可以手动调用遍历器对象的`next`方法，进行遍历。

```javascript
let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']
```

##### includes()

`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。该方法属于ES7，但Babel转码器已经支持。

```javascript
[1, 2, 3].includes(2);     // true
[1, 2, 3].includes(4);     // false
[1, 2, NaN].includes(NaN); // true
```

```
[{a:1},2,3,{b:2}].includes({a:1})//false
```

##### 数组的空位

数组的空位指，数组的某一个位置没有任何值。比如，`Array`构造函数返回的数组都是空位。

```javascript
Array(3) // [, , ,]
```

上面代码中，`Array(3)`返回一个具有3个空位的数组。

注意，空位不是`undefined`，一个位置的值等于`undefined`，依然是有值的。空位是没有任何值，`in`运算符可以说明这一点。

```javascript
0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
```

上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。

ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。

- `forEach()`, `filter()`, `every()` 和`some()`都会跳过空位。
- `map()`会跳过空位，但会保留这个值
- `join()`和`toString()`会将空位视为`undefined`，而`undefined`和`null`会被处理成空字符串。

```javascript
// forEach方法
[,'a'].forEach((x,i) => console.log(i)); // 1

// filter方法
['a',,'b'].filter(x => true) // ['a','b']

// every方法
[,'a'].every(x => x==='a') // true

// some方法
[,'a'].some(x => x !== 'a') // false

// map方法
[,'a'].map(x => 1) // [,1]

// join方法
[,'a',undefined,null].join('#') // "#a##"

// toString方法
[,'a',undefined,null].toString() // ",a,,"
```

ES6则是明确将空位转为`undefined`。

`Array.from`方法会将数组的空位，转为`undefined`，也就是说，这个方法不会忽略空位。

```javascript
Array.from(['a',,'b'])
// [ "a", undefined, "b" ]
```

扩展运算符（`...`）也会将空位转为`undefined`。

```javascript
[...['a',,'b']]
// [ "a", undefined, "b" ]
```

`copyWithin()`会连空位一起拷贝。

```javascript
[,'a','b',,].copyWithin(2,0) // [,"a",,"a"]
```

`fill()`会将空位视为正常的数组位置。

```javascript
new Array(3).fill('a') // ["a","a","a"]
```

`for...of`循环也会遍历空位。

```javascript
let arr = [, ,];
for (let i of arr) {
  console.log(1);
}
// 1
// 1
```

上面代码中，数组`arr`有两个空位，`for...of`并没有忽略它们。如果改成`map`方法遍历，空位是会跳过的。

`entries()`、`keys()`、`values()`、`find()`和`findIndex()`会将空位处理成`undefined`。

```javascript
// entries()
[...[,'a'].entries()] // [[0,undefined], [1,"a"]]

// keys()
[...[,'a'].keys()] // [0,1]

// values()
[...[,'a'].values()] // [undefined,"a"]

// find()
[,'a'].find(x => true) // undefined

// findIndex()
[,'a'].findIndex(x => true) // 0
```

由于空位的处理规则非常不统一，所以建议避免出现空位。

#### 实战

##### 根据数组长度创建一个一样长度的数组并初始化值为0

```
const arr = new Array(5).fill(0)
```

##### 选择一个随机值

```
const random = (arr) => arr[Math.floor(Math.random() * arr.length)]
random([1, 2, 3, 4, 5, 6])
```

##### 数组去重

https://zhuanlan.zhihu.com/p/90017508

```js
function removeDuplicate(arr) {
  return Array.from(new Set([1,2,3,4,5,2,2,2,4,5]))
}
```

```js
/*
  indexOf：从左往右查找目标字符串，是否包含 Value;
           如果包含，返回第一次出现的索引;
           如果不包含，返回 -1
  indexOf 和 lastIndexOf() 方法一样
  步骤：
  1. 先声明一个空数组，用来存放去重后的数据
  2. 遍历数组，判断每一项
*/
let arr = ['one','two','three','one','three','two','four'];
let indexArr = [];
arr.forEach(item => {
   if(indexArr.indexOf(item)===-1){
      indexArr.push(item);
   };
});
console.log(indexArr); // ['one','two','three','four'];
```

```js
let arr = ['one','two','three','one','three','two','four'];
let el = arr.filter((item,index)=>arr.indexOf(item)===index);
console.log(el); // ['one','two','three','four'];
```

```js
/* 
   1. 和上面方法一致，只不过是使用了 forEach
*/
var arr = ['one','two','three','one','three','two','four'];
var obj = {};
arr.forEach(function(ele,index,arr){
    obj[arr[index]] = arr[index];
});
var el =  Object.keys(obj);
console.log(el) // ['one','two','three','four'];
```

##### 数组中最大元素的下标

```js
function maxValIndex(arr){
  var max=Math.max(...arr);
  var index = arr.map(item => item).indexOf(max);
  return index
}
```

##### 找出数组中出现最多的元素和次数

```js
function findMost(arr) {
    if (!arr.length) return
    if (arr.length === 1) return 1
    let res = {}
    let maxName, maxNum = 0
    // 遍历数组
    arr.forEach((item) => {
      res[item] ? res[item] += 1 : res[item] = 1
    })
    // 遍历 res
    for (let r in res) {
      if (res[r] > maxNum) {
        maxNum = res[r]
        maxName = r
      }
    }
    return '出现次数最多的元素为:' + maxName + ', 出现次数为:' + maxNum;
}
 
function findMost (arr) {
  if (!arr.length) return;
  if (arr.length === 1) return 1;
  let res = {};
  let maxName, maxNum = 0
  // 遍历数组
  arr.forEach((item) => {
    res[item] ? res[item] += 1 : res[item] = 1
    if (res[item] > maxNum) {
      maxName = item
      maxNum = res[item]
    }
  })
  return '出现次数最多的元素为:' + maxName + ', 出现次数为:' + maxNum;
}
 
 
function findMost (arr) {
  if (!arr.length) return;
  if (arr.length === 1) return 1;
  let maxName, maxNum = 0
  let res = arr.reduce((res, currentNum) => {
    res[currentNum] ? res[currentNum] += 1 : res[currentNum] = 1
    if (res[currentNum] > maxNum) {
      maxNum = res[currentNum]
      maxName = currentNum
    }
    return res
  }, {})
  return '出现次数最多的元素为:' + maxName + ', 出现次数为:' + maxNum;
}
 
 const str = 'jshdjsihh';
     const obj = str.split('').reduce((pre,item) => {
         pre[item] ? pre[item] ++ : pre[item] = 1
         return pre
     },{})
 console.log(obj) // {j: 2, s: 2, h: 3, d: 1, i: 1}
```

##### 数组对象

###### 数组对象去重

```js
tempArr1 = tempArr1.filter((item,index) =>{
	return tempArr1.findIndex(item1 =>item1.id==item.id) == index
})
```

###### 判断两个数组对象是否相等

## 遍历

### 数组

**迭代方法 不会修改原数组**

every()、filter()、forEach()、map()、some()

#### forEach()

指定数组的每项元素都执行一次传入的函数，返回值为undefined。

语法：**arr.forEach(fn, thisArg)**

fn 表示在数组每一项上执行的函数，接受三个参数：

- value 当前正在被处理的元素的值
- index 当前元素的数组索引
- array 数组本身

thisArg 可选，用来当做fn函数内的this对象。

```js
var array = [1, 3, 5];
var obj = {name:'cc'};
var sReturn = array.forEach(function(value, index, array){
  array[index] = value * value;
  console.log(this.name); // cc被打印了三次
},obj);
console.log(array); // [1, 9, 25], 可见原数组改变了
console.log(sReturn); // undefined, 可见返回值为undefined
```

#### map()

使用传入函数处理每个元素，并返回函数的返回值组成的新数组。

语法：**arr.map(fn, thisArg)**

参数介绍同 forEach 方法的参数介绍。

#### every()

数组的每一项执行的函数都满足条件就返回true

#### some()

对数组的每一项运行给定函数，如果该函数对任一项返回true，则返回true。

```jsx
let list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
list.some(item=>{
  console.log(item)
  if(item===3){
    return true
  }
})
输出结果为0 1 2 3
```

es6中的some也可实现此功能。some循环中只要有一个符合条件则会跳出循环体

#### filter()

执行函数过滤掉不符和条件的数组元素，返回复合条件的数组元素

语法：**arr.filter(fn, thisArg)**

```
var array = [18, 9, 10, 35, 80];
var array2 = array.filter(function(value, index, array){
  return value > 20;
});
console.log(array2); // [35, 80]
```

`0`，`undefined`，`null`，`false`，`""`，`''`可以很容易地通过以下方法省略

```js
const array = [3, 0, 6, 7, '', false];
array.filter(Boolean);
// 输出
(3) [3, 6, 7]
```

删除重复值

```
const array  = [5,4,7,8,9,2,7,5];
array.filter((item,idx,arr) => arr.indexOf(item) === idx);
```

#### reduce()

reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。

语法：**array.reduce(function(total, currentValue, currentIndex, arr), initialValue)**

**参数**

| 参数                                      | 描述                               |
| :---------------------------------------- | :--------------------------------- |
| *initialValue*                            | 可选。**传递给函数的初始值**       |
| *function(total,currentValue, index,arr)* | 必需。用于执行每个数组元素的函数。 |

| 参数                     | 描述                                     |
| :----------------------- | :--------------------------------------- |
| *total(累计器)*          | 必需。*初始值*, 或者计算结束后的返回值。 |
| *currentValue*(当前值)   | 必需。当前元素                           |
| *currentIndex(当前索引)* | 可选。当前元素的索引                     |
| *arr(源数组)*            | 可选。当前元素所属的数组对象。           |

**代码**

```js
[1,2,3,4].reduce((acc, cur) => { //不带初始值
  return acc + cur
})
// 1 + 2 + 3 + 4
// 10

[1,2,3,4].reduce((acc, cur) => { //带初始值
  return acc + cur
}, 10)
// 10 + 1 + 2 + 3 + 4
// 20
```

 **初始值 `initialValue` 可以是任意类型。如果没有提供 `initialValue`，`reduce` 会从索引 1 的地方开始执行 `callback` 方法，跳过第一个索引。如果提供 `initialValue`，从索引 0 开始**

#### entries() 

方法基于**ECMAScript 2015（ES6）规范**，返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。

语法：**arr.entries()**

```
var array = ["a", "b", "c"];
var iterator = array.entries();
console.log(iterator.next()); //{ value: [ 0, 'a' ], done: false } 
console.log(iterator.next().value); // [0, "a"]
console.log(iterator.next().value); // [1, "b"]
console.log(iterator.next().value); // [2, "c"]
console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined
```

#### keys

keys() 方法基于ECMAScript 2015（ES6）规范，返回一个数组索引的迭代器。（浏览器实际实现可能会有调整）

语法：**arr.keys()**

```js
var array = ["abc", "xyz"];
var iterator = array.keys();
console.log(iterator.next()); // Object {value: 0, done: false}
console.log(iterator.next()); // Object {value: 1, done: false}
console.log(iterator.next()); // Object {value: undefined, done: false}
```

#### values()

values() 方法基于**ECMAScript 2015（ES6）规范**，返回一个数组迭代器对象，该对象包含数组中每个索引的值。其用法基本与上述 entries 方法一致。

语法：**arr.values()**

遗憾的是，现在没有浏览器实现了该方法，因此下面将就着看看吧。

```js
var array = ["abc", "xyz"];
var iterator = array.values();
console.log(iterator.next().value);//abc
console.log(iterator.next().value);//xyz
```

#### for

**for...in循环**

精准的迭代，可以迭代对象的元素。也可以迭代数组。

【注意】使用`for ... in`，迭代的是元素（keys），对于数组来说，则为下标（0,1,2...,length-1）

```text
for(var key in arr) {
    //执行相关操作
}
```

 **for...of循环（ES6支持）**

```text
for(let item of arr) {
    //执行相关操作
}
```

和`for...in`不同的是，`for...of`迭代出来的是值（value），对于数组来说，则是一个元素值。

### 对象

#### for...in 

**for...in遍历**

```js
var book = {
    name: "hello",
    id: "2",
    author: "ztyzz",
    time: "2018.2.30"

};
for(var el in book) {
    console.log(book[el]);
}
```

**for ... of遍历**

此方法，**不能遍历普通对象**(因为能够被for...of正常遍历的，都需要实现一个遍历器Iterator。而数组、字符串、Set、Map结构，早就内置好了Iterator（迭代器），它们的原型中都有一个Symbol.iterator方法，而Object对象并没有实现这个接口（**对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。**），使得它无法被for...of遍历。)，需要和`Object.keys()`搭配使用，先获取对象的所有key的数组 然后遍历：

```text
var book = {
    name: "hello",
    id: "2",
    author: "ztyzz",
    time: "2018.2.30"

};
for(var key of Object.keys(book)) {
    console.log(book[key]);
}
```

【注意】`Object.values()`返回对象所有的键值组成的数组，但是由于无法获取到key值，功能会比较残缺。

同时，由于`Object.keys()`返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).所以我们可以使用forEach()等上面的方法，来进行数组的遍历，再通过对象的访问来进行值的访问。



## 构造函数

```js
const name = 'window'
const p1 = {
  name: 'foo'
}
function People(name) {
  console.log(this);
  this.name = name
  console.log(this);

}

const Foo = People.bind(p1)
Foo(1)
console.log(p1);
const foo = new Foo('boo')
console.log(foo.name);
console.log(name);
```

## 数据转化

#### 自动转换

##### 赋值

###### 不全等

null,NaN,undefined,0-0,+0,true,false

**基本数据类型有隐式转换**

- 字符串与数字比较 （等号两侧转化为数字，再比较）

  ```
  　　100 == "100"　　==>　　100 == 100　　//　true
  　　100 == "99"　　==>　　100 == 99　　//　false
  　　100 == "abc"　　==>　　100 == NaN　　//　false
  　　1 == "abc"　　==>　　1 == NaN　　//　false
  　　1 == ""　　==>　　1 == 0　　//　false
  ```

- 字符串与布尔值比较（等号两侧转换为数字，再比较）

  ```
  　　"abc" == true　　==>　　NaN == 1　　//　false
  　　"abc" == false　　==>　　NaN == 0　　//　false
  　　"" == true　　==>　　0 == 1　　//　false
  　　"" == false　　==>　　0 == 0　　//　true
  ```

- 数字与布尔值比较（等号两侧转换为数字，再比较）

  ```
  　　1 == true　　==>　　1 == 1　　//　true
  　　0 == true　　==>　　0 == 1　　//　false
  　　100 == true　　==>　　100 == 1　　//　false
  　　1 == false　　==>　　1 == 0　　//　false
  　　0 == false　　==>　　0 == 0　　//　true
  　　100 == false　　==>　　100 == 0　　//　false
  ```

- undefined 和 null

  ```
  undefined 与 null 比较特殊,比较相等性之前，不能将 null 和 undefined 转换成其他任何值。undefined 和 null 互相比较返回 true，和自身比较也返回 true，其他情况返回 false
  　　undefiend == undefined　　//　true
  　　undefined == null　　//　true
  　　null == null　　//　true
  　　undefined == 其他值　　//　false
  　　null == 其他值　　//　false
  ```

- NaN

  ```
  NaN（非数值）也很特殊，NaN 和任何值（包括自己）比较都是返回 false
  NaN == NaN　　//　false
  NaN == 其他值　　//　false
  ```

**复杂数据类型**

由于引用类型保存的是对象（包括数组，函数）的地址值，所以地址值不同的，返回的都是 false

- 等号两侧为不同的引用数据类型时

- 有且只有一侧为引用数据类型时

  ```
  [1，2] == 1 ==> NaN == 1　　//　false
  [1，2] == true ==> NaN == 1　　//　false
  [1] == 1 ==> 1 == 1　　//　true
  [1] == '1' ==> '1' == '1'　　//　true
  
  [] == 0 ==> 0 == 0　　//　true
  [] == '0' ==> '' == '0'　　//　false
  [] == '' ==> '' == ''　　//　true
  ```

###### 全等

```
+0 === -0 //true
实际意义上的全等
Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

##### 自动转换布尔值

除了以下五个值，其他都是自动转为`true`。

- `undefined`
- `null`
- `+0`或`-0`
- `NaN`
- `''`（空字符串）

##### 自动转换为字符串

具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。

字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。

```
'5' + 1 // '51'
'5' + true // "5true"
'5' + false // "5false"
'5' + {} // "5[object Object]"
'5' + [] // "5"
'5' + function (){} // "5function (){}"
'5' + undefined // "5undefined"
'5' + null // "5null"
```

##### 自动转换为数值

JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用`Number()`函数。

除了加法运算符（`+`）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。

```
'5' - '2' // 3
'5' * '2' // 10
true - 1  // 0
false - 1 // -1
'1' - 1   // 0
'5' * []    // 0
false / '5' // 0
'abc' - 1   // NaN
null + 1 // 1
undefined + 1 // NaN
```

上面代码中，运算符两侧的运算子，都被转成了数值。

> 注意：`null`转为数值时为`0`，而`undefined`转为数值时为`NaN`。

一元运算符也会把运算子转成数值。

```
+'abc' // NaN
-'abc' // NaN
+true // 1
-false // 0
```

#### 强制转换

##### Number

- 基本类型

  ```js
  // 数值：转换后还是原来的值
  Number(324) // 324
  
  // 字符串：如果可以被解析为数值，则转换为相应的数值
  Number('324') // 324
  
  // 字符串：如果不可以被解析为数值，返回 NaN
  Number('324abc') // NaN
  
  // 空字符串转为0
  Number('') // 0
  
  // 布尔值：true 转成 1，false 转成 0
  Number(true) // 1
  Number(false) // 0
  
  // undefined：转成 NaN
  Number(undefined) // NaN
  
  // null：转成0
  Number(null) // 0
  ```

  `Number`函数将字符串转为数值，要比`parseInt`函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为`NaN`。

  ```
  parseInt('42 cats') // 42
  Number('42 cats') // NaN
  ```

- 引用类型

  简单的规则是，`Number`方法的参数是对象时，将返回`NaN`，除非是包含单个数值的数组。

  ```
  Number({a: 1}) // NaN
  Number([1, 2, 3]) // NaN
  Number([5]) // 5
  ```

  第一步，调用对象自身的`valueOf`方法。如果返回原始类型的值，则直接对该值使用`Number`函数，不再进行后续步骤。

  第二步，如果`valueOf`方法返回的还是对象，则改为调用对象自身的`toString`方法。如果`toString`方法返回原始类型的值，则对该值使用`Number`函数，不再进行后续步骤。

  第三步，**如果`toString`方法返回的是对象**，就报错。

  请看下面的例子。

  ```
  const obj = { x: 1 };
  console.log(Number(obj)); // NaN
  
  // 等同于
  if (typeof obj.valueOf() === 'object') {
    console.log(Number(obj.toString()));
  } else {
    console.log(Number(obj.valueOf()));
  }
  ```

  上面代码中，`Number`函数将`obj`对象转为数值。背后发生了一连串的操作，首先调用`obj.valueOf`方法, 结果返回对象本身；于是，继续调用`obj.toString`方法，这时返回字符串`[object Object]`，对这个字符串使用`Number`函数，得到`NaN`。

  ```
  const obj = {
    valueOf: function () {
      return {};
    },
    toString: function () {
      return {};
    }
  };
  
  Number(obj)
  // TypeError: Cannot convert object to primitive value
  ```

  上面代码的`valueOf`和`toString`方法，返回的都是对象，所以转成数值时会报错。

##### string

- 基本类型

  - **数值**：转为相应的字符串。
  - **字符串**：转换后还是原来的值。
  - **布尔值**：`true`转为字符串`"true"`，`false`转为字符串`"false"`。
  - **undefined**：转为字符串`"undefined"`。
  - **null**：转为字符串`"null"`。

  ```
  String(123) // "123"
  String('abc') // "abc"
  String(true) // "true"
  String(undefined) // "undefined"
  String(null) // "null"
  ```

- 引用类型

  `String`方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。

  ```
  String({a: 1}) // "[object Object]"
  String([1, 2, 3]) // "1,2,3"
  ```

  `String`方法背后的转换规则，与`Number`方法基本相同，只是互换了`valueOf`方法和`toString`方法的执行顺序。

  1. 先调用对象自身的`toString`方法。如果返回原始类型的值，则对该值使用`String`函数，不再进行以下步骤。
  2. 如果`toString`方法返回的是对象，再调用原对象的`valueOf`方法。如果`valueOf`方法返回原始类型的值，则对该值使用`String`函数，不再进行以下步骤。
  3. 如果`valueOf`方法返回的是对象，就报错。

  ```
  var obj = {
    valueOf: function () {
      return {};
    },
    toString: function () {
      return {};
    }
  };
  
  String(obj)
  // TypeError: Cannot convert object to primitive value
  ```

  

##### Boolean

`Boolean()`函数可以将任意类型的值转为布尔值。

它的转换规则相对简单：除了以下五个值的转换结果为`false`，其他的值全部为`true`。

- `undefined`
- `null`
- `0`（包含`-0`和`+0`）
- `NaN`
- `''`（空字符串）

```
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false
```

当然，`true`和`false`这两个布尔值不会发生变化。

```
Boolean(true) // true
Boolean(false) // false
```

注意，所有对象（包括空对象）的转换结果都是`true`，甚至连`false`对应的布尔对象`new Boolean(false)`也是`true`（详见《原始类型值的包装对象》一章）。

```
Boolean({}) // true
Boolean([]) // true
Boolean(new Boolean(false)) // true
```



## 判断数据类型

##### **1、typeof**

typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：

- 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。
- 引用数据类型：对象(Object)、数组(Array)、函数(Function)。

```js
typeof''; // string 有效
typeof1; // number 有效
typeofSymbol(); // symbol 有效
typeoftrue; //boolean 有效
typeofundefined; //undefined 有效
typeofnull; //object 无效
typeof[] ; //object 无效
typeofnewFunction(); // function 有效
typeofnewDate(); //object 无效
typeofnewRegExp(); //object 无效
```

**注意：**

- 对于基本类型，除 null 以外，均可以返回正确的结果。
- 对于引用类型，除 function 以外，一律返回 object 类型。
- 对于 null ，返回 object 类型。因为在定义typeof时还没有null这种类型。

其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，**只返回了处于其原型链最顶端的 Object 类型**，没有错，但不是我们想要的结果。

##### **2、instanceof**

instanceof 是用来**判断 A 是否为 B 的实例**(不能判断一个对象实例具体属于哪种类型)

表达式为：A instanceof B。如果 A 是 B 的实例，则返回 true,否则返回 false。 

在这里需要特别注意的是：**instanceof 检测的是原型**，我们用一段伪代码来模拟其内部执行过程：

```js
instanceof (A,B) = {
    varL = A.__proto__;
    varR = B.prototype;
    if(L === R) {
        // A的内部属性 __proto__ 指向 B 的原型对象
        return true;
    }
    return false;
}
```

从上述过程可以看出，**当 A 的 proto 指向 B 的 prototype 时，就认为 A 就是 B 的实例**，我们再来看几个例子：

```js
[] instanceof Array; // true
{} instanceof Object;// true
newDate() instanceof Date;// true
 
function Person(){};
new Person() instanceof Person;
 
[] instanceof Object; // true
newDate() instanceof Object;// true
newPerson instanceof Object;// true
```

**虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例**

我们来分析一下 [ ]、Array、Object 三者之间的关系：

从 instanceof 能够判断出 [ ].__proto__  指向 Array.prototype，而 Array.prototype.__proto__ 又指向了Object.prototype，最终 Object.prototype.__proto__ 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：

![img](https://images2015.cnblogs.com/blog/849589/201601/849589-20160112232510850-2003340583.png)

从原型链可以看出，[] 的 __proto__  直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，**instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。**

##### **3、constructor**

当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后**在 prototype上添加一个 constructor 属性，并让其指向 F 的引用**。如下所示：

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125250566-1896556617.png)

当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 **F 原型上的 constructor 传递到了 f 上**，因此 f.constructor == F

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125714941-1649387639.png)

可以看出，**F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上**， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。

同样，JavaScript 中的内置对象在内部构建时也是这样做的：

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508131800457-2091987664.png)

> - null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。
>
> - 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508132757347-1999338357.png)

为什么变成了 Object？

因为 **prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。**

**因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改**。

##### **4、toString**

toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格

式为 [object Xxx] ，其中 Xxx 就是对象的类型。

对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / 

apply 来调用才能返回正确的类型信息。

```
Object.prototype.toString.call('') ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(Symbol()); //[object Symbol]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(newFunction()) ; // [object Function]
Object.prototype.toString.call(newDate()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(newRegExp()) ; // [object RegExp]
Object.prototype.toString.call(newError()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用
```



## 兼容性

webpak 引入autoprefixer，自动加上各种前缀让不同的浏览器得以支持

冒泡和捕获

```js
function pauseEvent(e) {
    if (e.stopPropagation) e.stopPropagation();
    e.cancelBubble = true;
}
//防止冒泡和捕获
w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true
```

取消默认事件

```js
function pauseEvent(e) {
    if (e.preventDefault) e.preventDefault();
    e.returnValue = false;
    return false;
}
//取消默认事件
w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;
//return false
javascript的return false只会阻止默认行为，而是用jQuery的话则既阻止默认行为又防止对象冒泡。
```

event事件对象

```js
var ev = ev || window.event 
document.documentElement.clientWidth || document.body.clientWidth 
var target = ev.srcElement||ev.target
```

设备像素比

```js
//获取设备像素比
var getPixelRatio = function (context) {
var backingStore =
context.backingStorePixelRatio ||
context.webkitBackingStorePixelRatio ||
context.mozBackingStorePixelRatio ||
context.msBackingStorePixelRatio ||
context.oBackingStorePixelRatio ||
context.backingStorePixelRatio ||
return (window.devicePixelRatio || 1) / backingStore;
};
var pixelRatio = getPixelRatio(canvas);
```

## 回到顶部

```js
//图标固定
  var c = 0;
  $(window).scroll(function (e) {
    let a = $(document).scrollTop() - $(".guide-box").offset().top;
    let b = $(".guide-ico").css("margin-top");
    b = b.substr(0, b.length - 2);
    if (a > 0 && a - c > 0 && a < $(".guide-box").height() * 0.8) {
      if (a  > b) {
        $(".guide-ico").css({
          top: a - b,
        });
      }
    }
    if (a > 0 && a - c < 0 &&a < $(".guide-box").height() * 0.8) {
      if (a > b) {
        $(".guide-ico").css({
          top: a-b,
        });
      }
    }
    c = a;
  });

```
## 时间

### 纯js

```js
//时间差
let t1 = moment().locale("zh-cn").format("YYYY-MM-DD HH:mm:ss");
let t2 = moment("2021-07-02 14:33:33");
let t3 = t2.diff(t1, "second"); //计算相差的秒
let d = Math.floor(Math.floor(Math.floor(t3 / 60) / 60) / 24); //相差的天
//时
let t = t3 - d * 24 * 60 * 60;
t = Math.floor(Math.floor(t / 60) / 60);
//分
let m = t3 - d * 24 * 60 * 60 - t * 60 * 60;
m = Math.floor(m / 60);
//秒
let s = t3 - d * 24 * 60 * 60 - t * 60 * 60 - m * 60;
```



```js
//比较时间
compareTime = (startTime, endTime) => {
    var start_time = startTime.replace(/-|\s|:|\//g, "");
    var end_time = endTime.replace(/-|\s|:|\//g, "");
    if (start_time < end_time) { return true; }
    else { return false; }
};
```

### moment

获取前一天的日期

```
moment(new Date()).subtract(1, "days").format("YYYY-MM-DD")
```

比较时间

```
compareTime = (startTime, endTime) => {
	return moment(startTime).isBefore(endTime)
};
```

以什么格式获取当前时间

```
let now = moment().locale('zh-cn').format('YYYY-MM-DD HH:mm:ss');
```

距离当前时间60天的moment对象

```
moment().subtract(60, 'days')
```

传入年份和月份 获取该年对应月份的天数

```
function getMonthDays(year,month){

 var thisDate = new Date(year,month,0); //当天数为0 js自动处理为上一月的最后一天

 return thisDate.getDate();

}
```

两个时间相差多少天

分别获取两个日期的[时间戳](https://so.csdn.net/so/search?q=时间戳&spm=1001.2101.3001.7020)，相减得到数值是毫秒，再换算成天（即除以1 * 24 * 60 * 60 * 1000）即可。

```js
/**
 * @param startDate  开始日期 yyyy-MM-dd
 * @param enDate  结束日期 yyyy-MM-dd
 * @returns {number} 两日期相差的天数
 */
 function getDaysBetween(startDate, enDate) {
  const sDate = Date.parse(startDate)
  const eDate = Date.parse(enDate)
  // if (sDate > eDate) {
  //   return 0
  // }
  if (sDate === eDate) {
    return 1
  }
  const days = (eDate - sDate) / (1 * 24 * 60 * 60 * 1000)
  return Math.abs(days)
}
console.log(getDaysBetween('2021-04-21', '2021-03-22')) // 输出结果为44275

```

## 获取url的参数

```
function getQueryVariable(variable){
    let a=window.location.href.split("?")[1];
    var query = a;
    var vars = query.split("&");
    for (var i=0;i<vars.length;i++) {
    var pair = vars[i].split("=");
    if(pair[0] == variable){return pair[1];}
    }
    return(false);
};

function getUrl(href = '') {
  var url =decodeURIComponent(href || window.location.href); //获取url中"?"符后的字串
  var theRequest = new Object();
  if (url.lastIndexOf("?") != -1) {
    var str =url.substring(url.lastIndexOf("?") + 1, url.length);
    const strs = str.split("&");
    for (var i = 0; i < strs.length; i++) {
      theRequest[strs[i].split("=")[0]] = unescape(strs[i].split("=")[1]);
    }
  }
  return theRequest;
}
```

## 数组转换为JSON数据

**方法一：使用Object.assign()**

Object.assign()方法将[枚举](https://so.csdn.net/so/search?q=枚举&spm=1001.2101.3001.7020)的所有属性的值从源对象（一个或多个）复制到目标对象

**语法：**

```javascript
Object.assign(target, ...sources)
```

```
var array = [34, 24, 31, 48];
JSON.stringify(Object.assign({}, array))
//'{"0":34,"1":24,"2":31,"3":48}'
```

## setTimeout

看以下例子可以知道，代码运行为6次打印了6。因为setTimeout因为是一个异步函数，var变量存在变量提升、无块级作用域等，等执行到setTimeout时，for循环已经遍历结束，i的值已经是6。

```js
for (var i = 0; i < 6; i++) {
  setTimeout(() => {
    console.log(i) //6,6,6,6,6,6
  }, 1000)
}
```

解决办法

1、闭包；使用闭包将i的值驻留在内存中，打印j的值（形成了自己的作用域），实际的外部函数的变量i

```js
for (var i = 0; i < 6; i++) {
  (function (j) {
    setTimeout(() => {
      console.log(j)// 0,1,2,3,4,5
    }, 1000)
  })(i)
}
```

2、setTimeout的第三个参数，该参数就是给setTimeout第一个函数的参数。每次传入setTimeout第一个函数的j值是for遍历的值，个人认为还是作用域的问题。

```js
for (var i = 0; i < 6; i++) {
  setTimeout(
    (j) => {
      console.log(j)// 0,1,2,3,4,5
    },
    1000,
    i
  )
}
```

## 数组循环中删除元素

```
(function () {
    var arr = [1, 2, 2, 3, 4, 5];
    for (var i = 0; i < arr.length; i++){
        // 打印数组中的情况，便于跟踪数组中数据的变化
        console.log(i + ' = ' + arr[i]);
        // 删除掉所有为2的元素
        if(arr[i] === 2) {
            arr.splice(i, 1);
        }
    }
    console.log(arr);
})();
```

产生这个结果的原因是因为，当删除掉了一个元素后，数组中元素的索引（下标）发生了实时变化，造成了程序的异常。

方案

1. 循环中索引添加递加判断,只有在不删除元素时才对索引递加

   ```
   for(var i=0; i<arr.length;) {
     if(arr[i].gender === 2) {
       arr.splice(i,1);
     }else{
       i++;
     }
   }
   ```

2. 倒序删除

   ```
   (function () {
       var arr = [1, 2, 2, 3, 4, 5];
       var i = arr.length;
       while(i--) {
           console.log(i + ' = ' + arr[i]);
           if(arr[i] === 2) {
               arr.splice(i, 1);
           }
        }
       console.log(arr);
   })();
   ```

   ## 业务
   
   ###  防抖/节流
   
   https://www.jianshu.com/p/c8b86b09daf0
   
   防抖和节流是针对**响应跟不上触发频率**这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。
   
   #### 防抖
   
   当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来**之前**，又一次触发了事件，就重新开始延时
   
   ![img](https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144209623-862434090.jpg)
   
   ##### **非立即执行版**
   
   ```jsx
   function debounce(func, wait) {
       let timeout;
       return function () {
           let context = this;
           let args = arguments;
   
           if (timeout) clearTimeout(timeout);
           
           timeout = setTimeout(() => {
               func.apply(context, args)
           }, wait);
       }
   }
   ```
   
   非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
   
   ![img](https://upload-images.jianshu.io/upload_images/4842858-1f6389b9dd9e5ef9.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1134/format/webp)
   
   ##### **立即执行版**
   
   ```jsx
   function debounce(func,wait) {
       let timeout;
       return function () {
           let context = this;
           let args = arguments;
   
           if (timeout) clearTimeout(timeout);
   
           let callNow = !timeout;
           timeout = setTimeout(() => {
               timeout = null;
           }, wait)
   
           if (callNow) func.apply(context, args)
       }
   }
   ```
   
   立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。
   
   ![img](https://upload-images.jianshu.io/upload_images/4842858-067785c056f182d8.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1140/format/webp)
   
   将非立即执行版和立即执行版的防抖函数结合起来，实现最终的双剑合璧版的防抖函数。
   
   ##### **双剑合璧版**
   
   ```jsx
   /**
    * @desc 函数防抖
    * @param func 函数
    * @param wait 延迟执行毫秒数
    * @param immediate true 表立即执行，false 表非立即执行
    */
   function debounce(func,wait,immediate) {
       let timeout;
   
       return function () {
           let context = this;
           let args = arguments;
   
           if (timeout) clearTimeout(timeout);
           if (immediate) {
               var callNow = !timeout;
               timeout = setTimeout(() => {
                   timeout = null;
               }, wait)
               if (callNow) func.apply(context, args)
           }
           else {
               timeout = setTimeout(function(){
                   func.apply(context, args)
               }, wait);
           }
       }
   }
   ```
   
   #### 节流
   
   **连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率**
   
   ![img](https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144342847-660853255.jpg)
   
   ##### 时间戳版
   
   ```jsx
   function throttle(func, wait) {
       let previous = 0;
       return function() {
           let now = Date.now();
           let context = this;
           let args = arguments;
           if (now - previous > wait) {
               func.apply(context, args);
               previous = now;
           }
       }
   }
   ```
   
   ![img](https://upload-images.jianshu.io/upload_images/4842858-80423b8898a27732.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1140/format/webp)
   
   可以看到，在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。
   
   ##### 定时器版:
   
   ```jsx
   function throttle(func, wait) {
       let timeout;
       return function() {
           let context = this;
           let args = arguments;
           if (!timeout) {
               timeout = setTimeout(() => {
                   timeout = null;
                   func.apply(context, args)
               }, wait)
           }
   
       }
   }
   ```
   
   ![img](https://upload-images.jianshu.io/upload_images/4842858-bf2ed4c8ed4f0ec0.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1136/format/webp)
   
   可以看到，在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。
   
   ##### 双剑合璧版
   
   ```tsx
   /**
    * @desc 函数节流
    * @param func 函数
    * @param wait 延迟执行毫秒数
    * @param type 1 表时间戳版，2 表定时器版
    */
   function throttle(func, wait ,type) {
       if(type===1){
           let previous = 0;
       }else if(type===2){
           let timeout;
       }
       return function() {
           let context = this;
           let args = arguments;
           if(type===1){
               let now = Date.now();
   
               if (now - previous > wait) {
                   func.apply(context, args);
                   previous = now;
               }
           }else if(type===2){
               if (!timeout) {
                   timeout = setTimeout(() => {
                       timeout = null;
                       func.apply(context, args)
                   }, wait)
               }
           }
       }
   }
   ```
   
   ### Web Notification桌面通知
   
   https://daotin.netlify.app/gc12ta.html#%E6%9C%80%E5%90%8E
   
   #### 开始
   
   要创建一个消息通知，非常简单，直接使用 window 对象下面的`Notification`类即可，代码如下：
   
   ```text
   var n = new Notification("桌面推送", {
      icon: 'img/icon.png',
      body: '这是我的第一条桌面通知。',
      image:'img/1.jpg'
   }); 
   ```
   
   于是你就会看到系统桌面弹出我上面那张截图的通知。
   
   > PS：消息通知只有通过`Web服务访问`该页面时才会生效，如果直接双击打开本地文件，是没有任何效果的。也就是说你的文件需要使用服务器的形式打开，而不是直接使用浏览器打开本地文件。
   
   当然也有可能你什么都没看到，别着急继续往下看。
   
   #### 基本语法
   
   当然在想要弹出上面通知之前，有必要了解一下一个通知的基本语法：
   
   ```text
   let myNotification = new Notification(title, options); 
   ```
   
   `title`：定义一个通知的标题，当它被触发时，它将显示在通知窗口的顶部。
   
   `options`（可选）对象包含应用于通知的任何自定义设置选项。
   
   常用的选项有：
   
   - body: 通知的正文，将显示在标题下方。
   
   - tag: 类似每个通知的ID，以便在必要的时候对通知进行刷新、替换或移除。
   
   - icon:  显示通知的图标
   
   - image: 在通知正文中显示的图像的URL。
   
   - data: 您想要与通知相关联的任意数据。这可以是任何数据类型。
   
   - renotify: 一个 Boolean 指定在新通知替换旧通知后是否应通知用户。默认值为false，这意味着它们不会被通知。
   
   - requireInteraction: 表示通知应保持有效，直到用户点击或关闭它，而不是自动关闭。默认值为false。
   
   当这段代码执行时，浏览器会询问用户，是否允许该站点显示消息通知，如下图所示：
   
   
   
   ![img](https://raw.githubusercontent.com/Daotin/pic/master/img/20190727155108.png)
   
   只有用户点击了`允许`，授权了通知，通知才会被显示出来。
   
   #### 授权
   
   *如何获取到用户点击的是“允许”还是“阻止”呢？*
   
   window的 Notification实例有一个 `requestPermission` 函数用来获取用户的授权状态：
   
   ```text
   // 首先，我们检查是否具有权限显示通知
    // 如果没有，我们就申请权限
    if (window.Notification && Notification.permission !== "granted") {
        Notification.requestPermission(function (status) {
        //status是授权状态。
        //如果用户点击的允许，则status为'granted'
        // 如果用户点击的禁止，则status为'denied'
       
        // 这将使我们能在 Chrome/Safari 中使用 Notification.permission
        if (Notification.permission !== status) {
          Notification.permission = status;
        }
      });
    } 
   ```
   
   > 注意：如果用户点击了授权右上角的关闭按钮，则status的值为default。
   
   之后，我们只需要判断 status 的值是否为`granted`，来决定是否显示通知。
   
   #### 通知事件
   
   但是单纯的显示一个消息框是没有任何吸引力的，所以消息通知应该具有一定的交互性，在显示消息的前前后后都应该有事件的参与。
   
   Notification一开始就制定好了一系列事件函数，开发者可以很方面的使用这些函数处理用户交互：
   
   有：`onshow`,`onclick`,`onerror`,`onclose`。
   
   ```text
   var n = new Notification("桌面推送", {
      icon: 'img/icon.png',
      body: '这是我的第一条桌面通知。'
   });
   
   //onshow函数在消息框显示时触发
   //可以做一些数据记录及定时关闭消息框等
   n.onshow = function() {
      console.log('显示消息框');
      //5秒后关闭消息框
      setTimeout(function() {
          n.close();
      }, 3000);
   };
   
   //消息框被点击时被调用
   //可以打开相关的视图，同时关闭该消息框等操作
   n.onclick = function() {
      console.log('点击消息框');
      // 打开相关的视图
      n.close();
   };
   
   //当有错误发生时会onerror函数会被调用
   //如果没有granted授权，创建Notification对象实例时，也会执行onerror函数
   n.onerror = function() {
      console.log('消息框错误');
      // 做些其他的事
   };
   
   //一个消息框关闭时onclose函数会被调用
   n.onclose = function() {
      console.log('关闭消息框');
      //做些其他的事
   }; 
   ```
   
   #### 一个简单的例子
   
   ```text
      <meta charset="UTF-8">
      <title>Document</title>
    
    
      <button>点击发起通知</button>
    
    <script>
      window.addEventListener("load", function() {
        // 首先，让我们检查我们是否有权限发出通知
        // 如果没有，我们就请求获得权限
        if (window.Notification && Notification.permission !== "granted") {
          Notification.requestPermission(function(status) {
            if (Notification.permission !== status) {
              Notification.permission = status;
            }
          });
        }
   
        var button = document.getElementsByTagName("button")[0];
   
        button.addEventListener("click", function() {
          // 如果用户同意就创建一个通知
          if (window.Notification && Notification.permission === "granted") {
            var n = new Notification("Hi！");
          }
   
          // 如果用户没有选择是否显示通知
          // 注：因为在 Chrome 中我们无法确定 permission 属性是否有值，因此
          // 检查该属性的值是否是 "default" 是不安全的。
          else if (window.Notification && Notification.permission !== "denied") {
            Notification.requestPermission(function(status) {
              if (Notification.permission !== status) {
                Notification.permission = status;
              }
   
              // 如果用户同意了
              if (status === "granted") {
                var n = new Notification("Hi!");
              }
   
              // 否则，我们可以让步的使用常规模态的 alert
              else {
                alert("Hi!");
              }
            });
          }
   
          // 如果用户拒绝接受通知
          else {
            // 我们可以让步的使用常规模态的 alert
            alert("Hi!");
          }
        });
      });
    </script>
   ```
   
   当我们打开界面的时候，就会弹出授权申请，如果我们点击`允许`，然后点击按钮，就可以发送一条通知到桌面，我们就可以在桌面右下角看到这条通知。
   
   
   
   ![img](https://raw.githubusercontent.com/Daotin/pic/master/img/20190727155403.png)
   
   
   
   上面我们只是显示一条消息。
   
   ```text
   if (status === "granted") {
    var n = new Notification("Hi");
   } 
   ```
   
   如果我们有很多消息的话，比如我是用个for循环来模拟大量通知的情况。
   
   ```text
   for(var i=0; i<10; i++) {
      var n = new Notification("Hi,"+i);
   } 
   ```
   
   可以看到有10条通知都显示出来。但是某些情况下对于用户来说，显示大量通知是件令人痛苦的事情。
   
   ![img](https://raw.githubusercontent.com/Daotin/pic/master/img/20190727155632.png)
   
   
   
   比如，如果一个即时通信应用向用户提示每一条传入的消息。为了避免数以百计的不必要通知铺满用户的桌面，可能需要接管一个挂起消息的队列。
   
   因此，需要为新建的通知添加一个`标记`。
   
   如果有一条新通知和上一条通知具有相同的标记，那么这条新通知将会替换上一条通知，最后桌面上只会显示最新的通知。
   
   还是上面的例子，只需要在触发通知加个`tag`属性即可：
   
   ```text
   for (var i = 0; i < 10; i++) {
     // 最后只看到内容为 "Hi! 9" 的通知
      var n = new Notification("Hi! " + i, {tag: 'soManyNotification'});
   } 
   ```
   
   #### 最后
   
   消息通知是个不错的特性，可是也不排除有些站点恶意的使用这个功能，一旦用户授权之后，不时的推送一些不太友好的消息，打扰用户的工作，这个时候我们可以移除该站点的权限，禁用其消息通知功能。
   
   ![img](https://raw.githubusercontent.com/Daotin/pic/master/img/20190727155205.png)
   
   我们可以点击浏览器地址输入框左边的叹号就有一个通知的选项，我们可以修改授权。或者在通知页面也有修改通知的选项，可以根据具体情况进行修改授权通知。
   
   ![img](https://raw.githubusercontent.com/Daotin/pic/master/img/20190727155225.png)
   
   于是最基本的 Web Notification 就实现了。
   
   

## 异步

### **async**

```js
//在async中将异步的代码同步执行
var a = async () => {
  console.log(1);
  function fn(){
    setTimeout(()=>{
        console.log(5)
    })
  }
  await fn()
  // await的Promise会同步执行完
  await的 new Promise((resolved) => {
    console.log(2);
    resolved(3);
  }).then((v) => {
    console.log(v);
  });
  console.log(4);
};
a();
```

```
1 ​​​​​at ​quokka.js:2:2​

2 ​​​​​at ​quokka.js:10:4​

3 ​​​​​at ​​​v​​​ ​quokka.js:13:4​

4 ​​​​​at ​quokka.js:16:2​

5 ​​​​​at ​quokka.js:5:8​
```

```js
async function f1(){
  console.log(2);
  await f2()
  console.log(6);
}
async function f2(){
  console.log(3);
}
console.log(1);
setTimeout(() => {
  console.log(8);
}, 0);
f1()
new Promise((resolved)=>{
  console.log(4);
  resolved(7)
}).then((res)=>{
  console.log(res);
})
console.log(5);

很多人以为await会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上await会产生一个微任务(Promise.then是微任务)。await后面的函数会执行一遍，然后就会跳出整个async函数来执行后面js栈的代码。等本轮事件循环执行完了之后又会跳回到async函数中执行剩下的代码

```



```
1 ​​​​​at ​​​​​​quokka.js:9:1​

2 ​​​​​at ​​​​​​quokka.js:2:3​

3 ​​​​​at ​​​​​​quokka.js:7:3​

4 ​​​​​at ​​​​​​quokka.js:15:3​

5 ​​​​​at ​​​​​​quokka.js:20:1​

6 ​​​​​at ​​​​​​quokka.js:4:3​

7 ​​​​​at ​​​​​​​​res​​​ ​quokka.js:18:3​

8 ​​​​​at ​​​​​​quokka.js:11:3​
```

### **promise**

```js
let a = new Promise((resolve, reject) => {
  console.log(1);
  setTimeout(() => {
    console.log(2);
    resolve(3)
}, 1000);
});
a.then((index) => {
  console.log(index);
});
console.log(a);
```

```
1 ​​​​​at ​​​​​​quokka.js:2:3​

Promise { <pending> }
  ​​​​​at ​​​​​​​​a​​​ ​quokka.js:11:1​

2 ​​​​​at ​​​​​​quokka.js:4:5​

3 ​​​​​at ​​​​​​​​index​​​ ​quokka.js:9:3​
```

```js
new Promise((resolved,reject)=>{
  console.log(1);
  resolved(2)
  console.log(3);
  resolved(4)
  console.log(5);
  reject(4)
}).then((res)=>{
  console.log(res);
}).catch((res)=>{
  console.log(res);
})

JavaScript具有"从头到尾"的概念。 除非抛出错误/return，否则函数将一直执行直到return语句或其结尾。
```

```
1 ​​​​​at ​​​​​​quokka.js:2:3​

3 ​​​​​at ​​​​​​quokka.js:4:3​

5 ​​​​​at ​​​​​​quokka.js:6:3​

2 ​​​​​at ​​​​​​​​res​​​ ​quokka.js:9:3​
```

```js
new Promise((resolved, reject) => {
  throw new Error('x 必须为正数');
}).then((res) => {
  console.log(res);
}).catch((res) => {
  console.log(res);
})
```

```
[Error: x 必须为正数] ​​​​​at ​​​​​​​​res​​​ ​quokka.js:6:3​
```

# 编程题

## 时间空间复杂度

log：https://blog.csdn.net/weixin_39888180/article/details/111268391

### 时间复杂度

其实就是一个函数，用大 O 表示， 比如 O(1)、 O(n)...

它的作用就是用来`定义描述算法的运行时间`

- **O(1)**

```
    let i = 0
    i += 1
复制代码
```

- **O(n)：** 如果是 O(1) + O(n) 则还是 O(n)

```
    for (let i = 0; i < n; i += 1) {
      console.log(i)
    }
复制代码
```

- **O(n^2)：** O(n) * O(n), 也就是双层循环，自此类推：O(n^3)...

```
    for (let i = 0; i < n; i += 1) {
      for (let j = 0; j < n; j += 1) {
        console.log(i, j)
      }
    }
复制代码
```

- **O(logn)：** 就是求 log 以 2 为底的多少次方等于 n

```
    // 这个例子就是求2的多少次方会大于i，然后就会结束循环。 这就是一个典型的 O(logn)
    let i = 1
    while (i < n) {
      console.log(i)
      i *= 2
    }
复制代码
```

###  空间复杂度

和时间复杂度一样，空间复杂度也是用大 O 表示，比如 O(1)、 O(n)...

它用来`定义描述算法运行过程中临时占用的存储空间大小`

> 占用越少 代码写的就越好

- **O(1)：** 单个变量，所以占用永远是 O(1)

```
    let i = 0
    i += 1
复制代码
```

- **O(n)：** 声明一个数组， 添加 n 个值， 相当于占用了 n 个空间单元

```
    const arr = []
    for (let i = 0; i < n; i += 1) {
      arr.push(i)
    }
复制代码
```

- **O(n^2)：** 类似一个矩阵的概念，就是二维数组的意思

```
    const arr = []
    for (let i = 0; i < n; i += 1) {
      arr.push([])
      for (let j = 0; j < n; j += 1) {
        arr[i].push(j)
      }
    }
```

### 查找

#### 二分法

二分法查找是一种速度非常快的算法，但是它有固定的应用范围。仅当列表是有序的时候，二分查找才管用。

  > 采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边

### 排序

#### 快速排序

  - （1）在数据集之中，找一个基准点
  - （2）建立两个数组，分别存储左边和右边的数组
  - （3）利用递归进行下次比较

```js
var arr = [3, 1, 4, 6, 5, 7, 2];

function quickSort(arr) {
    if(arr.length == 0) {
        return [];    // 返回空数组
    }

    var cIndex = Math.floor(arr.length / 2);
    var c = arr.splice(cIndex, 1);
    var l = [];
    var r = [];

    for (var i = 0; i < arr.length; i++) {
        if(arr[i] < c) {
            l.push(arr[i]);
        } else {
            r.push(arr[i]);
        }
    }

    return quickSort(l).concat(c, quickSort(r));
}

console.log(quickSort(arr));
```

## 深拷贝与浅拷贝

https://mp.weixin.qq.com/s/BQ3_RJQcCZiXphMoyMRaTg

基本数据类型的特点：直接存储在栈(stack)中的数据
引用数据类型的特点：存储的是该对象在栈中引用地址，真实的数据存放在堆内存里。引用数据类型在栈中存储了指针，指针指向堆中该实体的起始地址

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

#### 实现浅拷贝

浅拷贝只拷贝基本数据的内容，引用数据虽然栈不同但会共用一个堆

##### Object.assign()

![图片描述](https://segmentfault.com/img/bVbrl7t?w=541&h=138)

注意：当object只有一层的时候，是深拷贝

##### 展开运算符...

```
let obj1 = { name: 'Kobe', address:{x:100,y:100}}
let obj2= {... obj1}
obj1.address.x = 200;
obj1.name = 'wade'
console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }
```

##### concat()

```
let arr = [1, 3, {
    username: 'kobe'
    }];
let arr2 = arr.concat();    
arr2[2].username = 'wade';
console.log(arr); //[ 1, 3, { username: 'wade' } ]
```

##### slice()

![图片描述](https://segmentfault.com/img/bVbrmbB?w=424&h=185)

#### 实现深拷贝

![img](https://image-static.segmentfault.com/809/484/809484289-5cb44d922e659_fix732)

```js
function deepClone(obj, newObj) {
  var newObj = newObj || {};
  for (let key in obj) {
    if (typeof obj[key] == 'object') {
      let isArray = Array.isArray(obj[key]);//判断是否数组
      newObj[key] = (isArray == true ? [] : {})
      deepClone(obj[key], newObj[key]);
    } else {
      newObj[key] = obj[key]
    }
  }
  console.log(newObj);
  return newObj;
}

let a1 = { a: { b: 1 } }
let a2 = deepClone(a1);
a1.a.b = 2;
console.log(a2.a);
```




```js
function deepClone(source) {
    let target;
    if (typeof source === 'object') {
      target = Array.isArray(source) ? [] : {}
      for (let key in source) {
        if (source.hasOwnProperty(key)) {
          if (typeof source[key] !== 'object') {
            target[key] = source[key]
          } else {
            target[key] = deepClone(source[key])
          }
        }
      }
    } else {
      target = source
    }
    return target
  }
  let a ={name:['a','b'],age:[10,15],book:{1:[2,3,k]}}
  let b = deepClone(a)
  console.log(a)
  console.log(a == b)
  let c = a
  console.log(c)
  console.log(c == a)
```

```js
JSON.parse(JSON.stringify(xxx))

我们在使⽤ JSON.parse(JSON.stringify(xxx))时应该注意⼀下⼏点：
1、如果obj⾥⾯存在时间对象，JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。
2、如果obj⾥有RegExp、Error对象，则序列化的结果将只得到空对象。
3、如果obj⾥有函数，undefined，则序列化的结果会把函数， undefined丢失。
4、如果obj⾥有NaN、Infinity和-Infinity，则序列化的结果会变成null。
5、JSON.stringify()只能序列化对象的可枚举的⾃有属性。如果obj中的对象是有构造函数⽣成的，则使⽤JSON.parse(JSON.stringify(obj))
深拷贝后，会丢弃对象的constructor。
6、如果对象中存在循环引⽤的情况也⽆法正确实现深拷贝。
```

## 递归

### 阶乘

```js
  const factorial = function(n) {
      if (n <= 1) {
          return 1;
      }
      return n * factorial(n - 1);
  }
```

f(6) = n * f(5)，所以 f(6) 需要拆解成 f(5) 子问题进行求解，以此类推 f(5) = n * f(4) ，也需要进一步拆分 ... 直到 f(1)，「这是递的过程。」 f(1) 解决后，依次可以解决f(2).... f(n)最后也被解决，「这是归的过程。」

归无非就是把问题拆解成具有相同解决思路的子问题，直到最后被拆解的子问题不能够拆分，这个过程是“递”。当解决了最小粒度可求解的子问题后，在“归”的过程中顺其自然的解决了最开始的问题。

  **复杂度分析**

  - 空间复杂度为 O(n)
  - 时间复杂度 O(2^n)

```
  总时间 = 子问题个数 * 解决一个子问题需要的时间
```

  - 子问题个数即递归树中的节点总数 2^n
  - 解决一个子问题需要的时间，因为只有一个加法操作 `fib(n-1) + fib(n-2)` ，所以解决一个子问题的时间为 `O(1)`

  二者相乘，得出算法的时间复杂度为 `O(2^n)`

### 实现深拷贝

![img](https://image-static.segmentfault.com/809/484/809484289-5cb44d922e659_fix732)

```js
function deepClone(obj, newObj) {
  var newObj = newObj || {};
  for (let key in obj) {
    if (typeof obj[key] == 'object') {
      let isArray = Array.isArray(obj[key]);//判断是否数组
      newObj[key] = (isArray == true ? [] : {})
      deepClone(obj[key], newObj[key]);
    } else {
      newObj[key] = obj[key]
    }
  }
  console.log(newObj);
  return newObj;
}

let a1 = { a: { b: 1 } }
let a2 = deepClone(a1);
a1.a.b = 2;
console.log(a2.a);
```




```js
function deepClone(source) {
    let target;
    if (typeof source === 'object') {
      target = Array.isArray(source) ? [] : {}
      for (let key in source) {
        if (source.hasOwnProperty(key)) {
          if (typeof source[key] !== 'object') {
            target[key] = source[key]
          } else {
            target[key] = deepClone(source[key])
          }
        }
      }
    } else {
      target = source
    }
    return target
  }
  let a ={name:['a','b'],age:[10,15],book:{1:[2,3,k]}}
  let b = deepClone(a)
  console.log(a)
  console.log(a == b)
  let c = a
  console.log(c)
  console.log(c == a)
```

```js
JSON.parse(JSON.stringify(xxx))

我们在使⽤ JSON.parse(JSON.stringify(xxx))时应该注意⼀下⼏点：
1、如果obj⾥⾯存在时间对象，JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。
2、如果obj⾥有RegExp、Error对象，则序列化的结果将只得到空对象。
3、如果obj⾥有函数，undefined，则序列化的结果会把函数， undefined丢失。
4、如果obj⾥有NaN、Infinity和-Infinity，则序列化的结果会变成null。
5、JSON.stringify()只能序列化对象的可枚举的⾃有属性。如果obj中的对象是有构造函数⽣成的，则使⽤JSON.parse(JSON.stringify(obj))
深拷贝后，会丢弃对象的constructor。
6、如果对象中存在循环引⽤的情况也⽆法正确实现深拷贝。
```

### 树形结构

```js
const input = [
  {
    name: "浙江",
    children: [
      {
        name: "杭州",
        children: [
          { name: "余杭区" },
          { name: "上城区" },
          { name: "下城区" },
          { name: "西湖区" },
          { name: "拱墅区" },
        ],
      },
      {
        name: "绍兴",
        children: [
          { name: "柯桥区" },
          { name: "越城区" },
          { name: "上虞区" },
          { name: "新昌县" },
        ],
      },
    ],
  },
  {
    name: "湖北",
    children: [
      {
        name: "武汉",
        children: [
          { name: "江岸区" },
          { name: "江汉区" },
          { name: "硚口区" },
          { name: "汉阳区" },
          { name: "武昌区" },
          { name: "青山区" },
          { name: "洪山区" },
        ],
      },
    ],
  },
];
```

#### 获取树的叶子节点并赋值到树结构中

```js
const input = [
  {
    name: "浙江",
    children: [
      {
        name: "杭州",
        children: [
          { name: "余杭区" },
          { name: "上城区" },
          { name: "下城区" },
          { name: "西湖区" },
          { name: "拱墅区" },
        ],
      },
      {
        name: "绍兴",
        children: [
          { name: "柯桥区" },
          { name: "越城区" },
          { name: "上虞区" },
          { name: "新昌县" },
        ],
      },
    ],
  },
  {
    name: "湖北",
    children: [
      {
        name: "武汉",
        children: [
          { name: "江岸区" },
          { name: "江汉区" },
          { name: "硚口区" },
          { name: "汉阳区" },
          { name: "武昌区" },
          { name: "青山区" },
          { name: "洪山区" },
        ],
      },
    ],
  },
];
function process(input) {
  function getLeafCountTree(arr) {
    if (!arr.children) {
      return 1;
    } else {
      arr.leafCount = 0;
      for (var i = 0; i < arr.children.length; i++) {
        arr.leafCount = arr.leafCount + getLeafCountTree(arr.children[i]);
      }
      //需要将次层的叶子节点return给父级
      return arr.leafCount;
    }
  }
  function finalQuery() {
    //因为是数组，不是树形结构，需要以树形结构处理
    for (var r = 0; r < input.length; r++) {
      getLeafCountTree(input[r]);
    }
  }
  finalQuery();
  return input
}
console.log(process(input));

const output = [
  {
    name: "浙江",
    path: "浙江",
    leafCount: 9,
    children: [
      {
        name: "杭州",
        path: "浙江-杭州",
        leafCount: 5,
        children: [
          { name: "余杭区", path: "浙江-杭州-余杭区" },
          { name: "上城区", path: "浙江-杭州-上城区" },
          { name: "下城区", path: "浙江-杭州-下城区" },
          { name: "西湖区", path: "浙江-杭州-西湖区" },
          { name: "拱墅区", path: "浙江-杭州-拱墅区" },
        ],
      },
      {
        name: "绍兴",
        path: "浙江-绍兴",
        leafCount: 4,
        children: [
          { name: "柯桥区", path: "浙江-绍兴-柯桥区" },
          { name: "越城区", path: "浙江-绍兴-越城区" },
          { name: "上虞区", path: "浙江-绍兴-上虞区" },
          { name: "新昌县", path: "浙江-绍兴-新昌县" },
        ],
      },
    ],
  },
  {
    name: "湖北",
    path: "湖北",
    leafCount: 7,
    children: [
      {
        name: "武汉",
        path: "湖北-武汉",
        leafCount: 7,
        children: [
          { name: "江岸区", path: "湖北-武汉-江岸区" },
          { name: "江汉区", path: "湖北-武汉-江汉区" },
          { name: "硚口区", path: "湖北-武汉-硚口区" },
          { name: "汉阳区", path: "湖北-武汉-汉阳区" },
          { name: "武昌区", path: "湖北-武汉-武昌区" },
          { name: "青山区", path: "湖北-武汉-青山区" },
          { name: "洪山区", path: "湖北-武汉-洪山区" },
        ],
      },
    ],
  },
];
```

#### 根据id，拿到id数组

```js
// (tree为目标树，targetId为目标节点id)
function getNodeRoute(tree, targetId) {
  let nodePathArray = []
  let fn = (tree, targetId) => {
    for (let index = 0; index < tree.length; index++) {
      if (tree[index].children) {
        let endRecursiveLoop = fn(tree[index].children, targetId)
        if (endRecursiveLoop) {
          nodePathArray.push(tree[index].name)
          return true
        }
      }
      if (tree[index].name === targetId) {
        nodePathArray.push(tree[index].name)
        return true
      }
    }
  }
  fn(tree, targetId)
  return nodePathArray;
}

getNodeRoute(input, '余杭区')
console.log(getNodeRoute(input, '余杭区').reverse());
//[ '浙江', '杭州', '余杭区' ]
```

####   案例

- 使用递归实现`getElementsByClassName`

  ```js
  let arr = [];
     function byClass(node, className, arr){
         //得到传入节点的所有子节点
         var lists = node.childNodes;
         for(var i = 0;i< lists.length;i++){
             //判断是否有相同className元素
             if(arr[i],className == className){
                 arr.push(arr[i]);
             }
             //判断子节点是否还有子节点
             if(arr[i].childNodes.length > 0){
                 byClass(arr[i],className,arr);
             }
         }
     }
  复制代码
  ```

- 有一堆桃子，每天吃掉一半，挑出一个坏的扔掉，第6天的时候发现还剩1个桃子，问原来有多少个桃子。


```js
  function fn(n) {
    if (n === 1) {
      return 1
    }
    var a = (fn(n - 1) + 1) * 2
    return a
  }
  console.log(fn(2)) //190
```
# 浏览器

将浏览器的前进按钮禁止

```js
// 将浏览器的前进按钮禁止
import $ from "jquery";
$(function () {
  if (window.history && window.history.pushState) {
    $(window).on('popstate', function () {
      // console.log(window.location.href)
      if (window.location.href.indexOf(window.location.origin + "/wechatpub/surveyOne")>-1) {
        // console.log(window.location.href,"==========================")
        window.history.pushState('forward', null, '#');
        window.history.forward(1);
      }
    });
  }
  // window.history.pushState('forward', null, '#'); //在IE中必须得有这两行
  // window.history.forward(1);
})
```

# 业务问题


## AntD

### Form

```
rules={[
    ({ getFieldValue }) => ({
        validator(_, value) {
        if (value.valueOf() > getFieldValue('onlineTime').valueOf() 					|| !value) {
        	return Promise.resolve();
        }
        return Promise.reject(new Error('上线时间大于当前时间'));
        },
    }),
]}
```

  

```
const formRef = useRef<any>();
formRef.current.setFieldsValue({
    putNum: state.crowdData.putNum,
    putPhone: state.crowdData.putPhone,
    putEmail: state.crowdData.putEmail
})
<Form ref={formRef} initialValues={initialValues} {...Formlayout}><Form>
```

### upload

```jsx
  const uploadProps = {
    // name: "file",
    action: "",
    accept: ".doc, .docx",
    multiple: false, //是否支持多选文件
    fileList: uploadTypeList,
    showUploadList: {
      showDownloadIcon: true,
      downloadIcon: 'download ',
      showRemoveIcon: true,
      removeIcon: <i className='iconfont iconshanchu3' onClick={() => removeIcon()}/>,
    },
    iconRender() {
      return <img src={`${PUBLIC_CDN_URL}/images/dashboard/upload_file.png`} alt='' 			className={styles.upload_file}/>
    },
    onRemove() {
      setUploadTypeList([])
    }
    onChange(info) {
      console.log(info, uploadTypeList)
      let ext = info.file.name ? info.file.name.split('.')[1] : '';
      let reg = /[*&<>%?:;\\/|"]/im
      if (ext) {
        if (!(ext === 'doc' || ext === 'docx')) {
          message.error('您只能上传doc，docx 文件!');
        } else if (reg.test(info.file.name)) {
          message.error('文件名不能包含下列任何字符串：* & < > % ? : ; \\ / | "');
          return false;
        } else {
          message.loading({ content: '文件上传中...', key: 'export' });
          const formData = new FormData();
          formData.append('file_upload', info.file);
          console.log(info, uploadTypeList)
          // setUploadLocalList([info.file])
          // uploadTopic.run(formData);
        }
      } else {
      }
    },
  }
```

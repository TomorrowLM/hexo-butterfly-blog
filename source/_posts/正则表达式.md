---
slug: 正则表达式
title: 正则表达式
description: 正则表达式
keywords: 正则表达式
category: 正则表达式
tags: [正则表达式]
author: liming
date: 25-September-2020
cover: https://i0.hippopx.com/photos/457/88/1021/microphone-boy-studio-screaming-preview.jpg
---

# 正则表达式的组成

- 普通字符abc  123
- 特殊字符(元字符)：正则表达式中有特殊意义的字符\d  \w

## 元字符

### 常用元字符串

| 元字符 | 说明                                         |
| ------ | -------------------------------------------- |
| \d     | 匹配数字                                     |
| \D     | 匹配任意非数字的字符                         |
| \w     | 匹配字母或数字或下划线                       |
| \W     | 匹配任意不是字母，数字，下划线               |
| \s     | 匹配任意的空白符（包括空格、制表符、换页符） |
| \S     | 匹配任意不是空白符的字符                     |
| .      | 匹配除换行符以外的任意单个字符               |

### 限定符

| 限定符      | 说明                                                   |                                                              |
| ----------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| *           | 表达式尽可能的多匹配，最少可以不匹配，相当于 **{0, }** |                                                              |
| +           | 表达式尽可能的多匹配，至少匹配1次，相当于 **{1, }**    | “zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}         |
| ?           | 表达式尽可能匹配1次，也可以不匹配，相当于 **{0, 1}**   | “do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。          |
| {n}         | 表达式固定重复n次                                      | “o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。      |
| {n,}        | 表达式尽可能的多匹配，至少重复n次                      | “o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o*” |
| {n,m}       | 表达式尽可能重复m次，至少重复n次                       | “o{1,3}”匹配“fooooood”中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。 |
| **{n, m}?** | 表达式尽量只匹配n次，最多重复m次。                     |                                                              |
| **{m, n}+** | 表达式尽可能重复n次，至少重复m次。                     |                                                              |

- 贪婪模式:在限定符之后的表达式能够匹配成功的情况下，不定次数的限定符总是**尽可能的多匹配**。如果之后的表达式匹配失败，限定符可适当“让出”能够匹配的字符，以使整个表达式匹配成功。这种模式就叫“贪婪模式”。

  - 限定符之后添加加号(+),总是尽可能多的匹配

- 非贪婪匹配模式:正则表达式去匹配时，会尽量少的匹配符合条件的内容 也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有`g`，开启下一组匹配)

  - 限定符之后添加问号(?),总是尽可能少的匹配

- ```js
  // 前瞻/先行断言：
  exp1(?=exp2) 查找exp2前面的exp1
  // 后顾：
  (?<=exp2)exp1 查找exp2后面的exp1
  // 负前瞻：
  exp1(?!exp2) 查找后面不是exp2的exp1
  // 负后顾：
  (?<!exp2)exp1 查找前面不是exp2的exp1



### 其它

- 边界

  | ^      | 表示匹配行首的文本(以谁开始)                     |
  | ------ | ------------------------------------------------ |
  | $      | 表示匹配行尾的文本(以谁结束)                     |
  | **\b** | 当前位置的左右两侧，只能有一侧是字母数字或下划线 |

- 转义符

  | 表达式 | 可匹配           |
  | ------ | ---------------- |
  | \r, \n | 代表回车和换行符 |
  | \t     | 制表符           |
  | \\     | 代表 "\" 本身    |

- **有特殊用处的标点符号，在前面加 “\” 后，就代表该符号本身**

  | 表达式 | 可匹配              |
  | ------ | ------------------- |
  | \^     | 匹配 ^ 符号本身     |
  | \ $    | 匹配 $ 符号本身     |
  | \ .    | 匹配小数点（.）本身 |

- 方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。[^]  匹配除中括号以内的内容

  | 表达式        | 可匹配                                  |
  | ------------- | --------------------------------------- |
  | **[ab5@]**    | 匹配 "a" 或 "b" 或 "5" 或 "@"           |
  | **[^abc]**    | 匹配 "a","b","c" 之外的任意一个字符     |
  | **[f-k]**     | 匹配 "f"~"k" 之间的任意一个字母         |
  | **[^A-F0-3]** | 匹配 "A"~"F","0"~"3" 之外的任意一个字符 |

- | 选择左右两边的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱。

- () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\(` 和 `\)`。

     从两个直接量中选择一个，分组
     eg：gr(a|e)y匹配gray和grey
     [\u4e00-\u9fa5]  匹配汉字

## 案例

```
验证手机号：^\d{11}$
验证邮编：^\d{6}$
验证日期 2012-5-01 ^\d{4}-\d{1,2}-\d{1,2}$
验证邮箱 xxx@itcast.cn：^\w+@\w+\.\w+$
验证IP地址 192.168.1.10 ^\d{1,3}\(.\d{1,3}){3}$
```



```
[正则表达式]文本框输入内容控制
 整数或者小数：^[0-9]+.{0,1}[0-9]{0,2}$
 只能输入数字："^[0-9]*$"。
 只能输入n位的数字："^d{n}$"。
 只能输入至少n位的数字："^d{n,}$"。
 只能输入m~n位的数字：。"^d{m,n}$"
 只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。
 只能输入有两位小数的正实数："^[0-9]+(.[0-9]{2})?$"。
 只能输入有1~3位小数的正实数："^[0-9]+(.[0-9]{1,3})?$"。
 只能输入非零的正整数："^+?[1-9][0-9]*$"。
 只能输入非零的负整数："^-[1-9][]0-9"*$。
 只能输入长度为3的字符："^.{3}$"。
 只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。
 只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。
 只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。
 只能输入由数字和26个英文字母组成的字符串："^[A-Za-z0-9]+$"。
 只能输入由数字、26个英文字母或者下划线组成的字符串："^w+$"。
 验证是否含有^%&',;=?$"等字符："[^%&',;=?$x22]+"。
 只能输入汉字："^[u4e00-u9fa5]{0,}$"
 验证Email地址："^w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$"。
 验证InternetURL："^http://([w-]+.)+[w-]+(/[w-./?%&=]*)?$"。
 验证电话号码："^((d{3,4}-)|d{3.4}-)?d{7,8}$"正确格式为："XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX"。
 验证身份证号（15位或18位数字）："^d{15}|d{18}$"。
 验证一年的12个月："^(0?[1-9]|1[0-2])$"正确格式为："01"～"09"和"1"～"12"。
 验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$"正确格式为；"01"～"09"和"1"～"31"。
 匹配中文字符的正则表达式： [u4e00-u9fa5]
 匹配双字节字符(包括汉字在内)：[^x00-xff]
 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
 String.prototype.len=function(){return this.replace(/[^x00-xff]/g,"aa").length;}
 匹配空行的正则表达式：n[s| ]*r
 匹配html标签的正则表达式：<(.*)>(.*)</(.*)>|<(.*)/>
 匹配首尾空格的正则表达式：(^s*)|(s*$)
 匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*
 匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&=]*)?

```

# JavaScript 中使用正则表达式

## 创建正则对象

方式1：

```javascript
var reg = new RegExp('\d', 'i');
var reg = new RegExp('\d', 'gi');
```

方式2：

```javascript
var reg = /\d/i;
var reg = /\d/gi;
```

**参数**

| 标志 | 说明                |
| ---- | ------------------- |
| i    | 忽略大小写          |
| g    | 全局匹配            |
| gi   | 全局匹配+忽略大小写 |

## 正则匹配

```javascript
// 匹配日期
var dateStr = '2015-10-10';
var reg = /^\d{4}-\d{1,2}-\d{1,2}$/
console.log(reg.test(dateStr));
```

## 正则提取

```javascript
// 1. 提取工资
var str = "张三：1000，李四：5000，王五：8000。";
var array = str.match(/\d+/g);
console.log(array);

// 2. 提取email地址
var str = "123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...";
var array = str.match(/\w+@\w+\.\w+(\.\w+)?/g);
console.log(array);

// 3. 分组提取  
// 3. 提取日期中的年部分  2015-5-10
var dateStr = '2016-1-5';
// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取
var reg = /(\d{4})-\d{1,2}-\d{1,2}/;
if (reg.test(dateStr)) {
  console.log(RegExp.$1);
}

// 4. 提取邮件中的每一部分
var reg = /(\w+)@(\w+)\.(\w+)(\.\w+)?/;
var str = "123123@xx.com";
if (reg.test(str)) {
  console.log(RegExp.$1);
  console.log(RegExp.$2);
  console.log(RegExp.$3);
}
```

## 正则替换

```javascript
// 1. 替换所有空白
var str = "   123AD  asadf   asadfasf  adf ";
str = str.replace(/\s/g,"xx");
console.log(str);

// 2. 替换所有,|，
var str = "abc,efg,123，abc,123，a";
str = str.replace(/,|，/g, ".");
console.log(str);
```

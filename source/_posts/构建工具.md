---
slug: 项目构建
title: 项目构建
description: 项目构建的一系列工具
keywords: webpack,git,npm,规范
category: 项目构建
tags: [webpack,git,npm,规范]
author: liming
date: 25-September-2020
sticky: 3
swiper_index: 3
swiper_desc: 项目构建的一系列工具！
cover: https://i0.hippopx.com/photos/457/88/1021/microphone-boy-studio-screaming-preview.jpg
---

# 网站搭建

## nginx

https://juejin.cn/post/6887135998099062792

https://blog.csdn.net/Charissa2017/article/details/105886521

Nginx是一款轻量级的Web服务器，具有内存占用少，启动极快，高并发能力强的优势，采用事件驱动的异步非阻塞处理方式框架，IO性能好，时常用于服务端的反向代理和负载均衡。 

### 正向代理与反向代理

正向代理是什么东东？反向代理又是啥？
 ***「「正向代理」」***
 **「「举个栗子」」** 因为防火墙的原因， 直接访问谷歌是无法访问的， 这时可以借助梯子，即vpn，那么这个vpn(代理)就是代替客户端去访问服务器，然后将数据返回给客户端。服务器并不知道目标客户端，只是与vpn建立联系。
 ***「「反向代理」」***
 **「「举个栗子」」** 你（客户端）去租房时，真正的房东（服务器）将房租给二手房东（代理服务器），而你通过二手房东租到的房子，也就是你与二手房东建立联系， 租到房子，并非真正的房东。
 一句话： **正向代理 “代理”客户端， 反向代理“代理”服务器**

### nginx文件

#### 配置文件

 `ps aux|grep nginx` 查看 配置文件conf目录 

 nginx配置文件的基本结构 

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de06e2d89ea345dcac78a3da6d509ebc~tplv-k3u1fbpfcp-watermark.awebp)

```
「「main」」:nginx的全局配置，对全局生效。
「「events」」:配置影响nginx服务器或与用户的网络连接。
「「http」」：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。
「「server」」：配置虚拟主机的相关参数，一个http中可以有多个server。
「「location」」：配置请求的路由，以及各种页面的处理情况。
「「upstream」」：配置后端服务器具体地址，负载均衡配置不可或缺的部分。
```

#####  server 

```bash
server {
  listen 80;
  server_name  localhost;
  root   html;
  index  index.html index.htm;
}
include /etc/nginx/conf.d/*.conf;
##引入/etc/nginx/conf.d中的server配置
## /etc/nginx/conf.d/index.conf
server {
  #端口号
  listen 80;
  #域名或者ip
  #server_name 121.40.61.99;
  server_name tomorrowlm.xyz;
  #文件的路径
  root /root/www;
  #配置默认访问的页面
  index index.html;
  #配置多个项目
  #location注意要和项目中配置的base一样
  location /vue-demo {
 	try_files $uri $uri/ /vue-demo/index.html;
  }
  location /react-demo {
  	try_files $uri $uri/ /react-demo/index.html;
  }

# location / {
#   #当输入错误路径时，跳转到index.html页面
#   try_files $uri $uri/ =404 /index.html;
#  }
}
```



```bash
#点击刷新后，页面就会显示（404）,使用try_files（进行内部重定向）
try_files $uri $uri/ /react-demo/index.html;
#$uri  请求文件的路径
#$uri/ 请求目录的路径

try_files是nginx中http_core核心模块所带的指令，主要是能替代一些rewrite的指令，提高解析效率。
当用户请求 http://localhost/example 时，这里的 $uri 就是 /example。 
try_files 会到硬盘里尝试找这个文件。如果存在名为 /$root/example（其中 $root 是项目代码安装目录）的文件，就直接把这个文件的内容发送给用户。 
显然，目录中没有叫 example 的文件。然后就看 $uri/，增加了一个 /，也就是看有没有名为 /$root/example/ 的目录。 
```



```bash
#配置代理
server {
  listen 80;
  server_name name1;
  root /root/www;
  #配置默认访问的页面
  index index.html;
  autoindex on;
  #实现公用80端口 部署多个网站
  location / {
    proxy_pass http://localhost:4300;
  }
}
server {
  listen 4300;
  server_name localhost;
  root /root/www;
  autoindex on;
  location /vue-demo {
    try_files $uri $uri/ /index.html;
  }
}
server {
  listen 80;
  server_name name2;
  root /root/www;
  #配置默认访问的页面
  index index.html;
  autoindex on;
  #实现公用80端口 部署多个网站
  location / {
    proxy_pass http://localhost:4400;
  }
}
server {
  listen 4400;
  server_name localhost;
  root /root/www;
  autoindex on;
  location /vue-demo {
    try_files $uri $uri/ /index.html;
  }
}
```

nginx默认监听的就是80端口， 也可以监听其他端口号

server_name就是你服务器的名称，可以精准匹配，也可以使用通配符或正则匹配，没有顺序，一般是先到先得。

root 你项目文件存放路径， 一般是放在html下面，也可放在其他地方， 如/var/local/marking-h5,n那么就改为 `root /var/local/marking-h5`（build打包后的dist文件在服务器上的路径）

index 你的项目入口， 通常是index.html.

#### 其他文件

```bash
/run 		nginx.pid
/etc/nginx 	nginx配置
/root 		页面
/var/log/nginx/access.log 	报错信息
```

### nginx命令

```bash
nginx 							#打开 nginx
nginx -t   				        #测试配置文件是否有语法错误
nginx -s reopen					#重启Nginx
nginx -s reload					#重新加载Nginx配置文件，然后以优雅的方式重启Nginx
nginx -s stop  					#强制停止Nginx服务
nginx -s quit  					#停止Nginx服务（即处理完所有请求后再停止服务）
systemctl start nginx			#开启防火墙
service nginx start				#启动nginx
nginx [-?hvVtq] [-s signal] [-c filename] [-p prefix] [-g directives]

-?,-h           : 打开帮助信息
-v              : 显示版本信息并退出
-V              : 显示版本和配置选项信息，然后退出
-t              : 检测配置文件是否有语法错误，然后退出
-q              : 在检测配置文件期间屏蔽非错误信息
-s signal       : 给一个 nginx 主进程发送信号：stop（强制停止）, quit（优雅退出）, reopen（重启）, reload（重新加载配置文件）
-p prefix       : 设置前缀路径（默认是：/usr/share/nginx/）
-c filename     : 设置配置文件（默认是：/etc/nginx/nginx.conf）
-g directives   : 设置配置文件外的全局指令
```

tip:

- nginx: [error] open() "/run/nginx.pid" failed (2: No such file or directory)

  ```
  nginx -c /etc/nginx/nginx.conf
  ```

## PM2

PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。

```
pm2 start ./bin/www --watch --name my-api
```

```
用法
$ npm install pm2 -g     # 命令行安装 pm2 
$ pm2 start app.js --name my-api # 命名进程
$ pm2 list               # 显示所有进程状态
$ pm2 monit              # 监视所有进程
$ pm2 logs               #  显示所有进程日志
$ pm2 stop all           # 停止所有进程
$ pm2 restart all        # 重启所有进程
$ pm2 reload all         # 0秒停机重载进程 (用于 NETWORKED 进程)
$ pm2 stop 0             # 停止指定的进程
$ pm2 restart 0          # 重启指定的进程
$ pm2 startup            # 产生 init 脚本 保持进程活着
$ pm2 web                # 运行健壮的 computer API endpoint (http://localhost:9615)
$ pm2 delete 0           # 杀死指定的进程
$ pm2 delete all         # 杀死全部进程
```

## express

https://help.aliyun.com/document_detail/50775.html

https://www.jianshu.com/p/175558881f19

# **前端⼯程化**

## JS模块规范

### CommonJS

是一种为JS的表现指定的规范，它希望js可以运行在任何地方，更多的说的是服务端模块规范，Node.js采用了这个规范。

核心思想：
允许模块通过 `require` 方法来同步加载所要依赖的其他模块，然后通过 `exports` 或 `module.exports` 来导出需要暴露的接口。

**优点：**服务器端模块重用，NPM中模块包多，有将近20万个。

**缺点：**加载模块是**同步**的，只有加载完成后才能执行后面的操作，也就是当要用到该模块了，现加载现用，不仅加载速度慢，而且还会导致性能、可用性、调试和跨域访问等问题。Node.js主要用于服务器编程，加载的模块文件一般都存在本地硬盘，加载起来比较快，不用考虑异步加载的方式，因此,CommonJS规范比较适用。然而，这并不适合在浏览器环境，同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。

**实现**：

- 服务器端的 [Node.js](http://www.nodejs.org/)
- [Browserify](http://browserify.org/)，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大
- [modules-webmake](https://github.com/medikoo/modules-webmake)，类似Browserify，还不如 Browserify 灵活
- [wreq](https://github.com/substack/wreq)，Browserify 的前身

### **AMD**

鉴于浏览器的特殊情况，又出现了一个规范，这个规范呢可以实现异步加载依赖模块，并且会提前加载那就是AMD规范。

**其核心接口是**：define(id, 『dependencies』, factory) ，它要在声明模块的时候指定所有的依赖 dependencies ，并且还要当做形参传到factory 中，对于依赖的模块**提前执行**，**依赖前置**。

```js
define("module", ["dep1", "dep2"], function(d1, d2) {
  return someExportedValue;
});
require(["module", "../file"], function(module, file) { /* ... */ });
```

**优点：**在浏览器环境中异步加载模块；并行加载多个模块；

**缺点：**开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现；

### **CMD**

Common Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。

```text
define(function(require, exports, module) {
  var $ = require('jquery');
  var Spinning = require('./spinning');
  exports.doSomething = ...
  module.exports = ...
})
```

**优点：依赖就近，延迟执行**（对于依赖的模块延迟执行，即只在需要用到某个模块的时候再require） 可以很容易在 Node.js 中运行；
**缺点：**依赖 SPM 打包，模块的加载逻辑偏重；
**实现：Sea.js** ；coolie

### **ES6**

ECMAScript6 标准增加了 JavaScript 语言层面的模块体系定义。[ES6 模块](http://es6.ruanyifeng.com/#docs/module)的设计思想，是尽量的静态化，使得**编译**时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。**但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require**。

```js
import "jquery";
export function doStuff() {}
module "localModule" {}
```

优点：

- 容易进行静态分析
- 面向未来的 ECMAScript 标准

缺点：

- 原生浏览器端还没有实现该标准
- 全新的命令字，新版的 Node.js才支持

### 模块包的导入导出

https://mp.weixin.qq.com/s/1wUU-i3W4RlR2hf86lZqEA

#### CommonJS

#### ES6 Module

##### 导出

在ES6 Module 中，导出用到了关键字 `export` ，导出的方式也大致分为两种，分别是**命名导出** 、**默认导出**

**第一种：** 命名导出

```js
// B.js
/*--------  单个变量或函数导出  ----------*/
export function show() { console.log('show方法被调用') }

export let count = 3

/*--------  批量导出  ----------*/
function show() { console.log('show方法被调用') }

let count = 3

export {show, count}
```

上述代码分了两种情况，且这两种写法是等价的

第一种是单个的变量或函数导出，只需要直接在开头使用 `export` 关键字即可；

第二种情况是批量地把多个变量或函数导出，只需要把它们储存到一个对象中即可

**第二种：** 默认导出

```
// B.js
function show() { console.log('show方法被调用') }

// 命名导出变量count
export let count = 3

// 默认导出函数show
export default show
```

默认导出是在 `export` 关键词后面再跟上一个 `default` 表示导出的该变量或函数是匿名的

> **注意：** 一个模块只能默认导出一次，否则就会报错，具体原因会在后面讲解

##### 导入

ES6 Module 的导入用到的关键字是 `import` ，具体代码如下

```js
// A.js
import {show, count} from './B.js'

show()   // show方法被调用

console.log(count)  // 3
```

ES6 Module的导入需要用一对 `{}` 大括号来接收我们需要导入的方法或函数

> **注意：** 大括号中的变量或函数名必须与导出时的名称一模一样

那么如果我们想修改导入的变量或函数的名称，可以通过 `as` 关键词来命名，代码如下

```js
// A.js
import {show as print, count as number} from './B.js'

print()   // show方法被调用

console.log(number)  // 3
```

如果我们要想将所有的变量或函数都导入，可以通过 `*` 来整体导入，代码如下

```js
import * as bModule from './B.js'

bModule.show()  // show方法被调用

console.log(bModule.count)  // 3
```

`*` 表示全部的意思，我们将其全部导入，并赋值给 `bModule`，这样我们就可以通过 `bModule` 获取想要的变量或对象了

以上所说的都是针对命名导出的变量或函数，那么如何导入一个默认导出的变量或函数呢？

```js
// 将通过 export default 导出的变量导入
import print from './B.js'

print()  // show方法被调用
```

命名导出的变量都是通过 `{}` 来接收的，那么去掉 `{}` ，接收的就是默认导出的变量了，因为导出的变量是匿名的，因此我们可以随意地起个变量名用于接收

**补充：** 这里特别提一下，与CommonJS不同，ES6 Module 的导入文件路径是不支持表达式的.

#### CommonJS 与ES6的区别

这两者的主要区别主要有以下两点：

1. 对于模块的依赖，CommonJS是**动态的**，ES6 Module 是**静态的**
2. CommonJS导入的是值的**拷贝**，ES6 Module导入的是值的**引用**

##### 区别一

对于模块的依赖，何为**动态**？何为**静态**？

动态是指对于模块的依赖关系建立在代码执行阶段；静态是指对于模块的依赖关系建立在代码编译阶段；

上文提到，CommonJS导入时，`require` 的路径参数是支持表达式的，例如

```
// A.js
let fileName = 'example.js'
const bModule = require('./' + fileName)
```

因为该路径在代码执行时是可以动态改变的，所以如果在代码编译阶段就建立各个模块的依赖关系，那么一定是不准确的，只有在代码运行了以后，才可以真正确认模块的依赖关系，因此说CommonJS是动态的。

那么现在你也应该也知道为什么 ES6 Module 是静态的了吧

##### 区别二

为了验证这一点，我准备用实例来演示一下

首先来验证CommonJS，代码如下

```
// B.js
let count = 3

function change() {
    count ++    // 变量count + 1
    console.log('原count值为：', count);  // 打印B.js模块中count的值
}

module.exports = {
    count,
    change
}

// A.js
let count = require('./B.js').count 
let change = require('./B.js').change

console.log('改变前：', count);   
change()     // 调用模块B.js中的change方法，将原来的count + 1
console.log('改变后：', count); 

// 运行A.js文件的结果
改变前：3
原count值为：4
改变后：3
```

在上述代码中我们可以看到，在 `A.js` 文件中导入了 `B.js` 文件中的变量 `count` 和 函数 `change`，因为导入的 `count` 只是对原有值的一个拷贝，因此尽管我们调用了函数 `change` 改变了 `B.js` 文件中变量 `count` 的值，也不会影响到 `A.js` 文件中的变量 `count`

根据这个结果得出结论：CommonJS导入的变量是对原值的拷贝

## 构建工具

### 构建历史

![构建历史](img/构建工具/构建历史.webp)

前端模块化/构建工具从最开始的基于浏览器**运行时**加载的 `RequireJs/Sea.js` 到将所有资源组装依赖打包 `webpack`/`rollup`/`parcel`的`bundle`类模块化构建工具，再到现在的`bundleless`基于浏览器原生 ES 模块的 `snowpack`/`vite`，前端的模块化/构建工具发展到现在已经快 10 年了。

-  Grunt

- browserify

  `browserify`致力于在浏览器端使用`CommonJs`，他使用跟 `NodeJs` 一样的模块化语法，然后将所有依赖文件编译到一个`bundle`文件，在浏览器通过`<script>`标签使用的，并且支持 npm 库。

- Gulp

- webpack

  `webpack1`支持`CommonJs`和`AMD`模块化系统，优化依赖关系，支持分包，支持多种类型 script、image、file、css/less/sass/stylus、mocha/eslint/jshint 的打包，丰富的插件体系。`webpack`的概念更偏向于工程化

  以上的 3 个库 `Grunt/Gulp/browserify` 都是偏向于工具，而 `webpack`将以上功能都集成到一起，相比于工具它的功能大而全。

- rollup

  `rollup`编译`ES6`模块，提出了`Tree-shaking`，根据`ES module`静态语法特性，删除未被实际使用的代码，支持导出多种规范语法，并且导出的代码非常简洁，如果看过 `vue` 的`dist` 目录代码就知道导出的 `vue` 代码完全不影响阅读。

  `rollup`的插件系统支持：`babel`、`CommonJs`、`terser`、`typescript`等功能。

  相比于`browserify`的`CommonJs`，`rollup`专注于`ES module`。
  相比于`webpack`大而全的前端工程化，`rollup`专注于纯`javascript`，大多被用作打包`tool`工具或`library`库。

  react、vue 等库都使用`rollup`打包项目，并且下面说到的`vite`也依赖`rollup`用作生产环境打包 js。

- snowpack 和 vite

  因为 `snowpack` 和 `vite` 比较类似，都是`bundleless`所以一起拿来说。`bundleless`类运行时打包工具的启动速度是毫秒级的，因为不需要打包任何内容，只需要起两个`server`，一个用于页面加载，另一个用于`HMR`的`WebSocket`，当浏览器发出原生的`ES module`请求，`server`收到请求只需编译当前文件后返回给浏览器不需要管依赖。`bundleless`工具在**生产环境**打包的时候依然`bundle`构建所以依赖视图的方式，vite 是利用 `rollup` 打包生产环境的 js 的。

### webpack和gulp的区别

#### webpack打包工具定义

webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。

**网页中常见的静态资源**

**js**--js，jax，coffee，ts(TypeScript,需要编译为js)

**css**-- css,less,sass

**image**--jpg,png,gif,bmp,svg

**字体文件(Fonts)**--svg,ttf,eot,woff,woff2

**模板文件**--ejs,jade,vue(这是在webpack中定义的组件的方式)

![什么是webpack](https://zhaoda.net/webpack-handbook/images/what-is-webpack.png)

#### gulp构建工具定义

gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。

#### 相同功能

| 功能                  | gulp                                                         | webpack                                                      |
| --------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 文件合并与压缩（css） | 使用gulp-minify-css模块 gulp.task('sass',function(){    gulp.src(cssFiles)    .pipe(sass().on('error',sass.logError))    .pipe(require('gulp-minify-css')())    .pipe(gulp.dest(distFolder)); }); | 样式合并一般用到extract-text-webpack-plugin插件， 压缩则使用webpack.optimize.UglifyJsPlugin。 |
| 文件合并与压缩（js）  | 使用gulp-uglify和gulp-concat两个模块                         | js合并在模块化开始就已经做， 压缩则使用webpack.optimize.UglifyJsPlugin |
| sass/less预编译       | 使用gulp-sass/gulp-less 模块                                 | sass-loader/less-loader 进行预处理                           |
| 启动server            | 使用gulp-webserver模块 var webserver =require('gulp-webserver'); gulp.task('webserver',function(){    gulp.src('./')    .pipe(webserver({      host:'localhost',      port:8080,      livereload:true, //自动刷新      directoryListing:{         enable: true,         path:'./'      },    })); }); | 使用webpack-dev-server模块 module.exports = {    ......    devServer: {      contentBase: "build/",      port:8080,      inline: true //实时刷新    } } |
| 版本控制              | 使用gulp-rev和gulp-rev-collector两个模块                     | 将生成文件加上hash值 module.exports = {    ......   output: {     ......     filename: "[name].[hash:8].js"   },    plugins:[      ......      new ExtractTextPlugin(style.[hash].css")    ] } |

#### 区别

- gulp严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。

- webpack更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。

- Webpack 可以做到按需加载。像 Grunt、Gulp 这类构建工具，打包的思路是：遍历源文件→匹配规则→打包，这个过程中做不到按需加载，即对于打包起来的资源，到底页面用不用，打包过程中是不关心的。Webpack 跟其他构建工具本质上不同之处在于：Webpack 是从入口文件开始，经过模块依赖加载、分析和打包三个流程完成项目的构建。在加载、分析和打包的三个过程中，可以针对性的做一些解决方案，达到按需加载的目的，比如code split（拆分公共代码等）。

### webpack

#### 原理

⾸先我们通过⼀个制作⼀个打包⽂件的原型。

假设有两个js模块，这⾥我们先假设这两个模块是复合commomjs标准的es5模块。

我们的⽬的是将这两个模块打包为⼀个能在浏览器端运⾏的⽂件，这个⽂件其实叫bundle.js。

```js
// index.js
var add = require('add.js').default
console.log(add(1 , 2))
// add.js
exports.default = function(a,b) {return a + b}
```

浏览器中直接执⾏这个程序肯定会有问题 最主要的问题是**浏览器中没有exports对象与require⽅法**所以⼀定

会报错。我们需要通过**模拟**exports对象和require⽅法

**模拟exports对象**

```js
exports = {}
eval('exports.default = function(a,b) {return a + b}') // node⽂件读取后的代码字符串
console.log(exports.default(1,3))
```

 由于⼦模块中会声明变量，为了不污染全局我们使⽤⼀个⾃运⾏函数来封装⼀下。

```js
var exports = {}
(function (exports, code) {
 eval(code)
})(exports, 'exports.default = function(a,b){return a + b}')
```

**模拟require函数,返回export对象**

```js
function require(file) {
 var exports = {};
 (function (exports, code) {
 eval(code)
 })(exports, 'exports.default = function(a,b){return a + b}')
 return exports
}
var add = require('add.js').default
console.log(add(1 , 2))
```

将所有模块的⽂件名和代码字符串整理为⼀张key-value表就可以根据传⼊的⽂件名加载不同的模块了

```js
(function (list) {
  function require(file) {
    var exports = {};
    (function (exports, code) {
      eval(code);
    })(exports, list[file]);
    return exports;
  }
  require("index.js");
})({
  "index.js": `
    var add = require('add.js').default
    console.log(add(1 , 2))
    `,
  "add.js": `exports.default = function(a,b){return a + b}`,
});

```

#### 插件

##### 基础

###### **webpack**

一个模块打包器，根据entry指示webpack应该使用哪个模块，来**作为构建其内部依赖图的开始**。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。
每个依赖项随即被处理，最后输出到output字段指定的文件中

###### **webpack-dev-server**

webpack-dev-server：一个服务器插件，相当于webpack+apache，启动一个web服务并实时更新修改
**启动webpack-dev-server后，在目标文件夹中是看不到编译后的文件的，实时编译后的文件都保存到了内存当中。**

**区别**

- webpack不会实时更新修改，就只是一个打包工具，webpack-dev-server会实时自动更新修改
- webpack打包输出路径，output字段为path，webpack-dev-server打包输出路径，output字段为publicPath(此值为空时默认是项目根目录，  contentBase:'src',//指定托管的根目录)
- webpack打包输出的文件，是真的存在于物理地址path中，而webpack-dev-server打包输出的文件，是保存在内存中的，在项目目录中是找不到的。

模块热更新(Hot Module Replacement)是指在浏览器运行过程中，替换、添加或删除模块，而无需重新加载整个页面。

###### html-webpack-plugin

webpack-dev-server实现了自动编译刷新浏览器，让编译出来的bundle.js托关于服务器根路径（电脑内存）中去。

html-webpack-plugin会创建一个在内存中生成一个html的插件，帮我们自动引入在内存中打包好的bundle.js文件

##### loader

**webpack默认只能打包处理 JS类型的文件，无法处理其他的非JS类型的文件**

```js
  //loader加载器模块配置
  module: {
    rules: [
      {
        test: /\.less$/,//使用正则匹配
        use: ["style-loader", "css-loader", "less-loader"],//从后往前调用的
      }, //如果想要启用 CSS 模块化，可以为 css-loader 添加 modules 参数即可
      {
        test: /(\.jsx|\.js)$/,
        use: ["babel-loader?cacheDirectory"],
        include: path.resolve(__dirname, "./src"),
        exclude: /node_modules/,
      },
    ],
  },
```

- babel-loader: 负责 es6 语法转化
- babel-preset-env: 包含 es6、7 等版本的语法转化规则

##### 编译优化

https://jelly.jd.com/article/61179aa26bea510187770aa3

###### 编译进度和依赖包大小

`webpack-bundle-analyzer`可以帮助我们分析打包后的依赖包大小，`webpackbar`提供了友好的编译进度提示

```
npm i -D webpackbar webpack-bundle-analyzer
```

加入配置文件：

```javascript
// webpack.prod.js
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
  // ...
  plugins: [
    new BundleAnalyzerPlugin(),
  ]
}
```

```
// webpack.base.js
const WebpackBar = require('webpackbar');

module.exports = {
  // ...
  plugins: [
    new WebpackBar(),
  ]
}

```

###### 编译速度分析

优化 webpack 构建速度，首先需要知道是哪些插件、哪些 loader 耗时长，方便我们针对性的优化。通过 [speed-measure-webpack-plugin ](https://www.npmjs.com/package/speed-measure-webpack-plugin)插件进行构建速度分析，可以看到各个 loader、plugin 的构建时长，后续可针对耗时 loader、plugin 进行优化。

```
npm i -D speed-measure-webpack-plugin
```

```
//webpack.base.js
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");
const smp = new SpeedMeasurePlugin();
module.exports = smp.wrap({
  // ...webpack config...
})
```

###### 缓存

通过配置 [webpack 持久化缓存 ](https://webpack.docschina.org/configuration/cache/#root)`cache: filesystem`，来缓存生成的 webpack 模块和 chunk，改善构建速度。

简单来说，通过 `cache: filesystem` 可以将构建过程的 webpack 模板进行缓存，大幅提升二次构建速度、打包速度，当构建突然中断，二次进行构建时，可以直接从缓存中拉取，可提速 **90%** 左右。

`webpack.common.js` 配置方式如下：

```
module.exports = {
    cache: {
      type: 'filesystem', // 使用文件缓存
    },
}
```

##### 压缩

```js
//css压缩
const OptimizeCss = require("optimize-css-assets-webpack-plugin");
//压缩js文件
const UglifyJsPlugin = require("uglifyjs-webpack-plugin");
```

##### PWA

https://www.jianshu.com/p/7845a13a67d7

https://carljin.com/how-to-add-pwa-on-existed-project

PWA化主要解决了两大问题： 1）使web app有沉浸式体验，也就是更靠近原生体验。如：去掉浏览器的地址栏和底部工具栏；在桌面上生成图标，方便再次进入。 2）提供独立于浏览器的缓存，并且可以接收服务器的推送。如：在没有网络，或者网络状态较差的时候，仍可访问缓存在本地的数据.

#### 项目构建

https://juejin.cn/post/6844903968405979144

```
npm init
npm install webpack
```

##### 文件

webpack.base.conf.js  ==> webpack基本配置；

webpack.dev.conf.js  ==> webpack开发环境配置；

webpack.prod.conf.js  ==> webpack生产环境配置；

##### 配置

###### 入口文件entry

```
entry: path.resolve(__dirname, "./src/main.js"),
```

###### output

```
output: {
    //指定打包好的文件，输出到哪个目录中去
    path: path.resolve(__dirname, "./dist"),
    //输出文件名
    filename: "js/bundle.[hash].js",
    publicPath: '',//静态文件打包存放的目录.静态文件是指 img 的src ,link ，				script 标签等所指向的文件。静态资源最终访问路径 = output.publicPath + 资源loader或插	件等配置路径
},
```



- Sourcemap

  **`Sourcemap` 本质上是一个信息文件**，里面储存着代码转换前后的对应位置信息。它记录了转换压缩后的代码所对应的转换前的源代码位置，是源代码和生产代码的映射。简单说 `Sourcemap` 构建了处理前以及处理后的代码之间的一座桥梁，方便定位生产环境中出现 `bug` 的位置。
  
- externals

  **防止**将某些 `import` 的包(package)**打包**到 bundle 中，而是在运行时(runtime)再去从外部获取这些*扩展依赖(external dependencies)*。

  例如，从 CDN 引入 [jQuery](https://jquery.com/)，而不是把它打包

# 编码规范

## 组件化

## ⾃动化

调试

编译

部署

测试

⽂档化

## 规范性

项⽬⽬录结构

语法提示

编码⻛格规范 

### lint

#### Lint 的含义

https://www.jianshu.com/p/ad1e46faaea2 

https://blog.csdn.net/userkang/article/details/84305689

每个程序员都有自己的编码习惯，最常见的莫过于：

- 有的人写代码一行代码结尾必须加分号 `;`，有的人觉得不加分号 `;` 更好看；
- 有的人写代码一行代码不会超过 80 个字符，认为这样看起来简洁明了，有的人喜欢把所有逻辑都写在一行代码上，觉得别人看不懂的代码很牛逼；
- 有的人使用变量必然会先定义 `var a = 10;`，而粗心的人写变量可能没有定义过就直接使用 `b = 10;`；

如果你写自己的项目怎么折腾都没关系，但是在公司中老板希望每个人写出的代码都要符合一个统一的规则，这样别人看源码就能够看得懂，因为源码是符合统一的编码规范制定的。

那么问题来了，总不能每个人写的代码老板都要一行行代码去检查吧，这是一件很蠢的事情。凡是重复性的工作，都应该被制作成工具来节约成本。这个工具应该做两件事情：

- 提供编码规范；
- 提供自动检验代码的程序，并打印检验结果：告诉你哪一个文件哪一行代码不符合哪一条编码规范，方便你去修改代码。

Lint 因此而诞生。

Lint 是检验代码格式工具的一个统称，具体的工具有 `Jslint` 、 `Eslint` 等等

#### Eslint 

##### 含义

> ESLint 是什么呢？
> 是一个开源的 JavaScript 的 linting 工具，使用 [espree](https://link.zhihu.com/?target=https%3A//github.com/eslint/espree) 将 JavaScript 代码解析成抽象语法树 (AST)，然后通过AST 来分析我们代码，从而给予我们两种提示：

1. **代码质量问题：使用方式有可能有问题(problematic patterns)**
2. **代码风格问题：风格不符合一定规则 (doesn’t adhere to certain style guidelines)**

ESLint 可以让程序员在编码的过程中发现问题而不是在执行的过程中。

ESLint 的初衷是为了让程序员可以创建自己的检测规则。ESLint 的所有规则都被设计成可插拔的。为了便于人们使用，ESLint 内置了一些规则，当然，你可以在使用过程中自定义规则。所有的规则默认都是禁用的。

ESLint 使用 **Node.js** 编写，这样既可以有一个快速的运行环境的同时也便于安装。 (重点，**使用eslint必须有package.json文件**)

##### 安装

生成流程：https://blog.csdn.net/shenxianhui1995/article/details/103035013

- 全局安装： `npm install -g eslint`
  
  - `eslint --init`
  
- 项目安装： `npm install eslint --save-dev`

  - `./node_modules/.bin/eslint --init `

  如果你想你所有项目都使用eslint，请全局安装；如果你想当前项目使用，请局部安装。

```
? How would you like to use ESLint? (Use arrow keys) // 你想怎样使用eslint
  To check syntax only //只检查语法
> To check syntax and find problems//检查语法、发现问题
  To check syntax, find problems, and enforce code style//检查语法、发现问题并执行代码样式
```

##### eslint配置

https://www.cnblogs.com/jiaoshou/p/11218526.html

1. 一般都采用.eslintrc.*的配置文件进行配置, 如果放在项目的根目录中，则会作用于整个项目。如果在项目的子目录中也包含着.eslintrc文件，则对于子目录中文件的检查会忽略掉根目录中的配置，而直接采用子目录中的配置，这就能够在不同的目录范围内应用不同的检查规则，显得比较灵活。ESLint采用逐级向上查找的方式查找.eslintrc.*文件，当找到带有"root": true配置项的.eslintrc.*文件时，将会停止向上查找。
2. 在 package.json文件里的 eslintConfig 字段进行配置。

```js
module.exports = {
    "globals": {},
    "env": {
        "browser": true,
        "es2021": true
    },
    "extends": "eslint:recommended",
    "parse": "babel-eslint",
    "parserOptions": {
        "ecmaVersion": 12,
        "sourceType": "module"
    },
    "rules": {}
};
```

#### globals

ESLint会检测未声明的额外的全局变量，并发出报错，比如node环境中的process，浏览器环境下的全局变量console，以及我们通过cdn引入的jQuery定义的$等；我们可以在`globals`中进行变量声明：

```json
{
    "globals": {
        // true表示该变量可读写，false表示变量是只读
        "$": true,
        "console": false
    }
}
```

但是node或者浏览器中的全局变量很多，如果我们一个个进行声明显得繁琐，因此就需要用到我们的`env`，这是对环境定义的一组全局变量的预设。

#### env

使用 `env` 属性来指定要启用的环境，将其设置为 `true`，以保证在进行代码检测时不会把[这些环境](http://eslint.cn/docs/user-guide/configuring#specifying-environments)预定义的全局变量识别成未定义的变量而报错

```
"env": {
    "browser": true,
    "commonjs": true,
    "es6": true,
    "jquery": true
}
```

#### 插件plugins

##### eslint-plugin-html

```
npm install --save-dev eslint-plugin-html
```

```js
{
    "plugins": [
        "html"
    ]
}
```

#### 解析器

##### parser

[Babel-ESLint](https://www.npmjs.com/package/babel-eslint) - 一个对[Babel](https://babeljs.io/)解析器的包装，使其能够与 ESLint 兼容

##### parserOptions

默认情况下，ESLint 支持 ECMAScript 5 语法，如果你想启用对 ECMAScript 其它版本和 JSX 等的支持，ESLint 允许你使用 `parserOptions` 属性进行指定想要支持的 JavaScript [语言选项](http://eslint.cn/docs/user-guide/configuring#specifying-parser-options)

```json
{
  "parser": "babel-eslint",
  "parserOptions": {
    // 代码模块类型，可选script(默认)，module
    "sourceType": "module",
    // es版本号，默认为5，可以使用年份2015（同6）
    "ecamVersion": 6,
    // es 特性配置
    "ecmaFeatures": {
        "globalReturn": true, // 允许在全局作用域下使用 return 语句
        "impliedStrict": true, // 启用全局 strict mode 
        "jsx": true // 启用 JSX
    }
  },
}
```

#### 配置规则

**启用的规则及其各自的错误级别**

在上文的配置文件中， `"extends": "eslint:recommended"` 选项表示启用推荐规则，在推荐规则的基础上我们还可以根据需要使用 `rules` 新增自定义规则，每个规则的第一个值都是代表该规则检测后显示的错误级别：

- `"off"` 或 `0` - 关闭规则
- `"warn"` 或 `1` - 将规则视为一个警告
- `"error"` 或 `2` - 将规则视为一个错误

```json
"no-alert": 0,//禁止使用alert confirm prompt
"no-array-constructor": 2,//禁止使用数组构造器
"no-bitwise": 0,//禁止使用按位运算符
"no-caller": 1,//禁止使用arguments.caller或arguments.callee
"no-catch-shadow": 2,//禁止catch子句参数与外部作用域变量同名
"no-class-assign": 2,//禁止给类赋值
"no-cond-assign": 2,//禁止在条件表达式中使用赋值语句
"no-console": 2,//禁止使用console
"no-const-assign": 2,//禁止修改const声明的变量
"no-constant-condition": 2,//禁止在条件中使用常量表达式 if(true) if(1)
"no-continue": 0,//禁止使用continue
"no-control-regex": 2,//禁止在正则表达式中使用控制字符
"no-debugger": 2,//禁止使用debugger
"no-delete-var": 2,//不能对var声明的变量使用delete操作符
"no-div-regex": 1,//不能使用看起来像除法的正则表达式/=foo/
"no-dupe-keys": 2,//在创建对象字面量时不允许键重复 {a:1,a:1}
"no-dupe-args": 2,//函数参数不能重复
"no-duplicate-case": 2,//switch中的case标签不能重复
"no-else-return": 2,//如果if语句里面有return,后面不能跟else语句
"no-empty": 2,//块语句中的内容不能为空
"no-empty-character-class": 2,//正则表达式中的[]内容不能为空
"no-empty-label": 2,//禁止使用空label
"no-eq-null": 2,//禁止对null使用==或!=运算符
"no-eval": 1,//禁止使用eval
"no-ex-assign": 2,//禁止给catch语句中的异常参数赋值
"no-extend-native": 2,//禁止扩展native对象
"no-extra-bind": 2,//禁止不必要的函数绑定
"no-extra-boolean-cast": 2,//禁止不必要的bool转换
"no-extra-parens": 2,//禁止非必要的括号
"no-extra-semi": 2,//禁止多余的冒号
"no-fallthrough": 1,//禁止switch穿透
"no-floating-decimal": 2,//禁止省略浮点数中的0 .5 3.
"no-func-assign": 2,//禁止重复的函数声明
"no-implicit-coercion": 1,//禁止隐式转换
"no-implied-eval": 2,//禁止使用隐式eval
"no-inline-comments": 0,//禁止行内备注
"no-inner-declarations": [2, "functions"],//禁止在块语句中使用声明（变量或函数）
"no-invalid-regexp": 2,//禁止无效的正则表达式
"no-invalid-this": 2,//禁止无效的this，只能用在构造器，类，对象字面量
"no-irregular-whitespace": 2,//不能有不规则的空格
"no-iterator": 2,//禁止使用__iterator__ 属性
"no-label-var": 2,//label名不能与var声明的变量名相同
"no-labels": 2,//禁止标签声明
"no-lone-blocks": 2,//禁止不必要的嵌套块
"no-lonely-if": 2,//禁止else语句内只有if语句
"no-loop-func": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）
"no-mixed-requires": [0, false],//声明时不能混用声明类型
"no-mixed-spaces-and-tabs": [2, false],//禁止混用tab和空格
"linebreak-style": [0, "windows"],//换行风格
"no-multi-spaces": 1,//不能用多余的空格
"no-multi-str": 2,//字符串不能用\换行
"no-multiple-empty-lines": [1, {"max": 2}],//空行最多不能超过2行
"no-native-reassign": 2,//不能重写native对象
"no-negated-in-lhs": 2,//in 操作符的左边不能有!
"no-nested-ternary": 0,//禁止使用嵌套的三目运算
"no-new": 1,//禁止在使用new构造一个实例后不赋值
"no-new-func": 1,//禁止使用new Function
"no-new-object": 2,//禁止使用new Object()
"no-new-require": 2,//禁止使用new require
"no-new-wrappers": 2,//禁止使用new创建包装实例，new String new Boolean new Number
"no-obj-calls": 2,//不能调用内置的全局对象，比如Math() JSON()
"no-octal": 2,//禁止使用八进制数字
"no-octal-escape": 2,//禁止使用八进制转义序列
"no-param-reassign": 2,//禁止给参数重新赋值
"no-path-concat": 0,//node中不能使用__dirname或__filename做路径拼接
"no-plusplus": 0,//禁止使用++，--
"no-process-env": 0,//禁止使用process.env
"no-process-exit": 0,//禁止使用process.exit()
"no-proto": 2,//禁止使用__proto__属性
"no-redeclare": 2,//禁止重复声明变量
"no-regex-spaces": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/
"no-restricted-modules": 0,//如果禁用了指定模块，使用就会报错
"no-return-assign": 1,//return 语句中不能有赋值表达式
"no-script-url": 0,//禁止使用javascript:void(0)
"no-self-compare": 2,//不能比较自身
"no-sequences": 0,//禁止使用逗号运算符
"no-shadow": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名
"no-shadow-restricted-names": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用
"no-spaced-func": 2,//函数调用时 函数名与()之间不能有空格
"no-sparse-arrays": 2,//禁止稀疏数组， [1,,2]
"no-sync": 0,//nodejs 禁止同步方法
"no-ternary": 0,//禁止使用三目运算符
"no-trailing-spaces": 1,//一行结束后面不要有空格
"no-this-before-super": 0,//在调用super()之前不能使用this或super
"no-throw-literal": 2,//禁止抛出字面量错误 throw "error";
"no-undef": 1,//不能有未定义的变量
"no-undef-init": 2,//变量初始化时不能直接给它赋值为undefined
"no-undefined": 2,//不能使用undefined
"no-unexpected-multiline": 2,//避免多行表达式
"no-underscore-dangle": 1,//标识符不能以_开头或结尾
"no-unneeded-ternary": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;
"no-unreachable": 2,//不能有无法执行的代码
"no-unused-expressions": 2,//禁止无用的表达式
"no-unused-vars": [2, {"vars": "all", "args": "after-used"}],//不能有声明后未被使用的变量或参数
"no-use-before-define": 2,//未定义前不能使用
"no-useless-call": 2,//禁止不必要的call和apply
"no-void": 2,//禁用void操作符
"no-var": 0,//禁用var，用let和const代替
"no-warning-comments": [1, { "terms": ["todo", "fixme", "xxx"], "location": "start" }],//不能有警告备注
"no-with": 2,//禁用with

"array-bracket-spacing": [2, "never"],//是否允许非空数组里面有多余的空格
"arrow-parens": 0,//箭头函数用小括号括起来
"arrow-spacing": 0,//=>的前/后括号
"accessor-pairs": 0,//在对象中使用getter/setter
"block-scoped-var": 0,//块语句中使用var
"brace-style": [1, "1tbs"],//大括号风格
"callback-return": 1,//避免多次调用回调什么的
"camelcase": 2,//强制驼峰法命名
"comma-dangle": [2, "never"],//对象字面量项尾不能有逗号
"comma-spacing": 0,//逗号前后的空格
"comma-style": [2, "last"],//逗号风格，换行时在行首还是行尾
"complexity": [0, 11],//循环复杂度
"computed-property-spacing": [0, "never"],//是否允许计算后的键名什么的
"consistent-return": 0,//return 后面是否允许省略
"consistent-this": [2, "that"],//this别名
"constructor-super": 0,//非派生类不能调用super，派生类必须调用super
"curly": [2, "all"],//必须使用 if(){} 中的{}
"default-case": 2,//switch语句最后必须有default
"dot-location": 0,//对象访问符的位置，换行的时候在行首还是行尾
"dot-notation": [0, { "allowKeywords": true }],//避免不必要的方括号
"eol-last": 0,//文件以单一的换行符结束
"eqeqeq": 2,//必须使用全等
"func-names": 0,//函数表达式必须有名字
"func-style": [0, "declaration"],//函数风格，规定只能使用函数声明/函数表达式
"generator-star-spacing": 0,//生成器函数*的前后空格
"guard-for-in": 0,//for in循环要用if语句过滤
"handle-callback-err": 0,//nodejs 处理错误
"id-length": 0,//变量名长度
"indent": [2, 4],//缩进风格
"init-declarations": 0,//声明时必须赋初值
"key-spacing": [0, { "beforeColon": false, "afterColon": true }],//对象字面量中冒号的前后空格
"lines-around-comment": 0,//行前/行后备注
"max-depth": [0, 4],//嵌套块深度
"max-len": [0, 80, 4],//字符串最大长度
"max-nested-callbacks": [0, 2],//回调嵌套深度
"max-params": [0, 3],//函数最多只能有3个参数
"max-statements": [0, 10],//函数内最多有几个声明
"new-cap": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用
"new-parens": 2,//new时必须加小括号
"newline-after-var": 2,//变量声明后是否需要空一行
"object-curly-spacing": [0, "never"],//大括号内是否允许不必要的空格
"object-shorthand": 0,//强制对象字面量缩写语法
"one-var": 1,//连续声明
"operator-assignment": [0, "always"],//赋值运算符 += -=什么的
"operator-linebreak": [2, "after"],//换行时运算符在行尾还是行首
"padded-blocks": 0,//块语句内行首行尾是否要空行
"prefer-const": 0,//首选const
"prefer-spread": 0,//首选展开运算
"prefer-reflect": 0,//首选Reflect的方法
"quotes": [1, "single"],//引号类型 `` "" ''
"quote-props":[2, "always"],//对象字面量中的属性名是否强制双引号
"radix": 2,//parseInt必须指定第二个参数
"id-match": 0,//命名检测
"require-yield": 0,//生成器函数必须有yield
"semi": [2, "always"],//语句强制分号结尾
"semi-spacing": [0, {"before": false, "after": true}],//分号前后空格
"sort-vars": 0,//变量声明时排序
"space-after-keywords": [0, "always"],//关键字后面是否要空一格
"space-before-blocks": [0, "always"],//不以新行开始的块{前面要不要有空格
"space-before-function-paren": [0, "always"],//函数定义时括号前面要不要有空格
"space-in-parens": [0, "never"],//小括号里面要不要有空格
"space-infix-ops": 0,//中缀操作符周围要不要有空格
"space-return-throw-case": 2,//return throw case后面要不要加空格
"space-unary-ops": [0, { "words": true, "nonwords": false }],//一元运算符的前/后要不要加空格
"spaced-comment": 0,//注释风格要不要有空格什么的
"strict": 2,//使用严格模式
"use-isnan": 2,//禁止比较时使用NaN，只能用isNaN()
"valid-jsdoc": 0,//jsdoc规则
"valid-typeof": 2,//必须使用合法的typeof的值
"vars-on-top": 2,//var必须放在作用域顶部
"wrap-iife": [2, "inside"],//立即执行函数表达式的小括号风格
"wrap-regex": 0,//正则表达式字面量用小括号包起来
"yoda": [2, "never"]//禁止尤达条件
```

#### 扩展extends

如果每条规则都需要团队协商配置还是比较繁琐的，在项目开始配置时，我们可以先使用一些业内已经成熟的、大家普遍遵循的编码规范（最佳实践）；我们可以通过`extends`字段传入一些规范，它接收String/Array：

```json
{
    "extends": [
        "eslint:recommended",
        "plugin:vue/essential",
        "@vue/prettier",
        "eslint-config-standard"
    ]
}
```

extends可以使用以下几种类型的扩展：

- eslint：开头的ESLint官方扩展，有两个：`eslint:recommended`（推荐规范）和`eslint:all`（所有规范）。
- plugin：开头的扩展是插件类型扩展
- eslint-config：开头的来自npm包，使用时可以省略`eslint-config-`，比如上面的可以直接写成`standard`
- @：开头的扩展和eslint-config一样，是在npm包上面加了一层作用域scope

> 需要注意的是：多个扩展中有相同的规则，以后面引入的扩展中规则为准。

`eslint:recommended`推荐使用的规则在规则列表的右侧用`绿色√`标记。

#### Tips

- eslint在setting.json中配置和.eslintrc.js文件配置区别

  https://segmentfault.com/q/1010000023094556

  setting.json里面配的是vscode对eslint插件的一些配置，而.eslintrc里面配的是对代码规范的配置。目标不一样。vscode的所有配置都针对于插件或者vscode自身的。除了特别指定，这个 eslint 配置文件将会覆盖掉 vscode 的 setting.json 中 eslint 相关的配置。

##### Prettier

它是**代码格式化工具**，用来做代码格式化，有了Prettier之后，它能去掉原始的代码风格，确保团队的代码使用统一相同的格式，修复规则可自定义。

```js
    //  #让prettier使用eslint的代码格式进行校验 
    "prettier.eslintIntegration": true,
```

联调规范

⽂件命名规范

代码样式规范

git flow

# git

## git如何创建多个ssh

### 1.清除原有的设置

**初次使用git请跳过此步骤**

如果之前对git设置过global信息，则需要先清除这些信息，通过如下指令：

查看Git所有配置

```
git config --list
```

查看当前用户（**local**）配置

```
git config --local  --list
或者
cat .git/config
```

查看`user.name`

```
git config user.name
```

查看`user.email`

```
git config user.email
```

**删除**全局配置项

```
git config --global --unset user.name
```

### 2.ssh配置

1. 配置用户信息	

```
cd ~/workspace/gitlab
git init
git config --local user.name ‘gitlab‘//local局部 global
git config --local user.email ‘gitlab@company.com‘
```

2.	生成ssh key

```
ssh-keygen -t rsa -C "email"
```

 当命令行出现 Enter file in which to save the key (~/.ssh/id_rsa):  

 它会提示你输入一个保存key的路径/文件名，默认创建文件名id_rsa（若有多个邮箱，则创建不同的文件名）

 在.ssh文件中找到创建的id_rsa_pub并复制里面的内容，在远程的设置的密钥（key）里面粘贴

3.	配置config文件(id_rsa文件同级目录下)

```
#Host 它涵盖了下面一个段的配置，我们可以通过他来替代将要连接的服务器地址。
#HostName    真正连接的服务器地址
#User是本地ssh-agent与github服务器建立SSH连接时采用的用户名，IdentityFile是对应的私钥文件


#ssh -T User@Host	判断连接是否成功

# gitlab
Host git.lab
HostName gitlab.com
User git
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_lab

# github
Host git.hub
HostName github.com
User git
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa
```

4. 本地仓库与远程仓库关联：

   ```
   git remote add origin(设置的远程库名) User@Host:用户名/仓库名
   或者直接 git clone 链接(一般是master上的分支)
   
   clone https时，每次pull都会输入密码
   git config --global credential.helper store
   ```

5. 测试连接成功

   ```
   ssh -T User@Host
   ```
   
## git 指令

### 初始化

git init 初始化版本库（clone下来的不用初始化）

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6737sZ1ptKUEQcY6YOcKFqqqdv3riaAEJYVibl3GUgmRTiaH5sldypibNN7Zzk3Zqv9lMCAAsvT4vVQw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

首先**工作区**就是我们当前的文件目录，我们改完代码，用`git add`命令把当前文件加入**暂存区**，然后`git commit`把**暂存区**生成的快照提交到**本地仓库**，最后再用`git push`命令把**本地仓库**的提交复制到**远程仓库**，也就是`Github`之类的在线仓库。

git add  文件名      						                放入暂存区stage

git commit -m "提交的说明message"		放入分支里

git commit  -am   										 add和commit的合并，便捷写法

git commit --amend  								   尝试重新提交(**漏掉了几个文件没有添加，或者提交信息commit message写错**)，新增的`commit`会代替原来的`commit`的位置，而旧`commit`则被抛弃掉

### **commit规范**

```
feat:     A new feature
fix:      A bug fix
docs:     Documentation only changes
style:    Changes that do not affect the meaning of the code
refactor: A code change that neither fixes a bug nor adds a feature
perf:     A code change that improves performance
test:     Adding missing tests or correcting existing tests
```

分支规范https://zhuanlan.zhihu.com/p/108385922

### 本地分支的操作

```bash
git checkout -b dev 或者git switch -c dev    创建并切换该分支
git branch dev 								创建分支
git checkout master							切换分支
git branch -d dev							删除分支
git branch -D dev							强行删除一个没有合并的分支    
git branch -vv                              查看关联关系                         

git branch									查看本地分支
git branch -r			    				查看远程分支
git branch -a 			   					查看所有分支（包括远程分支和本地分支）
git branch -a | grep paynicorn2-repay-notice 查询指定分支(本地和远程的)
```

### 远程分支的操作

```bash
远程分支的移除
git remote rm paul				
git push origin --delete main
远程分支重命名，pb 重命名为 paul
git remote rename pb paul
拉取远程分支到本地
git checkout -b dev origin/dev	         直接拉取远程的分支，创建为本地的分支
推送到远程分支
git push --set-upstream origin wangxiao	 将本地的分支推送远程上（第一次推送）
git push orgin dev 						 上传分支到远程dev
为此分支创建跟踪信息，您可以执行：
git branch --set-upstream-to=origin/<分支> master
//https://blog.csdn.net/wangqingpei557/article/details/53147086
删除远程分支，git branch -a,还是可以看到远程的分支
解决：git remote prune origin 
//无法连接到仓库,尝试重新连接
 git remote rm origin  删除远程origin
 git remote add origin git@git.hub.bundle:bibo72/bundleb2b-v3.0-storefront.git
```

### 合并分支的操作

```
git rebase 分支	合并本地分支

git config --global pull.rebase true     这个配置就是告诉git在每次pull前先进行rebase操作
git pull orgin 分支名					   拉取远程分支并合并分支
pull= fetch + merge
git pull --rebase
pull= fetch + rebase

git fetch
从远程获取最新版本到本地，不会自动合并分支

git rebase --abort
执行之后，本地内容会回到提交之间的状态，也就是回到以前提交但没有pull的状态，简单来说就是撤销rebase。

git合并其他分支上指定的commit
git cherry-pick 1f56cd48e7f3da2b9d2bcd2d853e992d74d68885
```

### 查看信息

<img src="https://img2018.cnblogs.com/blog/333765/202001/333765-20200111163049190-252688967.png" alt="img" style="zoom: 67%;" />

```
//查看文件状态（是否被add或者commit）
git status 					  
使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出
//文件的区别
git diff 						 		    区和的暂存区差异
git diff HEAD								显示工作区与当前分支最新commit之间的差异
git diff --cached 							显示暂存区和上一个commit的差异
git diff branch-1 branch-2 	[filename]		比较两个分支(filename)的不同
git diff commit1..commit2  					查看两个 commit 的对比
git ls-files								查看暂存区的文件
git diff origin/branchname..branchname 		查看远程分支和本地分支的对比

//查看提交日志，每一次提交都有对应的 commit id 和 commit message(看不出来被删除的commitid),可以加上参数--pretty=oneline，只会显示版本号和提交时的备注信息
git log							
git log  -p					  用来显示每次提交的内容差异							
//记录操作记录(包括已经被删除的 commit 记录和 reset 的操作)		  
git reflog					  

git remote -v				查看关联的远程仓库url
cat .git/HEAD			    查看当前 HEAD 指向
```

### 回退系列

```bash
git reset --hard HEAD^					    回退到上一个版本
git reset --hard HEAD~1					    回退到上一个版本
git reset --hard id(前6位就行)	        	 回退到指定版本

git checkout .										   清空工作区改动
git checkout -- 文件名 					  

当你开始修改一个文件后，还没有执行 git add命令前(此时还在工作区）,想撤销对这个文件的改动，可以使用git checkout -- 文件名 
一旦你使用了 git add命令将文件添加到暂存区，此时不想改这个文件了，需要用git reset HEAD filename(git reset HEAD .)把文件移会到工作区，再使用第一步的git checkout -- 文件名 撤销工作区改动
```

### 文件的操作

```bash
git rm 文件名									删除文件，若误删，可以使用git checkout -- 文件名 
rm -rf  `git status | grep app/code`
cut 文件名										 获取文件内容
```

### git stash

  **questionRichText** 

766175e369a93a746a4e101a2ab629f5743a00ca

2c2fe0a234e2d5bbedbb97bbfe6ff33dd33e3f0f

 54ebea380e3af0aed9e10195e8a4b6905487d48b

5901800f5710ead923c46d335723eda62905771c

```bash
（1）git stash save "save message"  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。

（2）git stash list  ：查看stash了哪些存储

（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@{$num}，比如第二个 git stash show stash@{1}

（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@{$num}  -p ，比如第二个：git stash show  stash@{1}  -p

（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，git stash apply stash@{$num} ， 比如第二个：git stash apply stash@{1} 

（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}

（7）git stash drop stash@{$num} ：丢弃stash@{$num}存储，从列表中删除这个存储

（8）git stash clear ：删除所有缓存的stash
```

### git rebase 

https://www.cnblogs.com/tian874540961/p/12172900.html

https://blog.csdn.net/hudashi/article/details/7664631/

https://www.cnblogs.com/hujunzheng/p/9732936.html

<img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/086ccdee-4f40-4a8c-99c8-886bc672f0d8.jpg" alt="img" style="zoom:50%;" />

当我开发完D后，准备push到远端master时，git会进行检查：**远端master的最新节点是否是节点D的基点，即检查远端master的基点是否是节点C**，如果是，则可以直接push，如果不是，也就是上图的情况：在你push之前远端master已经被他人提交了E和F节点，这时可以执行`git pull -r`

<img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/88729b51-5f43-42a5-bd69-9c39f863ab92.jpg" alt="img" style="zoom:50%;" />

git会以F节点作为新的基点，与D节点的代码进行融合，如果此时出现**冲突**，那么你就会被移到临时解冲突的分支，需要人工解冲突，解完后执行`git add -A`保存操作，再执行`git rebase --continue`继续后续操作，你可能会遗漏某一处冲突，这个完全不同担会帮你检查是否解决完成，如果没有完成则不会让你回到正常分支。

<img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/beb6433f-49e8-4b42-b821-32a7350f2cc7.jpg" alt="img" style="zoom:50%;" />

此时我再执行`git push`，就可以顺利将D节点提交到远端master上去了：

<img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/469b4e16-c88d-4f71-9dde-c7eb432b7a78.jpg" alt="img" style="zoom:50%;" />

这同理本地基于master分支创建dev分支，master拉取远程代码后(其他人push了代码到远程master)，本地的master领先与dev分支，所以需要rebase，不然会污染了 commit 记录

```
git rebase --edit-todo
git rebase —abort 都可以用 --abort 参数来终止 rebase 的行动，并且分支会回到 rebase 开始前的状态。
```

- 合并多个提交

  ```
  git rebase -i HEAD~2
  将第二行的 pick 改为 s “s” 为 “squash” 的缩写
  ```
  
  
  
  ```
  pick：保留该commit（缩写:p）
  reword：保留该commit，但我需要修改该commit的注释（缩写:r）
  edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）
  squash：将该commit和前一个commit合并（缩写:s）
  fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）
  exec：执行shell命令（缩写:x）
  drop：我要丢弃该commit（缩写:d）
  ```

- git config --global branch.autosetuprebase always

## Tips

- clone https时，每次pull都会输入密码
  git config --global credential.helper store

- git忽略文件权限的改变
  git config core.filemode false
  
- git 换行符LF与CRLF转换问题https://blog.csdn.net/qq_22978533/article/details/78145935

  在各操作系统下，文本文件所使用的换行符是不一样的。UNIX/Linux/ Mac OS使用的是 LF，但 DOS/Windows 一直使用 CRLF作为换行符。Git提供了一个“换行符自动转换”功能。这个功能默认处于“自动模式”，当你在签出文件时，它试图将 UNIX 换行符（LF）替换为 Windows 的换行符（CRLF）；当你在提交文件时，它又试图将 CRLF 替换为 LF。Git 的“换行符自动转换”功能听起来似乎很智能、很贴心，因为它试图一方面保持仓库内文件的一致性（UNIX 风格），一方面又保证本地文件的兼容性（Windows 风格）。但遗憾的是，这个功能是有 bug 的，而且在短期内都不太可能会修正。

  ```
  #提交时转换为LF，检出时不转换
  git config --global core.autocrlf input
  #提交检出均不转换
  git config --global core.autocrlf false
  #提交检出均转换
  git config --global core.autocrlf true
  
  SafeCRLF
  #拒绝提交包含混合换行符的文件
  git config --global core.safecrlf true
  #允许提交包含混合换行符的文件
  git config --global core.safecrlf false
  #提交包含混合换行符的文件时给出警告
  git config --global core.safecrlf warn
  
  ```


- 解决Git在添加ignore文件之前就提交了项目无法再过滤问题

  ```matlab
  首先为避免冲突需要先同步下远程仓库
  $ git pull
  在本地项目目录下删除缓存
  $ git rm -r --cached .
  新建.gitignore文件
  在项目的根目录下面新建.gitignore文件并添加相应的过滤规则
  
  再次add所有文件
  输入以下命令，再次将项目中所有文件添加到本地仓库缓存中
  $ git add .
  
  再次添加commit
  这次commit是为了说明添加ignore文件的。
  $ git commit -m "add ignore"  
  最后提交到远程仓库即可
  $ git push
  ```

- fatal: 当前分支 master 没有对应的上游分支。
  为推送当前分支并建立与远程上游的跟踪，使用

      git push --set-upstream origin master

- 无法连接到仓库,尝试重新连接

  ```
  git remote rm origin  删除远程origin
  git remote add origin git@git.hub.bundle:bibo72/bundleb2b-v3.0-storefront.git
  ```

- ```
  git config --global core.editor vim 
  ```

- ```
  clone https时，每次pull都会输入密码
  git config --global credential.helper store
  ```

  

# npm

## 下载npm

**解决npm下载慢的问题**

方法一：使用淘宝定制的cnpm命令行工具替代默认安装npm

复制代码

```
npm install -g cnpm --registry=https://registry.npm.taobao.org
```

方法二：将npm默认的下载地址修改为淘宝镜像

复制代码

```
npm config set registry https://registry.npm.taobao.org/
```

注意，如果将来你需要发布自己的软件包时，需要将registry字段的值修改回来

```
npm config set registry https://registry.npmjs.org/
```

**npm-check**

[npm-check](https://link.zhihu.com/?target=https%3A//link.jianshu.com/%3Ft%3Dhttps%3A//www.npmjs.com/package/npm-check)是用来检查npm依赖包是否有更新，错误以及不在使用的，我们也可以使用npm-check进行包的更新

安装npm-check：

> npm install -g npm-check

检查npm包的状态:

> npm-check -u -g

**升级依赖**

> npm install -g npm-check-updates
>
> ncu -u

**查找未使用的npm包**

> npm install -g depcheck
>
> depcheck

## 插件

### 工具类

- 将DOM转化成canvas对象

  http://html2canvas.hertzen.com/dist/html2canvas.min.js

- 将canvas生成照片

  HTTP://github.com/randreucetti/canvas2image

- 一个用于将文本复制到剪贴板的 JS 库

  https://github.com/zenorocha/clipboard.js

- QRCode:生成二维码

  https://www.npmjs.com/package/qrcode#api

  https://zh.qr-code-generator.com/

  ```
  QRCode.toDataURL(url.basePage + "/common/share/#/homeshare")
  .then(url => {
  this.qrcodeImg = url
  })
  .catch(err => {
  console.error(err);
  });
  ```

### 时间处理类

- moment时间处理：http://momentjs.cn/

### 性能优化类

- register-service-worker

  首先了解什么是service workers

  > (源自[Service workers API-MDN](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FService_Worker_API))
  >
  > Service workers 本质上充当 Web **应用程序**、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用来采取适当的动作、更新来自服务器的的资源。
  >
  > Service worker是一个注册在指定源和路径下的事件驱动[worker](https://developer.mozilla.org/zh-CN/docs/Web/API/Worker)。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源
  >
  > Service worker运行在worker上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，同步API（如[XHR](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)和[localStorage (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API)）不能在service worker中使用。

  `registerServiceWorker.js`就是用来控制 `Service workers` 的注册和卸载，它可以在 **生产环境** 中(**只在生产环境中有效**)，注册一个`service worker`来为本地缓存提供服务。这使得应用程序在随后的访问中加载更快，并且可以实现离线加载。

### 环境

- cross-env

  运行跨平台设置和使用环境变量的脚本(当您使用NODE_ENV =production, 来设置环境变量时，大多数[Windows](https://www.baidu.com/s?wd=Windows&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)命令提示将会阻塞(报错)。)

### APP

**H5页面唤起指定app或跳转到应用市场**

https://suanmei.github.io/2018/08/23/h5_call_app/

github插件：https://github.com/suanmei/callapp-lib

### 加密

##### js-md5

### 存储

#### js-cookie

```
npm install js-cookie --save
import Cookies from 'js-cookie'
```

```js
// Create a cookie, valid across the entire site:  
Cookies.set('name', 'value');  
   
// Create a cookie that expires 7 days from now, valid across the entire site:  
Cookies.set('name', 'value', { expires: 7 });  
   
// Create an expiring cookie, valid to the path of the current page:  
Cookies.set('name', 'value', { expires: 7, path: '' }); 

// Read cookie:  
Cookies.get('name'); // => 'value'  
Cookies.get('nothing'); // => undefined  
   
// Read all visible cookies:  
Cookies.get(); // => { name: 'value' }  

// Delete cookie:  
Cookies.remove('name');  
   
// Delete a cookie valid to the path of the current page:  
Cookies.set('name', 'value', { path: '' });  
Cookies.remove('name'); // fail!  
Cookies.remove('name', { path: '' }); // removed!  
Cookies.remove('name', { path: '', domain: '' }); // removed! 
```

### axios

```js
1
// 创建 axios 实例
const service = axios.create({
  baseURL: process.env.VUE_APP_API_BASE_URL, // api base_url
  timeout: 6000 // 请求超时时间
})
// 添加请求拦截器
service.interceptors.request.use(config => {
  return handleParams(config)
}, err)
let showLoading = null
function handleParams(){
  if (!showLoading) {
    showLoading = Toast.loading({
      duration: 0, // 持续展示 toast
      forbidClick: true, // 是否禁止点击背景
      message: '加载中'
    });
  }
}
// 对请求错误做些什么
const err = (error) => {
  if (error.response) {
    const data = error.response.data
    if (error.response.status === 403) {
      failToast('Forbidden')
    }
    if (error.response.status === 401 && !(data.result && data.result.isLogin)) {
      failToast('Unauthorized')
    }
  } else {
    // 请求超时状态
    if (error.message.includes('timeout')) {
      console.log('超时了')
      failToast('请求超时，请检查网络是否连接正常')
    } else {
      // 可以展示断网组件
      console.log('断网了')
      failToast('请求失败，请检查网络是否已连接')
    }
  }
  showLoading && showLoading.clear()
  showLoading = null
  return Promise.reject(error)
}
// 添加响应拦截器
service.interceptors.response.use(config => {
  return handleParams(config)
}, err)
2
//封装请求方式
const request = (url, params = {}, method = 'post') => {
  return ['post', 'put'].includes(method) ? axios({url, method, data: params}) : axios({url, method, params})
}
3
//发请求
export function respondSurvey (params) {
  return request(api_share.respondSurvey, params)
}
```

## 命令

查看当前项目安装过的依赖模块
npm list --depth 0

查看全局安装过的依赖模块
npm list -g --depth 0

清理缓存命令：

- 局部

```
npm cache clean --force
```

- 全局

  ```
  cd ~/.npm
  du -sh * 
  rm -rf _cacache   
  ```

- nvm设置默认node版本：nvm alias default v14.18.2

# yarn

```bash
安装yarn 
npm install -g yarn
安装成功后，查看版本号： 
yarn --version
创建文件夹 yarn 
md yarn
进入yarn文件夹 
cd yarn
初始化项目 
yarn init // 同npm init，执行输入信息后，会生成package.json文件
yarn的配置项： 
yarn config list // 显示所有配置项
yarn config get <key> //显示某配置项
yarn config delete <key> //删除某配置项
yarn config set <key> <value> [-g|--global] //设置配置项
安装包
yarn install //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lock
yarn install --flat //安装一个包的单一版本
yarn install --force //强制重新下载所有包
yarn install --production //只安装dependencies里的包
yarn install --no-lockfile //不读取或生成yarn.lock
yarn install --pure-lockfile //不生成yarn.lock
添加包（会更新package.json和yarn.lock）
yarn add [package] // 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中
yarn add [package]@[version] // 安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数
yarn add [package]@[tag] // 安装某个tag（比如beta,next或者latest）
//不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型：

yarn add --dev/-D // 加到 devDependencies
yarn add --peer/-P // 加到 peerDependencies
yarn add --optional/-O // 加到 optionalDependencies
//默认安装包的主要版本里的最新版本，下面两个命令可以指定版本：

yarn add --exact/-E // 安装包的精确版本。例如yarn add foo@1.2.3会接受1.9.1版，但是yarn add foo@1.2.3 --exact只会接受1.2.3版
yarn add --tilde/-T // 安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0
发布包
yarn publish
移除一个包 
yarn remove <packageName>：移除一个包，会自动更新package.json和yarn.lock
查看包的缓存列表
yarn cache list
全局安装包 == npm -g
yarn global
更新一个依赖 yarn upgrade 用于更新包到基于规范范围的最新版本 运行脚本 yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本 显示某个包的信息 yarn info <packageName> 可以用来查看某个模块的最新版本信息 缓存 yarn cache yarn cache list # 列出已缓存的每个包 yarn cache dir # 返回 全局缓存位置 yarn cache clean # 清除缓存
```


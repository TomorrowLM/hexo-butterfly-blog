---
slug: 前端原理和源码
title: 前端原理和源码
description: 前端原理和源码
keywords: vue,webpack,响应式,路由,响应式,diff
category: 前端
tags: [vue,webpack,响应式,路由,响应式,diff]
author: liming
date: 28-12-2022
sticky: 4
swiper_index: 4
swiper_desc: vue,webpack,响应式,路由,响应式,diff
---

# webpack

## webpack执⾏流程

### 简略流程

<img src="img/常识/image-20220909135015955.png" alt="image-20220909135015955" style="zoom: 50%;" />

图示流程理解分析：

1. 读取⼊⼝⽂件；

2. 基于 AST（抽象语法树） 分析⼊⼝⽂件，并产出依赖列表；

3. AST （Abstract Syntax Tree）抽象语法树 在计算机科学中，或简称语法树（Syntax tree），是源代码语法结构的⼀种抽象表示。它以树状的形式表现编程语⾔的语法结构，树上的每个节点都表示源代码中的⼀种结构。
4. 使⽤ Babel 将相关模块编译到 ES5；

5. webpack有⼀个智能解析器（各种babel），⼏乎可以处理任何第三⽅库。⽆论它们的模块形式是CommonJS、AMD还是普通的JS⽂件；甚⾄在加载依赖的时候，允许使⽤动态表require("、/templates/"+name+"、jade")。以下这些⼯具底层依赖了不同的解析器⽣成AST，⽐如eslint使⽤了espree、babel使⽤了acorn

6. 对每个依赖模块产出⼀个唯⼀的 ID，⽅便后续读取模块相关内容；

7. 将每个依赖以及经过 Babel 编译过后的内容，存储在⼀个对象中进⾏维护；

8. 遍历上⼀步中的对象，构建出⼀个依赖图（Dependency Graph）；

9. 将各模块内容 bundle 产出

### 详细流程

<img src="http://blog.51weblove.com/wp-content/uploads/2021/10/webpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-scaled.jpg" alt="img" style="zoom: 150%;" />

流程：

1. 通过命令行和 `webpack.config.js` 来获取参数
2. 创建`compiler`对象，初始化`plugins`
3. 开始编译阶段，`addEntry`添加入口资源
4. `addModule` 创建模块
5. `runLoaders` 执行 `loader`
6. 依赖收集，js 通过`acorn`解析为 `AST`，然后查找依赖，并重复 4 步
7. 构建完**依赖树**后，进入生成阶段，调用`compilation.seal`
8. 经过一系列的`optimize`优化依赖，生成 `chunks`，写入文件

## 打包原理

⼿写webpack原理 https://juejin.cn/post/6854573217336541192

webpack打包原理 https://blog.csdn.net/weixin_41319237/article/details/116194091

**主要流程**

1. 需要读到入口文件里面的内容
2. 分析入口文件，递归的去读取模块所依赖的文件内容，生成AST语法树。
3. 根据AST语法树，生成浏览器能够运行的代码

**具体细节**

1. 获取主模块内容
2. 分析模块
   - 安装@babel/parser包（生成AST）
3. 对模块内容进行处理
   - 安装@babel/traverse包（遍历AST收集依赖）
   - 安装@babel/core和@babel/preset-env包   （es6转ES5）
4. 递归所有模块
5. 执行require和exports。生成最终代码

### 基本准备工作

先建一个项目

我们创建了add.js文件和minus.js文件,然后 在index.js中引入，再将index.js文件引入index.html。

代码如下:

add.js

```css
export default (a,b)=>{
  return a+b;
}
复制代码
```

minus.js

```css
export const minus = (a,b)=>{
    return a-b
}
复制代码
```

index.js

```javascript
import add from "./add.js"
import {minus} from "./minus.js";

const sum = add(1,2);
const division = minus(2,1);

console.log(sum);
console.log(division);
```

index.html

```xml
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script src="./src/index.js"></script>
</body>
</html>
复制代码
```

现在我们打开index.html。你猜会发生什么？？？显然会报错，因为浏览器还不能识别import等ES6语法

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e4428e16ee77~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

### 获取主模块内容

bundle.js文件

```javascript
// 获取主入口文件
const fs = require('fs')
const getModuleInfo = (file)=>{
    const body = fs.readFileSync(file,'utf-8')
    console.log(body);
}
getModuleInfo("./src/index.js")
```

执行一下bundle.js：`node bundle.js`

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e4428eab35af~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

### 分析模块babel/parser

分析模块的主要任务是 将获取到的主模块内容 解析成AST语法树，这个需要用到一个依赖包@babel/parser

```bash
npm install @babel/parser
```

ok,安装完成我们将@babel/parser引入bundle.js,

```javascript
// 获取主入口文件
const fs = require('fs')
const parser = require('@babel/parser')
const getModuleInfo = (file)=>{
    const body = fs.readFileSync(file,'utf-8')
    // 新增代码
    const ast = parser.parse(body,{
        sourceType:'module' //表示我们要解析的是ES模块
    });
    console.log(ast);
//当前我们解析出来的不单单是index.js文件里的内容，它也包括了文件的其他信息。 而它的内容其实是它的属性program里的body里
    console.log(ast.program.body);
}
getModuleInfo("./src/index.js")
```

### 收集依赖babel/traverse

现在我们需要 遍历AST，将用到的依赖收集起来。什么意思呢？其实就是将用import语句引入的文件路径收集起来。我们将收集起来的路径放到deps里。

前面我们提到过，遍历AST要用到@babel/traverse依赖包

```bash
npm install @babel/traverse
```

现在，我们引入。

```js
const fs = require('fs')
const path = require('path')
const parser = require('@babel/parser')
const traverse = require('@babel/traverse').default
const getModuleInfo = (file)=>{
    const body = fs.readFileSync(file,'utf-8')
    const ast = parser.parse(body,{
        sourceType:'module' //表示我们要解析的是ES模块
    });
    
    // 新增代码
    const deps = {}
    traverse(ast,{
         //ImportDeclaration方法代表的是对ast中type类型为ImportDeclaration的节点的处理。
        ImportDeclaration({node}){
            const dirname = path.dirname(file)
            const abspath = './' + path.join(dirname,node.source.value)
            deps[node.source.value] = abspath
        }
    })
    console.log(deps);


}
getModuleInfo("./src/index.js")
```

### ES6的AST转化成ES5

```bash
npm install @babel/core @babel/preset-env
```

我们现在将依赖引入并使用

```js
const fs = require('fs')
const path = require('path')
const parser = require('@babel/parser')
const traverse = require('@babel/traverse').default
const babel = require('@babel/core')
const getModuleInfo = (file)=>{
    const body = fs.readFileSync(file,'utf-8')
    const ast = parser.parse(body,{
        sourceType:'module' //表示我们要解析的是ES模块
    });
    const deps = {}
    traverse(ast,{
        ImportDeclaration({node}){
            const dirname = path.dirname(file)
            const abspath = "./" + path.join(dirname,node.source.value)
            deps[node.source.value] = abspath
        }
    })
    
    新增代码
    const {code} = babel.transformFromAst(ast,null,{
        presets:["@babel/preset-env"]
    })
    console.log(code);

}
getModuleInfo("./src/index.js")
```

### 递归获取所有依赖

经过上面的过程，现在我们知道getModuleInfo是用来获取一个模块的内容，不过我们还没把获取的内容return出来，因此，更改下getModuleInfo方法

```js
const getModuleInfo = (file)=>{
    const body = fs.readFileSync(file,'utf-8')
    const ast = parser.parse(body,{
        sourceType:'module' //表示我们要解析的是ES模块
    });
    const deps = {}
    traverse(ast,{
        ImportDeclaration({node}){
            const dirname = path.dirname(file)
            const abspath = "./" + path.join(dirname,node.source.value)
            deps[node.source.value] = abspath
        }
    })
    const {code} = babel.transformFromAst(ast,null,{
        presets:["@babel/preset-env"]
    })
    // 新增代码
    const moduleInfo = {file,deps,code}
    return moduleInfo
}
```

我们返回了一个对象 ，这个对象包括**主模块的路径（file）**，**主模块的依赖（deps）**，**主模块转化成es5的代码**

该方法只能获取一个模块的的信息，但是我们要怎么获取一个模块里面的依赖模块的信息呢？递归。

```
//递归获取依赖
const parseModules = (file) =>{
    const entry =  getModuleInfo(file)
    const temp = [entry]
    for (let i = 0;i<temp.length;i++){
        const deps = temp[i].deps
        if (deps){
            for (const key in deps){
                if (deps.hasOwnProperty(key)){
                    temp.push(getModuleInfo(deps[key]))
                }
            }
        }
    }
    console.log(temp)
}
```

讲解下parseModules方法：

1. 我们首先传入主模块路径
2. 将获得的模块信息放到temp数组里。
3. 外面的循坏遍历temp数组，此时的temp数组只有主模块
4. 循环里面再获得主模块的依赖deps
5. 遍历deps，通过调用getModuleInfo将获得的依赖模块信息push到temp数组里。

按照目前我们的项目来说执行完，应当是temp 应当是存放了index.js,add.js,minus.js三个模块。 ,执行看看。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e442e4a822fc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

不过现在的temp数组里的对象格式不利于后面的操作，我们希望是以文件的路径为key，{code，deps}为值的形式存储。因此，我们创建一个新的对象depsGraph。

```js
const parseModules = (file) =>{
    const entry =  getModuleInfo(file)
    const temp = [entry] 
    for (let i = 0;i<temp.length;i++){
        const deps = temp[i].deps
        if (deps){
            for (const key in deps){
                if (deps.hasOwnProperty(key)){
                    temp.push(getModuleInfo(deps[key]))
                }
            }
        }
    }
    // 新增代码
    const depsGraph = {}
    temp.forEach(moduleInfo=>{
        depsGraph[moduleInfo.file] = {
            deps:moduleInfo.deps,
            code:moduleInfo.code
        }
    })
    console.log(depsGraph)
    return depsGraph
}
```

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e442ed76d596~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

### 导入导出

我们现在的目的就是要生成一个bundle.js文件，也就是打包后的一个文件。其实思路很简单，就是把index.js的内容和它的依赖模块整合起来。然后把代码写到一个新建的js文件。

```js
// index.js
"use strict"
var _add = _interopRequireDefault(require("./add.js"));
var _minus = require("./minus.js");
function _interopRequireDefault(obj) 
{ 
  return obj && obj.__esModule ? obj : { "default": obj }; 
}
var sum = (0, _add["default"])(1, 2);
var division = (0, _minus.minus)(2, 1);
console.log(sum); console.log(division);
```

```js
// add.js
"use strict";
Object.defineProperty(exports, "__esModule", {  value: true});
exports["default"] = void 0;
var _default = function _default(a, b) { return a + b;};
exports["default"] = _default;
```

但是我们现在是不能执行index.js这段代码的，因为浏览器不会识别执行require和exports。

不能识别是为什么？因为没有定义这**require函数，和exports对象**。那我们可以自己定义。



```js
const bundle = (file) => {
  //返回一个整合完整的字符串代码
  const depsGraph = JSON.stringify(parseModules(file)); 
  console.log(depsGraph);
  /**
   * 把保存下来的depsGraph，传入一个立即执行函数。
    将主模块路径传入require函数执行
    执行reuire函数的时候，又立即执行一个立即执行函数，这里是把code的值传进去了
    执行eval（code）。也就是执行主模块的code这段代码
   */
  return `(function (graph) {
    function require(file) {
      //转化成绝对路径
      function absRequire(relPath) {
        return require(graph[file].deps[relPath])
      }
      //执行add.js的code时候，会遇到exports这个还没定义的问题.因此我们可以自己定义一个exports对象。
      var exports = {};
      (function (require, exports, code) {
        console.log(1, exports);
        //code代码执行过程中会执行到require函数。
        //这时会调用这个require，也就是我们传入的absRequire
        eval(code);
      })(absRequire, exports, graph[file].code)
      return exports;
    }
    require('${file}')
  })(${depsGraph})`;
};
const content = bundle("./src/index.js");
```

- 把保存下来的depsGraph，传入一个立即执行函数。

  - 将主模块路径传入require函数执行

    - reuire函数中立即执行函数

      - require：absRequire，因为code代码中require路径不是绝对路径，需要转化成绝对路径，因此写一个函数absRequire来转化

      - exports：exports

        - 增添了一个空对象 exports，执行add.js代码的时候，会往这个空对象上增加一些属性

          ```js
          // add.js
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true});
          exports["default"] = void 0;
          var _default = function _default(a, b) {  return a + b;};
          exports["default"] = _default;
          //执行完这段代码后
          exports = {
            __esModule：{  value: true}，
            default：function _default(a, b) {  return a + b;}
          }
          ```

        - 然后我们把exports对象return出去。

          ```js
          var _add = _interopRequireDefault(require("./add.js"));
          ```

          return出去的值，被_interopRequireDefault接收，_interopRequireDefault再返回default这个属性给_add，因此`_add = function _default(a, b) { return a + b;}`

      - code：graph[file].code

        - 执行eval（code）,也就是执行模块的code这段代码
          - 执行eval（code）过程会执行到require函数，这时会调用这个require，也就是我们传入的absRequire，而执行absRequire就执行了`return require(graph[file].deps[relPath])`这段代码，也就是执行了外面这个require。而执行require（"./src/add.js"）之后，又会执行eval，也就是执行add.js文件的代码。

## Sourcemap

https://mp.weixin.qq.com/s/g5GcZ10G89Xb9hZ1SibVrA

**`Sourcemap` 本质上是一个信息文件（储存着代码转换前后的对应位置信息），关联编译后的代码和源码的，通过一个个行列号的映射。**比如编译后代码的第 3 行第 4 列，对应着源码里的第 8 行第 5 列这种，这叫做一个mapping。简单说 `Sourcemap` 构建了处理前以及处理后的代码之间的一座桥梁，方便定位生产环境中出现 `bug` 的位置。

sourcemap 的格式如下：

```
{
    version : 3,
    file: "out.js",
    sourceRoot : "",
    sources: ["foo.js", "bar.js"],
    names: ["a", "b"],
    mappings: "AAgBC,SAAQ,CAAEA;AAAEA",
    sourcesContent: ['const a = 1; console.log(a)', 'const b = 2; console.log(b)']
}
```

version 是版本号，file 是文件名，sourceRoot 是源码根目录，names 是转换前的变量名，sources 是源码文件，sourcesContent 是每个 sources 对应的源码的内容，mappings 就是一个个位置映射了。

**为什么 sources 可以有多个呢？**

因为可能编译产物是多个源文件合并的，比如打包，一个 bundle.js 就对应了 n 个 sources 源文件。

**为什么要把变量名单独摘出来到 names 里呢？**

因为这样就可以通过下标来索引了，mapping 里面就不用保存变量名，只保留 names 的索引就行。

**重点是 mappings 部分：**

mappings 部分是通过分号`;` 和逗号 `,` 分隔的：

```
mappings:"AAAAA,BBBBB;CCCCC"
```

一个分号就代表一行，这样就免去了行的映射。

然后每一行可能有多个位置的映射，用 `,` 分隔

那具体的每一个 mapping 都是啥呢？

比如 AAAAA 一共五位，分别有不同的含义：

- 第一位：转换后代码的第几列（行数通过分号 ; 来确定）
- 第二位：对应转换前的哪个源码文件，保存在 sources 里的，这里通过下标索引
- 第三位：对应转换前的源码的第几行
- 第四位：对应转换前的源码的第几列
- 第五位：对应转换前的源码的哪个变量名，保存在 names 里的，这里通过下标索引

### 基础配置

- eval：浏览器 devtool 支持通过 sourceUrl 来把 eval 的内容单独生成文件，还可以进一步通过 sourceMappingUrl 来映射回源码，webpack 利用这个特性来简化了 sourcemap 的处理，可以直接从模块开始映射，不用从 bundle 级别。
- cheap：只映射到源代码的某一行，不精确到列，可以提升 sourcemap 生成速度
- source-map：生成 sourcemap 文件，可以配置 inline，会以 dataURL 的方式内联，可以配置 hidden，只生成 sourcemap，不和生成的文件关联。
- nosources：不生成 sourceContent 内容，可以减小 sourcemap 文件的大小
- module：sourcemap 生成时会关联每一步 loader 生成的 sourcemap，配合 sourcemap-loader 可以映射回最初的源码

理解了这些基础配置项，根据 ^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$ 的规律来进行组合，就可以实现各种需求下的 sourcemap 配置。

当然，这种 sourcemap 配置还不够细致，比如 sourcemap 的 url 怎么生成，文件名是什么。如果想对这些做配置，可以关掉 devtool，启用 SourceMapDevToolPlugin 来配置。

虽然 webapck 的 sourcemap 配置方式比较多，但最底层也就是浏览器支持的文件级别的 sourcemap 还有 eval 代码的 source 映射和 sourcemap 这两种机制。其余的方式都是基于这两种机制的封装。

# 单应用框架

## 软件架构模式

https://www.pianshen.com/article/3716256399/

MVC，MVP和MVVM都是常见的[软件架构设计模式](https://www.zhihu.com/search?q=软件架构设计模式&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2396493957})（Architectural Pattern），它通过分离关注点来改进代码的组织方式。它们目标都是解耦，解耦好处一个是关注点分离，提升代码可维护和可读性，并且提升代码复用性。

### MVC

MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的软件设计规范。

- **Model（模型）** ：数据层。将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。

- **View（视图）** ：视图层。

- **Controller（控制器）**：交互层。用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新

![img](https://pics7.baidu.com/feed/8ad4b31c8701a18b40c30015c909c8002838fe6b.png@f_auto?token=e2763c67fdda4b27897e546b2a2b2367)

> 1.View传送指令到Controller。
>
> 2.Controller完成业务逻辑后改变Model状态。
>
> 3.Model将新的数据发送至View,用户得到反馈。    

**缺点**

**1.m层和v层直接打交道，导致这两层耦合度高**

**2.因为所有逻辑都写在c层，导致c层特别臃肿**

控制div是否显示：

```html
<body>
    <div id="box">我显示的</div>
    <button id="btn">点击</button>
    
    <script>
        btn.onclick = function() {
            if(box.style.display === 'none') box.style.display = 'block';
            else box.style.display = 'none';
        }
    </script>
</body>
复制代码
```

用数据驱动模型模型来写：

```js
<body>
    <div id="box">我显示的</div>
    <button id="btn">点击</button>
    
    <script>
        let is_shown = true;
        function render(el, is_shown) {
            if(is_shown) el.style.display = 'block';
            else el.style.display = 'none';
        }
        btn.onclick = function() {
            is_shown = !is_shown;
            render(box, is_shown);
        }
    </script>
</body>
复制代码
```

看起来好像多了几行代码，但是对于第二种代码来说，简单抽象封装了 `render` 函数，我们只需要修改 `is_shown` 的 `bool` 值，而无需在意 `render` 函数内部的执行，就可以实现通过数据修改来驱动视图的更新。

### MVVM

mvc中Controller演变成mvvm中的viewModel。 **mvvm主要解决了mvc中大量DOM操作使页面首次渲染性能降低，加载速度变慢的问题 。**

**Model-View-ViewModel**即模型-视图-视图模型。

- 模型：数据层。后端传递的数据。

- 视图：视图层。

- 视图模型：mvvm模式的核心，它是连接view和model的桥梁。


**总结**：**在MVVM的框架下视图和模型是不能直接通信的**。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的**双向绑定**。

### 区别

- dom操作方式
  - MVC来讲，MVC操作的是真实dom，对于数据的更新需要找到对应抽象类来直接操作真实dom
  - 对于MVVM来讲，它操作的是虚拟dom、**在数据的更新后，该框架重新生成一个虚拟dom树，与旧虚拟dom树进行比对，然后替换修改的地方，所以可以将渲染视图抽象成一个函数类**
- 视图更新
  - MVVM完全不需要考虑视图更新对dom树的操作，框架会自动响应绑定对视图的更新

- 性能
  - 页面首次渲染，MVVM框架可能会比MVC框架快一些，因为MVVM只会进行一次对真实dom的操作，而MVC可能会进行多次真实dom的操作
  - 在首屏渲染完毕后，用户开始对页面进行直接操作时，MVVM的性能肯定会输MVC的
    - 对于MVC构建的页面来说，用户修改数据，该框架会根据绑定的dom元素直接进行修改
    - 而对于MVVM构建的页面来说，用户修改数据，该框架会重新生成虚拟dom树与原树进行比对，再修改
    - 虽然可以进行diff（新旧虚拟dom树比对算法）优化，但是一个是直接操作，一个需要最少O(n)算法比对在进行真实dom操作

- 框架
  - 常见的MVC框架有：Angular.js

## 框架对比

https://juejin.cn/post/6844903974437388295

https://zhuanlan.zhihu.com/p/100228073

### 渐进式

我们可以通过添加组件系统（components）、客户端路由（vue-router）、大规模状态管理（vuex）来构建一个完整的框架，这都是可选的



### 开发团队

+ React是由FaceBook前端官方团队进行维护和更新的；因此，React的维护开发团队，技术实力比较雄厚；
+ Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个小团队进行相关的维护和开发；

### 编写语法

#### vue

vue推荐的做法是webpack+vue-loader的单文件组件格式，**vue保留了html、css、js分离的写法**，使得现有的前端开发者在开发的时候能保持原有的习惯，更接近常用的web开发方式，模板就是普通的html，数据绑定使用mustache风格，样式直接使用css。其中<style>标签还提供了一个可选的scoped属性，它会为组件内 CSS 指定作用域，用它来控制仅对当前组件有效还是全局生效。

模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。

同时vue也支持JSX语法，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。

#### react

用过react的开发者可能知道，**react是没有模板的，直接就是一个渲染函数**，它中间返回的就是一个虚拟DOM树，**React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即'all in js'**。JSX实际就是一套使用XML语法，用于让我们更简单地去描述树状结构的语法糖。在react中，所有的组件的渲染功能都依靠JSX。你可以在render()中编写类似XML的语法，它最终会被编译成原生JavaScript。不仅仅是 HTML 可以用 JSX 来表达，现在的潮流也越来越多地将 CSS 也纳入到 JavaScript 中来处理。JSX是基于 JS 之上的一套额外语法，学习使用起来有一定的成本。

### 构建工具

#### vue

vue提供了CLI 脚手架，可以帮助你非常容易地构建项目。全局安装之后，我们就可以用 vue create命令创建一个新的项目，vue 的 CLI 跟其他 CLI不同之处在于，有多个可选模板，有简单的也有复杂的，可以让用户自定义选择需要安装的模块，还可以将你的选择保存成模板，便于后续使用。

极简的配置，更快的安装，可以更快的上手。它也有一个更完整的模板，包括单元测试在内的各种内容都涵盖，但是，它的复杂度也更高，这又涉及到根据用例来选择恰当复杂度的问题。

#### react

React 在这方面也提供了 create-react-app，但是现在还存在一些局限性：

- 它不允许在项目生成时进行任何配置，而 Vue CLI 运行于可升级的运行时依赖之上，该运行时可以通过插件进行扩展。
- 它只提供一个构建单页面应用的默认选项，而 Vue 提供了各种用途的模板。
- 它不能用用户自建的预设配置构建项目，这对企业环境下预先建立约定是特别有用的。

而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。

### 数据流和数据绑定

![img](https://img-blog.csdnimg.cn/img_convert/f05acead6d25707b82895cb43a8f7695.png)

**Vue和React均是单向数据流传递**，子组件不能直接改变父组件的状态

**Vue是双向绑定和React是单向绑定**

#### vue

Vue是双向数据。Vue采用数据劫持&发布-订阅模式的方式，vue在创建vm的时候，会将数据配置在实例当中，然后通过Object.defineProperty对数据进行操作，为数据动态添加了getter与setter方法，当获取数据的时候会触发对应的getter方法，当设置数据的时候会触发对应的setter方法，从而进一步触发vm的watcher方法，然后数据更改，vm则会进一步触发视图更新操作

#### react

在[React](https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020)中虽然modal和view之间也是通过ViewMode处理,但是却需要setState去手动刷新渲染view，所以叫单向绑定

### diff算法

相同点

1. 虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；
2. 都使用key比较是否是相同节点，都是为了尽可能的复用节点
3. 都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）

#### vue

vue中diff算法实现流程

1. 在内存中构建虚拟dom树
2. 将内存中虚拟dom树渲染成真实dom结构
3. 数据改变的时候，将之前的虚拟dom树结合新的数据生成新的虚拟dom树
4. 将此次生成好的虚拟dom树和上一次的虚拟dom树进行一次比对（diff算法进行比对），来更新只需要被替换的DOM，而**不是全部重绘**。在Diff算法中，只平层的比较前后两棵DOM树的节点，没有进行深度的遍历。
5. 会将对比出来的差异进行重新渲染

#### react

react中diff算法实现流程

1. DOM结构发生改变-----直接卸载并重新create
2. DOM结构一样-----不会卸载,但是会update变化的内容
3. 所有同一层级的子节点.他们都可以通过key来区分-----同时遵循1.2两点
    （其实这个key的存在与否只会影响diff算法的复杂度,换言之,你不加key的情况下,diff算法就会以暴力的方式去根据一二的策略更新,但是你加了key,diff算法会引入一些另外的操作）

React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点，涉及到的DOM操作非常多。diff总共就是移动、删除、增加三个操作，而如果给每个节点唯一的标识（key），那么React优先采用移动的方式，能够找到正确的位置去插入新的节点。

vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。**而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制。**

### 性能

#### react

当props或state发生改变的时候会触发shouldComponentUpdate生命周期函数，它是用来控制组件是否被重新渲染的，如果它返回true，则执行render函数，更新组件；如果它返回false，则不会触发重新渲染的过程。

有的时候我们希望它在更新之前，和之前的状态进行一个对比，这个时候我们就需要重写shouldComponentUpdate来避免不必要的dom操作，对比当前的props或state和更新之后的nextProps或nextState，返回true时 ，组件更新；返回false，则不会更新，节省性能。

#### vue

vue里面由于依赖追踪系统的存在，当任意数据变动的时，Vue的每一个组件都精确地知道自己是否需要重绘，所以并不需要shouldComponentUpdate手动优化。但是当数据特别多的时候vue中的watcher也会特别多，从而造成页面卡顿，所以一般数据比较多的大型项目会倾向于使用react。



### 生命周期

#### vue

```
beforeCreate	
组件实例刚刚被创建，组件的el（Vue实例挂载的元素节点，简单来说el的作用就是将当前vue组件生成的实例插入到页面元素中）和data，methods都未被初始化，调用不了
new Vue({
    el: '#app'
})

created			     
实例已经创建完成，data，methods都已经被初始化，可以被调用但是el还处于未被创建状态。如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作

beforeMount		
template模板已经编译完成，el已经创建完成，但是还没有挂载到页面上，而只是放在内存中

mounted			
页面渲染完成初始化完毕。可以在 mounted 内部使用 vm.$nextTick。 如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行

beforeUpdate	组件更新之前
updated			组件更新完毕	
更新前/后：当data变化时，会触发beforeUpdate和updated方法。

beforeDestroy	组件销毁前
destroyed		组件销毁后
销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。

activated	keep-alive 组件激活时调用。
deactivated	keep-alive 组件停用时调用。
```

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16debf6f691f598a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" style="zoom:50%;" />

#### react

- 初始化阶段（5个）：

  - getDefaultProps：实例化组件之后，组件的getDefaultProps钩子函数会执行

    这个钩子函数的目的是为组件的实例挂载默认的属性

    这个钩子函数只会执行一次，也就是说，只在第一次实例化的时候执行，创建出所有实例共享的默认属性，后面再实例化的时候，不会执行getDefaultProps，直接使用已有的共享的默认属性

    理论上来说，写成函数返回对象的方式，是为了防止实例共享，但是react专门为了让实例共享，只能让这个函数只执行一次

    组件间共享默认属性会减少内存空间的浪费，而且也不需要担心某一个实例更改属性后其他的实例也会更改的问题，因为组件不能自己更改属性，而且默认属性的优先级低。

（2）getInitialState：为实例挂载初始状态，且每次实例化都会执行，也就是说，每一个组件实例都拥有自己独立的状态。

（3）componentWillMount：执行componentWillMount，相当于Vue里的created+beforeMount，这里是在渲染之前最后一次更改数据的机会，在这里更改的话是不会触发render的重新执行。

（4）render：渲染dom

render()方法必须是一个纯函数，他不应该改变

state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。 如果

shouldComponentUpdate()返回

false，

render()不会被调用。

（5）componentDidMount：相当于Vue里的mounted,多用于操作真实dom

【运行中阶段（5个）】

当组件mount到页面中之后，就进入了运行中阶段，在这里有5个钩子函数，但是这5个函数只有在数据（属性、状态）发送改变的时候才会执行

（1）componentWillReceiveProps(nextProps,nextState)

当父组件给子组件传入的属性改变的时候，子组件的这个函数才会执行。初始化props时候不会主动执行

当执行的时候，函数接收的参数是子组件接收到的新参数，这个时候，新参数还没有同步到this.props上,多用于判断新属性和原有属性的变化后更改组件的状态。

（2）接下来就会执行shouldComponentUpdate(nextProps,nextState),这个函数的作用：当属性或状态发生改变后控制组件是否要更新，提高性能,返回true就更新，否则不更新，默认返回true。

接收nextProp、nextState，根据根据新属性状态和原属性状态作出对比、判断后控制是否更新

如果

shouldComponentUpdate()返回

false，

componentWillUpdate,

render和

componentDidUpdate不会被调用。

（3）componentWillUpdate,在这里，组件马上就要重新render了，多做一些准备工作，千万千万，不要在这里修改状态，否则会死循环 相当于Vue中的beforeUpdate

（4）render，重新渲染dom

（5）componentDidUpdate，在这里，新的dom结构已经诞生了,相当于Vue里的updated

【销毁阶段】

当组件被销毁之前的一刹那，会触发componentWillUnmount，临死前的挣扎

相当于Vue里的beforeDestroy，所以说一般会做一些善后的事情，例如使定时器无效，取消网络请求或清理在

componentDidMount中创建的任何监听。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16debf7c76553b3b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)



### 销毁组件

#### vue

vue在调用$destroy方法的时候就会执行beforeDestroy生命周期函数，然后组件被销毁，这个时候组件的dom结构还存在于页面结构中，也就说如果想要对残留的dom结构进行处理必须在destroyed生命周期函数中处理。

#### react

react执行完componentWillUnmount之后把事件、数据、dom都全部处理掉了，也就是说当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁，所以根本不需要其他的钩子函数了。react销毁组件的时候，会将组件的dom结构也移除，vue则不然，在调用destory方法销毁组件的时候，组件的dom结构还是存在于页面中的，this.$destory组件结构还是存在的，只是移除了事件监听，所以这就是为什么vue中有destroyed，而react却没有componentDidUnmount。

### 移动APP开发体验方面

+ Vue，结合 Weex 这门技术，提供了 迁移到 移动端App开发的体验（Weex，目前只是一个 小的玩具， 并没有很成功的 大案例；）
+ React，结合 ReactNative，也提供了无缝迁移到 移动App的开发体验（RN用的最多，也是最火最流行的）；



## SPA、SSR、CSR

https://zhuanlan.zhihu.com/p/299598903

https://zhuanlan.zhihu.com/p/138356519

### 一、SPA

single page web application，单页Web应用，就是只有一张Web页面的应用，**与后台仅仅是数据的交互，不会再请求其它页面**。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。

典型编写SPA的前端框架：React、Angular、Vue。

- 概念：
  - 网站的效果都是显示在`一个静态页面`中的
  - 在页面切换时，其实并没有从一个页面中跳转到另一个页面中，只是通过 `js` 动态的将内容进行了修改
  - 在网站的源代码中是看不到任何数据的

**特点：**

- 优点：
  - 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
  - 基于上面一点，SPA 相对对服务器压力小；
  - 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
- 缺点：
  - 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
  - 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；（vue-router 已经解决了这个问题）
  - SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。
    - 因为单页应用的所有内容都在 index.html 中，页面的切换是通过 js 动态切换的
    - 由于所有的内容切换都是通过 js 动态切换的，所以在页面的源代码中是看不到任何的数据的
    - 由于源代码中看不到任何数据，这是非常不利于 SEO 的，所以我们说 SPA 在 SEO 上有其天然的弱势。
    - vue 中的 SSR 就可以用来解决这个问题。

### 二、SSR

Server Side Rendering，服务器端渲染，传统的渲染方式，由服务端把渲染的完整的页面吐给客户端。这样减少了一次客户端到服务端的一次http请求，加快相应速度，一般用于首屏的性能优化。

典型服务器端渲染的例子就是jsp、asp、php等各种后台模板生成的页面，前端会直接拿到整张页面，不用自己过多的去拼接DOM。

<img src="https://pic1.zhimg.com/80/v2-b4c8866154ac2158d887e04e1e73c2f8_720w.jpg" alt="img" style="zoom:50%;" />

<img src="https://pic3.zhimg.com/80/v2-26e5fd8c489d700be758d43eba801f26_720w.jpg" alt="img" style="zoom:50%;" />

**渲染流程**：

- 阶段一：浏览器请求url --> 服务器路由分析、执行渲染 --> 服务器返回index.html(实时渲染的内容，字符串) --> 浏览器渲染
- 阶段二：浏览器请求bundle.js --> 服务器返回bundle.js --> 浏览器路由分析、生成虚拟DOM --> 比较DOM变化、绑定事件 --> 二次渲染

尽管服务器渲染第一阶段的流程图很长，但是因为服务器渲染速度很快，因此实际耗时与客户端渲染几乎相同。
第一阶段结束时，服务器端返回渲染结果，用户即可看到首屏。而对于客户端渲染，需要等待一次脚本下载时间，以及在客户端的渲染时间。由于客户端的硬件以及网络条件的差异，这两段时间开销可能十分显著。
客户渲染与服务器渲染第二阶段基本一致。所不同的是，服务器渲染流程中，在客户端生成vdom后，并不会重新渲染，而是比较现有dom的checksum来决定是否重新渲染。

**原理**：基于`Virtual DOM`实现了客户端与服务端的同构渲染。

- 在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；
- 在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。

### 三、CSR

客户端渲染(Client Side Render)。渲染过程全部交给浏览器进行处理，服务器不参与任何渲染。页面初始加载的HTML文档中无内容，需要下载执行JS文件，由浏览器动态生成页面，并通过JS进行页面交互事件与状态管理。

<img src="https://pic4.zhimg.com/80/v2-6a8fe007fcf263214074f72ea3971b87_720w.jpg" alt="img" style="zoom:67%;" />

**渲染流程**：浏览器请求url --> 服务器返回index.html(空body、白屏) --> 再次请求bundle.js、路由分析 --> 浏览器渲染

bundle.js体积越大，会导致浏览器白屏时间越长。

### 四、SSR与CSR对比

CSR与SSR的区别简而言之，就是数据拼接HTML字符串这件事放在服务端还是客户端。

![img](https://pic2.zhimg.com/80/v2-e12ce3a06497fcffaa51d3a720b46649_720w.jpg)

### 优势

**1. 相比于纯静态网站**

纯静态的网站很难承载动态的内容，内容改动通常都是要直接修改页面的代码，这**对于内容管理人员（很可能是非技术人员）来说非常不友好**。

而 Jamstack 的网站，通常会使用无头 CMS 来将内容管理抽离出去，内容管理人员可以直接在这些 CMS 系统的 UI 界面上进行内容修改，然后触发整个网站的重新预渲染，以及部署。

**2. 相比于传统动态网站**

这里的“传统动态网站”指的是用 PHP、Ruby On Rails、JSP 甚至更古老的 CGI 构建的网站，以及基于这些技术产生的建站工具比如 WordPress、Drupal 等等。

这些传统网站的劣势在于，它们在运行时都需要一个实时在线的服务端，这些服务端负责处理请求、渲染页面，这就很大程度上降低了**服务的可伸缩性和稳定性**（想象一下，你迁移扩容一个在线的 WordPress 网站有多么麻烦）。

Jamstack 由于是直接使用 CDN 分发静态的页面，完全不需要渲染页面的服务，网站的伸缩性、稳定性可以得到最大的保障。

**3. 相比于单页应用（SPA）**

大概五年前，随着各种前端框架的成熟，越来越多的业务逻辑迁移到了前端处理，这也就诞生了 SPA 的概念，也就是整个网站的 UI 层，由浏览器端来完全接管。得益于 HTML5 和现代浏览器的一系列特性，这样的做法可以保证最好的用户体验。

但是 SPA 最大的问题在于它**对 SEO 不友好**，因为 SPA 的页面内容都是靠浏览器异步获取、渲染的，虽然 Google 为首的大多数搜索引擎渐渐地支持爬取 SPA 的内容，但是这依然是一个隐患。另外，由于 SPA 需要异步加载数据，首屏内容需要在在加载、运行 JS 之后才能看到，也给用户打开网站的体验带来影响。

而 Jamstack 的页面本质上都是托管在 CDN 上的静态页面，搜索引擎可以直接爬取这些静态内容，首屏与静态网站一样，可以直接展示内容，而不需要等到加载运行 JS 之后。

**4. 相比于 SSR 应用**

目前市面上的几大前端框架都支持了服务器端渲染，也就是 SSR 的概念，这些 SSR 技术也成为了 Jamstack 的基础之一。但是典型的 SSR 应用和传统动态网站一样，都是需要一个在线的服务来渲染页面，同样**会有运维和安全性上的风险**。

Jamstack 从技术角度上讲，可以认为是 SSR 技术的进阶，也就是提前用 SSR 预渲染大部分页面，然后将这些页面部署在 CDN 上，随后根据网站的数据变化，重复预渲染、部署即可。

当然，Jamstack 也不是万金油，不可能完美适应所有场景，Jamstack 最适合一些**内容更新不太频繁的网站**（比如新闻、电商、文档）。它不适合 Feeds 流、聊天室、论坛、个性化推荐这样高度动态化的网站，以及邮箱、编辑器这样偏重型的 Web 应用。





# 框架原理

## 虚拟DOM和diff算法

### 虚拟DOM

#### **背景**

前端主流框架 vue 和 react 中都使用了虚拟DOM（virtual DOM）技术，因为渲染真实DOM的开销是很大的，性能代价昂贵，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，而我们只需要更新修改过的那一小块dom而不要更新整个dom，这时使用diff算法能够帮助我们。

#### **DOM**

DOM全称`文档对象模型`，本质也是一个JS对象。每操作一次DOM都会对页面进行重新渲染，且新生成一颗DOM树。

DOM的本质： 浏览器中的概念，用js对象来表示页面上的元素，并提供操作DOM对象的API

浏览器渲染引擎工作流程都差不多，大致分为5步

**创建DOM树——创建StyleRules——创建Render树——布局Layout——绘制Painting**

-   第一步，用HTML分析器，分析HTML元素，**构建一颗DOM树**(标记化和树构建)。
-   第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。
-   第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。每个DOM节点都有**attach方法，接受样式信息**，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。
-   第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。
-   第五步，Render树和节点显示坐标都有了，就调用每个节点**paint方法，把它们绘制**出来。

**缺点**

- 修改了某个数据，会直接渲染到真实dom上引起整个dom树的重绘和重排
- 原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。

#### **VDOM**

虚拟dom(JS模拟DOM中的真实节点对象)， 通过VDom和真实DOM的比对，再通过特定的render方法将其渲染成真实的DOM节点。

- 只会更新对应的节点。**diff算法**
- 更新10个DOM节点，只会执行最后一次。**例如批处理**

 ![img](https://img2020.cnblogs.com/blog/1569466/202101/1569466-20210129140258056-1083022081.png)

### **diff算法**

现有一个真实的`DOM`，首先会映射为虚拟`DOM`，这个时候，我们删除了最后一个`p`节点和`son2`的节点，得到了新的一个虚拟`DOM`，新的`vdom`会和旧的`vdom`进行差异对比，得到了`pathes`对象，之后，对旧的真实`dom`进行操作，得到了新的`DOM`。

传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。

**diff策略**

三大策略 将O(n^3)复杂度 转化为 O(n)复杂度

- 策略一（tree diff）：新旧DOM树，逐层对比的方式。DOM节点跨层级的操作不做优化，因为很少这么做

  1.只会对相同层级的节点进行比较； 

  2.只有**删除、创建**操作，没有移动操作； 

  <img src="https://pic2.zhimg.com/80/d712a73769688afe1ef1a055391d99ed_1440w.png" alt="img" style="zoom: 50%;" />

  如图所示，react发现新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。过程就是删除、创建，直接粗暴。

  3.由于没做性能优化，所以**官方建议少做这样的跨层级操作**；

   ![img](https://images2018.cnblogs.com/blog/1455367/201808/1455367-20180808083547179-1944470540.jpg) 

  只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。

  当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

- 策略二（component diff）：

  如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。

  如果不是，那么直接删除旧的，创建新的；

  > tips： 对于同一个类的组件，用户可以控制其不要进行diff运算，具体就是，用户可以使用`shouldComponentUpdate()`来告诉react要不要对此组件进行diff运算。

  ![img](https://pic1.zhimg.com/80/52654992aba15fc90e2dac8b2387d0c4_1440w.png)

- 策略三（element diff）：

  当节点处于**同一层级**时，拥有同层唯一的key值，来做删除、插入、移动的操作，这是针对element层级的策略；

  - 插入：INSERT_MARKUP，新的组件类型不在旧集合中，即全新的节点，需要对新节点进行插入操作。
  - 删除：REMOVE_NODE，在新集合里也有，但对应的element不同则不能直接复用和更新，需要执行删除操作。或者旧组件不在新集合里的，也需要执行删除操作。
  - 移动：MOVE_EXISTING，旧集合中有新组件类型，且element是可更新的类型，这时候就需要做移动操作，可以复用以前的DOM节点。

### 源码

https://www.jianshu.com/p/af0b398602bc

https://juejin.cn/post/6984939221681176607

#### 创建vNode对象

```js
const h = (tag, data = {}, children) => {
  let text = ''
  let el
  let key
  // 文本节点
  if (typeof children === 'string' || typeof children === 'number') {
    text = children
    children = undefined
  } else if (!Array.isArray(children)) {
    children = undefined
  }
  if (data && data.key) {
    key = data.key
  }
  return {
    tag, // 元素标签
    children, // 子元素
    text, // 文本节点的文本
    el, // 真实dom
    key,
    data
  }
}
```

#### 处理函数

```js
//处理样式
const handleStyle = {
  updateClass: (el, newVNode) => {
    el.className = ''
    if (newVNode.data && newVNode.data.class) {
      let className = ''
      Object.keys(newVNode.data.class).forEach((cla) => {
        if (newVNode.data.class[cla]) {
          className += cla + ' '
        }
      })
      el.className = className
    }
  },
  updateStyle: (el, oldVNode, newVNode) => {
    let oldStyle = oldVNode && oldVNode.data && oldVNode.data.style || {}
    let newStyle = newVNode && newVNode.data && newVNode.data.style || {}
    // 移除旧节点里存在新节点里不存在的样式
    Object.keys(oldStyle).forEach((item) => {
      if (newStyle[item] === undefined || newStyle[item] === '') {
        el.style[item] = ''
      }
    })
    // 添加旧节点不存在的新样式
    Object.keys(newStyle).forEach((item) => {
      if (oldStyle[item] !== newStyle[item]) {
        el.style[item] = newStyle[item]
      }
    })
  },
  updateAttr: (el, oldVNode, newVNode) => {
    let oldAttr = oldVNode && oldVNode.data && oldVNode.data.attr ? oldVNode.data.attr : {}
    let newAttr = newVNode && newVNode.data && newVNode.data.attr || {}
    // 移除旧节点里存在新节点里不存在的属性
    Object.keys(oldAttr).forEach((item) => {
      if (newAttr[item] === undefined || newAttr[item] === '') {
        el.removeAttribute(item)
      }
    })
    // 添加旧节点不存在的新属性
    Object.keys(newAttr).forEach((item) => {
      if (oldAttr[item] !== newAttr[item]) {
        el.setAttribute(item, newAttr[item])
      }
    })
  }
}

//处理事件
const handleEvent = {
  removeEvent: (oldVNode) => {
    console.log();
    if (oldVNode && oldVNode.data && oldVNode.data.event) {
      Object.keys(oldVNode.data.event).forEach((item) => {
        oldVNode.el.removeEventListener(item, oldVNode.data.event[item])
      })
    }
  },
  updateEvent: (el, oldVNode, newVNode) => {
    let oldEvent = oldVNode && oldVNode.data && oldVNode.data.event ? oldVNode.data.event : {}
    let newEvent = newVNode && newVNode.data && newVNode.data.event || {}
    // 移除旧节点里存在新节点里不存在的事件
    Object.keys(oldEvent).forEach((item) => {
      if (newEvent[item] === undefined || oldEvent[item] !== newEvent[item]) {
        el.removeEventListener(item, oldEvent[item])
      }
    })
    // 添加旧节点不存在的新事件
    Object.keys(newEvent).forEach((item) => {
      if (oldEvent[item] !== newEvent[item]) {
        el.addEventListener(item, newEvent[item])
      }
    })
  }
}
```

#### 打补丁

**打补丁，针对同级的节点处理**

- 元素标签相同，进行patch
  - 新节点的子节点是文本节点,那么就直接替换
  - 新节点的子节点是标签节点（递推）
    - **新旧节点都存在子节点，那么就要进行diff**
    - 新节点存在子节点
    - 新节点不存在子节点，那么移除旧节点的所有子节点
    - 新节点啥也没有，旧节点存在文本节点
-  元素标签不同，使用newNode替换oldNode

```js
const patchVNode = (oldVNode, newVNode) => {
  if (oldVNode === newVNode) {
    return
  }
  // 元素标签相同，进行patch
  if (oldVNode.tag === newVNode.tag) {
    // 元素类型相同，那么旧元素肯定是进行复用的
    newVNode.el = oldVNode.el;
    let el = newVNode.el;
    console.log(oldVNode, newVNode);
    handleStyle.updateClass(el, newVNode)
    handleStyle.updateStyle(el, oldVNode, newVNode)
    handleStyle.updateAttr(el, oldVNode, newVNode)
    handleEvent.updateEvent(el, oldVNode, newVNode)
    // 新节点的子节点是文本节点,那么就直接替换
    if (newVNode.text) {
      // 移除旧节点的子节点
      if (oldVNode.children) {
        console.log(oldVNode.children);
        oldVNode.children.forEach((item) => {
          console.log(item);
          handleEvent.removeEvent(item)
          // el.removeChild(h(item).el)
        })
      }
      // 文本内容不相同则更新文本
      if (oldVNode.text !== newVNode.text) {
        el.textContent = newVNode.text
      }
    } else {
      // 新旧节点都存在子节点，那么就要进行diff
      if (oldVNode.children && newVNode.children) {
        diff(el, oldVNode.children, newVNode.children)
      } else if (newVNode.children) { // 新节点存在子节点
        // 旧节点存在文本节点则移除
        if (oldVNode.text) {
          el.textContent = ''
        }
        // 添加新节点的子节点
        newVNode.children.forEach((item, index) => {
          el.appendChild(createEl(newVNode.children[index]))
        })
      } else if (oldVNode.children) { // 新节点不存在子节点，那么移除旧节点的所有子节点
        oldVNode.children.forEach((item) => {
          handleEvent.removeEvent(item)
          el.removeChild(item.el)
        })
      } else if (oldVNode.text) { // 新节点啥也没有，旧节点存在文本节点
        el.textContent = ''
      }
    }
  } else { // 元素标签不同，使用newNode替换oldNode
    let newEl = createEl(newVNode)
    updateClass(newEl, newVNode)
    updateStyle(newEl, null, newVNode)
    updateAttr(newEl, null, newVNode)
    handleEvent.removeEvent(oldNode)
    updateEvent(newEl, null, newVNode)
    let parent = oldVNode.el.parentNode
    parent.insertBefore(newEl, oldVNode.el)
    parent.removeChild(oldVNode.el)
  }
}
```

#### 渲染dom

```js
//渲染dom
const createEl = (vnode) => {
  console.log(vnode);
  let el = document.createElement(vnode.tag)
  vnode.el = el;
  if (Array.isArray(vnode) && vnode.children && vnode.children.length > 0) {
    vnode.children.forEach((item) => {
      el.appendChild(createEl(item))
    })
  } else {//重点：初始化的时候需要给虚拟节点赋值text，children。下次比较新旧节点的时候才是正确的。这里需要优化
    vnode.text = vnode.children
    vnode.children = undefined
  }
  if (vnode.text) {
    el.appendChild(document.createTextNode(vnode.text))
  }
  console.log('createEl:vnode', vnode);
  return el
}
```

#### diff函数（只针对新旧节点的比较）

1、**节点类型变了**。直接将旧节点卸载并装载新节点。**旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做效率不高**。但为了避免O(n^3)的时间复杂度，这样是值得的。这也提醒了开发者，应该避免无谓的节点类型的变化，例如运行时将div变成p没有意义。

2、**节点类型一样，仅仅属性或属性值变了。**我们将这个过程称之为**PROPS**。此时不会触发节点卸载和装载，而是节点更新。

3、**文本变了**，文本对也是一个Text Node，也比较简单，直接修改文字内容就行了，我们将这个过程称之为**TEXT**。

4、移动／增加／删除 子节点，我们将这个过程称之为**REORDER**。



前三个以及在打补丁函数中执行了。后面节点的操作在下面执行

```js
//diff算法
const diff = (el, oldChildren, newChildren) => {
  console.log('diff');
  // 指针
  let oldStartIdx = 0
  let oldEndIdx = oldChildren.length - 1
  let newStartIdx = 0
  let newEndIdx = newChildren.length - 1
  // 节点
  let oldStartVNode = oldChildren[oldStartIdx]
  let oldEndVNode = oldChildren[oldEndIdx]
  let newStartVNode = newChildren[newStartIdx]
  let newEndVNode = newChildren[newEndIdx]
  //子节点个数都要大于1
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVNode === null) {
      oldStartVNode = oldChildren[++oldStartIdx]
    } else if (oldEndVNode === null) {
      oldEndVNode = oldChildren[--oldEndIdx]
    } else if (newStartVNode === null) {
      newStartVNode = oldChildren[++newStartIdx]
    } else if (newEndVNode === null) {
      newEndVNode = oldChildren[--newEndIdx]
    } else if (isSameNode(oldStartVNode, newStartVNode)) { // 头-头
      console.log('头-头', oldStartVNode, newStartVNode);
      // 更新指针
      oldStartVNode = oldChildren[++oldStartIdx]
      newStartVNode = newChildren[++newStartIdx]
    } else if (isSameNode(oldStartVNode, newEndVNode)) { // 头-尾
      console.log('头-尾');
      patchVNode(oldStartVNode, newEndVNode)
      // 把oldStartVNode节点移动到最后
      el.insertBefore(oldStartVNode.el, oldEndVNode.el.nextSibling)
      // 更新指针
      oldStartVNode = oldChildren[++oldStartIdx]
      newEndVNode = newChildren[--newEndIdx]
    } else if (isSameNode(oldEndVNode, newStartVNode)) { // 尾-头
      console.log('尾-头');

      patchVNode(oldEndVNode, newStartVNode)
      // 把oldEndVNode节点移动到oldStartVNode前
      el.insertBefore(oldEndVNode.el, oldStartVNode.el)
      // 更新指针
      oldEndVNode = oldChildren[--oldEndIdx]
      newStartVNode = newChildren[++newStartIdx]
    } else if (isSameNode(oldEndVNode, newEndVNode)) { // 尾-尾
      console.log('尾-尾');

      patchVNode(oldEndVNode, newEndVNode)
      // 更新指针
      oldEndVNode = oldChildren[--oldEndIdx]
      newEndVNode = newChildren[--newEndIdx]
    } else {
      console.log('insertBefore');
      let findIndex = findSameNode(oldChildren, newStartVNode)
      // newStartVNode在旧列表里不存在，那么是新节点，创建插入
      if (findIndex === -1) {
        el.insertBefore(createEl(newStartVNode), oldStartVNode.el)
      } else { // 在旧列表里存在，那么进行patch，并且移动到oldStartVNode前
        let oldVNode = oldChildren[findIndex]
        patchVNode(oldVNode, newStartVNode)
        el.insertBefore(oldVNode.el, oldStartVNode.el)
        oldChildren[findIndex] = null
      }
      newStartVNode = newChildren[++newStartIdx]
    }
  }
  // 旧列表里存在新列表里没有的节点，需要删除
  if (oldStartIdx <= oldEndIdx) {
    for (let i = oldStartIdx; i <= oldEndIdx; i++) {
      handleEvent.removeEvent(oldChildren[i])
      oldChildren[i] && el.removeChild(oldChildren[i].el)
    }
  } else if (newStartIdx <= newEndIdx) {
    let before = newChildren[newEndIdx + 1] ? newChildren[newEndIdx + 1].el : null
    for (let i = newStartIdx; i <= newEndIdx; i++) {
      el.insertBefore(createEl(newChildren[i]), before)
    }
  }
}
```



#### 入口方法以及调用

```js
//入口方法
const patch = (oldVNode, newVNode) => {
  // 初始化的时候，dom元素转换成vnode
  if (!oldVNode.tag) {
    let el = oldVNode
    el.innerHTML = ''
    oldVNode = h(oldVNode.tagName.toLowerCase())
    oldVNode.el = el
  }
  patchVNode(oldVNode, newVNode)
  return newVNode
}
```

```js
//调用
let preVNode = patch(
  document.getElementById("app"),
  h(
    "div",
    {
      class: {
        btn: true,
      },
      style: {
        fontSize: "30px",
      },
      attr: {
        id: "oldId",
      },
      event: {
        mouseover: () => {
          setTimeout(() => {
            let newVNode = h(
              "div",
              {
                class: {//类名改变
                  btn: true,
                  warning: false,
                  bg: true,
                },
                style: {//样式改变
                  fontWeight: "bold",
                  fontStyle: "italic",
                },
                attr: {
                  id: "newId",//id改变
                },
                event: {
                  click: () => {
                    alert("点了我");
                  },
                },
              },
              [//reorder 移动／增加／删除 子节点
                {
                  tag: 'h1',
                  children: '已经移入'//text 文本变了 此时不会触发节点卸载和装载，而是节点更新
                },
                {
                  tag: 'h3',//replace 节点类型变了 直接将旧节点卸载并装载新节点
                  children: 'item3'
                },
              ]
            );
            console.log('preVNode:', preVNode, 'newVNode:', newVNode);
            patch(preVNode, newVNode);
          }, 1000);
        },
      },
    },
    [
      {
        tag: 'h1',
        children: '移入我'
      },
      {
        tag: 'h2',
        children: 'item1'
      },
      {
        tag: 'h2',
        children: 'item2'
      }
    ]
  )
);
```

#### html引入

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .btn {
      border: 1px solid #000;
    }
    .warning {
      border: 1px solid lightcoral;
    }
    .bg {
      background-color: lightgoldenrodyellow;
    }
  </style>
</head>

<body>
  <div id="app"></div>
</body>
<script src="./newIndex.js"></script>
</html>
```



## **响应式**

**1. 脏值检查：** angular是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply()在 Angular 中组件是以树的形式组织起来的，相应地，检测器也是一棵树的形状。当一个异步事件发生时，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查，这种检查方式的性能存在很大问题。

**2.观察者-订阅者（数据劫持）：vue**Observer 数据监听器，把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty()方法把这些属性全部转成setter、getter方法。当data中的某个属性被访问时，则会调用getter方法，当data中的属性被改变时，则会调用setter方法。Compile指令解析器，它的作用对每个元素节点的指令进行解析，替换模板数据，并绑定对应的更新函数，初始化相应的订阅。Watcher 订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。执行流程如下：

![img](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1581589677,2197583542&fm=173&app=25&f=JPEG?w=640&h=342&s=5926347301CA614B4E65C0CA0000E0B3)

从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。因为VUE使用Object.defineProperty方法来做数据绑定，而这个方法又无法通过兼容性处理，所以Vue 不支持 IE8 以及更低版本浏览器。另外，查看vue原代码，发现在vue初始化实例时， 有一个proxy代理方法，它的作用就是遍历data中的属性，把它代理到vm的实例上，这也就是我们可以这样调用属性：vm.aaa等于vm.data.aaa。

### 源码

https://juejin.cn/post/6950826293923414047

https://juejin.cn/post/6844903597986037768

https://juejin.cn/post/6989106100582744072

什么是响应式？数据发生改变的时候，视图会重新渲染，匹配更新为最新的值。

我们可以问出下面三个问题

1、Vue 是怎么知道数据改变？**Object.defineProperty**

2、Vue 在数据改变时，怎么知道通知哪些视图更新？**dep**

3、Vue 在数据改变时，视图怎么知道什么时候更新？

![vue响应式](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/8/1617554b425a3431~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 背景

`vue.js` 则是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调

```js
const data = {};
const input = document.getElementById('input');
Object.defineProperty(data, 'text', {
  set(value) {
    input.value = value;
    this.value = value;
  }
});
input.onChange = function(e) {
  data.text = e.target.value;
}
```

#### Watcher

**Watcher是一个观察者对象（本质上是一个组件）**。

- 一个组件生成一个Watcher实例

- 依赖收集：执行addSub把Watcher实例保存在Dep实例的subs中
- 更新：数据变动的时候Dep执行notify通知Watcher实例，然后由Watcher实例回调update进行视图的更新

```js
const Watcher = function (vm, fn) {
    console.log(vm, fn);
    this.vm = vm;
    // 将当前Dep.target指向自己
    Dep.target = this;
    // 在 dep 中添加 watcher
    this.addDep = function (dep) {
      console.log("addDep-this", this); //Watcher实例
      dep.addSub(this);
    };

    // 更新方法，用于触发vm.$render
    this.update = function () {
      console.log(this, this, "update-this");
      console.log("in watcher update");
      fn.call(this.vm);
    };
    // 这里会首次调用vm._render，从而触发text的get
    // 从而将当前的Wathcer与Dep关联起来
    fn.call(this.vm);
    // 这里清空了Dep.target，为了防止notify触发时，不停的绑定Watcher与Dep，
    // 造成代码死循环
    Dep.target = null;
  };
```

#### **依赖收集**Dep

- 生成Dep实例（一个目标对象obj.key(即data)会生成一个Dep实例）
- getter读取响应式数据时，执行depend负责收集Watcher依赖
- setter设置响应式数据时，执行notify通知 dep 中那些 watcher 去执行 update 方法

```js
  const Dep = function () {
    this.target = null; // 收集目标
    this.subs = []; // dep收集器存储需要通知的Watcher
    this.addSub = function (watcher) {
      // 在 dep 中添加 watcher
      this.subs.push(watcher);
    };
    // 向 watcher 中添加 dep
    this.depend = function () {
      // 当有目标时，绑定Dep与Wathcer的关系
      if (Dep.target) {
        console.log("Dep.target", Dep.target);//
        Dep.target.addDep(this);
      }
    };
    this.notify = function () {
      // 通知收集器 dep 中的所有 watcher，执行 watcher.update() 方法
      for (let i = 0; i < this.subs.length; i += 1) {
        this.subs[i].update();
      }
    };
  };
```

#### Observer

Observer类是将每个目标对象（即data）的键值转换成getter/setter形式，用于进行依赖收集以及调度更新。

```js
const defineReactive = function (obj, key) {
    // 实例化 dep，一个 key 一个 dep
    const dep = new Dep();
    console.log("dep", dep, obj, key);
    // 获取当前值
    let val = obj[key];
    Object.defineProperty(obj, key, {
      // 设置当前描述属性为可被循环
      enumerable: true,
      // 设置当前描述属性可被修改
      configurable: true,
      get() {
        console.log("in get");
        // 调用依赖收集器中的addSub，用于收集当前属性与Watcher中的依赖关系
        dep.depend();
        return val;
      },
      set(newVal) {
        console.log("in set");
        if (newVal === val) {
          return;
        }
        val = newVal;
        // 当值发生变更时，通知依赖收集器，更新每个需要更新的Watcher，
        // 这里每个需要更新通过什么断定？dep.subs
        dep.notify();
      },
    });
  }; 
const Observer = function (data) {
    // 循环修改为每个属性添加get set
    for (let key in data) {
      defineReactive(data, key);
    }
  };

  const observe = function (data) {
    return new Observer(data);
  };
```

#### 代码

只针对了对象进行响应式

```html
<div id="app">
  <h3></h3>
</div>

<script>
  // 响应式的数据分为两类：
  // 对象，循环遍历对象的所有属性，为每个属性设置 getter、setter，以达到拦截访问和设置的目的，如果属性值依旧为对象，则递归为属性值上的每个 key 设置 getter、setter
  // 访问数据时（obj.key)进行依赖收集，在 dep 中存储相关的 watcher
  // 设置数据时由 dep 通知相关的 watcher 去更新
  // 数组，增强数组的那 7 个可以更改自身的原型方法，然后拦截对这些方法的操作
  // 添加新数据时进行响应式处理，然后由 dep 通知 watcher 去更新
  // 删除数据时，也要由 dep 通知 watcher 去更新

  /**
   * 一个 dep 对应一个 obj.key
   * 在读取响应式数据时，负责收集依赖，每个 dep（或者说 obj.key）依赖的 watcher 有哪些
   * 在响应式数据更新时，负责通知 dep 中那些 watcher 去执行 update 方法
   */
  const Dep = function () {
    this.target = null; // 收集目标
    this.subs = []; // dep收集器存储需要通知的Watcher
    this.addSub = function (watcher) {
      // 在 dep 中添加 watcher
      this.subs.push(watcher);
    };
    // 向 watcher 中添加 dep
    this.depend = function () {
      // 当有目标时，绑定Dep与Wathcer的关系
      if (Dep.target) {
        console.log("Dep.target", Dep.target);
        Dep.target.addDep(this);
      }
    };
    this.notify = function () {
      // 通知收集器 dep 中的所有 watcher，执行 watcher.update() 方法
      for (let i = 0; i < this.subs.length; i += 1) {
        this.subs[i].update();
      }
    };
  };
  /**
   * 拦截 obj[key] 的读取和设置操作：
   *   1、在第一次读取时收集依赖，比如执行 render 函数生成虚拟 DOM 时会有读取操作
   *   2、在更新时设置新值并通知依赖更新
   */
  const defineReactive = function (obj, key) {
    // 实例化 dep，一个 key 一个 dep
    const dep = new Dep();
    console.log("dep", dep, obj, key);
    // 获取当前值
    let val = obj[key];
    Object.defineProperty(obj, key, {
      // 设置当前描述属性为可被循环
      enumerable: true,
      // 设置当前描述属性可被修改
      configurable: true,
      get() {
        console.log("in get");
        // 调用依赖收集器中的addSub，用于收集当前属性与Watcher中的依赖关系
        dep.depend();
        return val;
      },
      set(newVal) {
        console.log("in set");
        if (newVal === val) {
          return;
        }
        val = newVal;
        // 当值发生变更时，通知依赖收集器，更新每个需要更新的Watcher，
        // 这里每个需要更新通过什么断定？dep.subs
        dep.notify();
      },
    });
  };

  const Observer = function (data) {
    // 循环修改为每个属性添加get set
    for (let key in data) {
      defineReactive(data, key);
    }
  };

  const observe = function (data) {
    return new Observer(data);
  };

  /**
   * 一个组件一个 watcher（渲染 watcher）或者一个表达式一个 watcher（用户watcher）
   * 当数据更新时 watcher 会被触发，访问 this.computedProperty 时也会触发 watcher
   */
  const Watcher = function (vm, fn) {
    console.log(vm, fn);
    this.vm = vm;
    // 将当前Dep.target指向自己
    Dep.target = this;
    // 在 dep 中添加 watcher
    this.addDep = function (dep) {
      console.log("addDep-this", this); //Watcher实例
      dep.addSub(this);
    };

    // 更新方法，用于触发vm.$render
    this.update = function () {
      console.log(this, this, "update-this");
      console.log("in watcher update");
      fn.call(this.vm);
    };
    // 这里会首次调用vm._render，从而触发text的get
    // 从而将当前的Wathcer与Dep关联起来
    fn.call(this.vm);
    // 这里清空了Dep.target，为了防止notify触发时，不停的绑定Watcher与Dep，
    // 造成代码死循环
    Dep.target = null;
  };

  const Vue = function (options) {
    // 将data赋值给this.$data，源码这部分用的Proxy所以我们用最简单的方式临时实现
    if (options && typeof options.data === "function") {
      this.$data = options.data.apply(this);
    }
    // 监听this.$data
    observe(this.$data);
  };

  // 挂载函数
  Vue.prototype.$mount = function () {
    const self = this;
    new Watcher(self, self.$render);
    // new Watcher(self, self.$render);
  };

  // 渲染函数
  Vue.prototype.$render = function () {
    //渲染视图
    //vue2渲染函数返回的是虚拟dom,这里暂时返回真实的dom
    console.log(this);
    const h3 = document.getElementsByTagName("h3")[0];
    h3.innerText = this.$data.text + `${this.$data.text1}`;
    return h3;
  };

  const myApp = new Vue({
    data() {
      return {
        text: "hello world",
        text1: "123",
      };
    },
    mounted() {
      setTimeout(() => {
        this.$data.text = "这是新的标题";
      }, 1000);
    },
  });

  myApp.$mount("app");
  // myApp.$data.text = "123"; // in watcher update /n in get
</script>

```

#### Object.defineProperty

**Object.defineProperty**可以为对象中的每一个属性，设置 get 和 set 方法

get 值是一个函数，当属性被访问时，会触发 get 函数

set 值同样是一个函数，当属性被赋值时，会触发 set 函数

```js
var obj = {
  name: ""
}
Object.defineProperty(obj, "name", {
  get() {
    console.log("get 被触发")
    return '神仙'
  },
  set(val) {
    console.log("set 被触发")
    return val;
  }
})
console.log(obj.name);

当我访问 obj.name 时，会打印 ' get 被触发 '
当我为 obj.name 赋值时，obj.name = 5，会打印 ' set 被触发 '
```



## tree-shaking

https://blog.csdn.net/qq_41887214/article/details/121922348

# vue

## this直接获取data和methods

https://mp.weixin.qq.com/s/Uq-LYSrmn1lOjRuAl4jc2A

```js
const vm = new Vue({
  data: {
      name: '我是pino',
  },
  methods: {
      print(){
          console.log(this.name);
      }
  },
});
console.log(vm.name); // 我是pino
vm.print(); // 我是pino
```

但是我们自己实现一个构造函数却实现不了这种效果呢？

```js
function Super(options){}

const p = new Super({
    data: {
        name: 'pino'
    },
    methods: {
        print(){
            console.log(this.name);
        }
    }
});

console.log(p.name); // undefined
p.print(); // p.print is not a function
```

**总结**

通过`this`直接访问到`methods`里面的函数的原因是：因为`methods`里的方法通过 `bind` 指定了`this`为 `new Vue`的实例(`vm`)

通过 `this` 直接访问到 `data` 里面的数据的原因是：data里的属性最终会存储到`new Vue`的实例（`vm`）上的 `_data`对象中，访问 `this.xxx`，是访问`Object.defineProperty`代理后的 `this._data.xxx`。

# react

## fiber

https://m.php.cn/article/490176.html

**fiber就是链表结构的虚拟Dom**

Fiber是React新的调度算法，是对核心算法的一次重新实现。React Fiber把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果有紧急任务，就去做紧急任务。

react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，使得react在动画、手势等应用中效果比较差。

为了解决这个问题，react团队经过两年的工作，重写了react中核心算法——reconciliation。并在v16版本中发布了这个新的特性。为了区别之前和之后的reconciler，通常将之前的reconciler称为stack reconciler，重写后的称为fiber reconciler，简称为Fiber。

![1.gif](https://img.php.cn/upload/image/897/958/792/1647925041816601.gif)

![2.gif](https://img.php.cn/upload/image/773/873/534/1647925045329977.gif)

**卡顿原因**

Stack reconciler的工作流程很像函数的调用过程。父组件里调子组件，可以类比为函数的递归（这也是为什么被称为stack reconciler的原因）。在setState后，react会立即开始reconciliation过程，从父节点（Virtual DOM）开始遍历，以找出不同。将所有的Virtual DOM遍历完成后，reconciler才能给出当前需要修改真实DOM的信息，并传递给renderer，进行渲染，然后屏幕上才会显示此次更新内容。对于特别庞大的vDOM树来说，reconciliation过程会很长(x00ms)，在这期间，主线程是被js占用的，因此任何交互、布局、渲染都会停止，给用户的感觉就是页面被卡住了。

**Scheduler**

scheduling(调度)是fiber reconciliation的一个过程，主要决定应该在何时做什么。?的过程表明在stack reconciler中，reconciliation是“一气呵成”，对于函数来说，这没什么问题，因为我们只想要函数的运行结果，但对于UI来说还需要考虑以下问题：

- 并不是所有的state更新都需要立即显示出来，比如屏幕之外的部分的更新
- 并不是所有的更新优先级都是一样的，比如用户输入的响应优先级要比通过请求填充内容的响应优先级更高
- 理想情况下，对于某些高优先级的操作，应该是可以打断低优先级的操作执行的，比如用户输入时，页面的某个评论还在reconciliation，应该优先响应用户输入

所以理想状况下reconciliation的过程应该是，每次只做一个很小的任务，做完后能够“喘口气儿”，回到主线程看下有没有什么更高优先级的任务需要处理，如果又则先处理更高优先级的任务，没有则继续执行([cooperative scheduling 合作式调度](https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2FTR%2Frequestidlecallback%2F))。

# 路由

https://mp.weixin.qq.com/s/2o7VvwyPISMQ7k0IBNoXmg

https://zhuanlan.zhihu.com/p/37730038

**路由就是 URL 到函数的映射**，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。

要实现前端路由，需要解决两个核心：

如何改变 URL 却不引起页面刷新？
如何检测 URL 变化了？

下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。

## **hash 实现**

hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新
通过 hashchange 事件监听 URL 的变化。
改变 URL 的方式只有这几种：

- 通过浏览器前进后退改变 URL

- 通过a标签改变 URL、

- 通过window.location改变URL

这几种情况改变 URL 都会触发 hashchange 事件

```js
 <ul>
   <!-- 定义路由 -->
   <li><a href="#/home">home</a></li>
   <li><a href="#/about">about</a></li>

   <!-- 渲染路由对应的 UI -->
   <div id="routeView"></div>
 </ul>


<script>
   // 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件
   window.addEventListener('DOMContentLoaded', onLoad)
   // 监听路由变化
   window.addEventListener('hashchange', onHashChange)
   
   // 路由视图
   var routerView = null
   
   function onLoad () {
     routerView = document.querySelector('#routeView')
     onHashChange()
   }
   
   // 路由变化时，根据路由渲染对应 UI
   function onHashChange () {
     switch (location.hash) {
       case '#/home':
         routerView.innerHTML = 'Home'
         return
       case '#/about':
         routerView.innerHTML = 'About'
         return
       default:
         return
     }
   }
</script> 
```



## **history 实现**

history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新。
history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：

- 通过浏览器前进后退改变 URL 时会触发 popstate 事件（或者在 JavaScript 中调用`history.back()`、`history.forward()`、`history.go()`方法）

- 通过pushState/replaceState或a标签改变 URL 不会触发 popstate 事件。

好在我们可以拦截 pushState/replaceState的调用和a标签的点击事件来检测 URL 变化。

```
<script>
   // 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件
   window.addEventListener('DOMContentLoaded', onLoad);
   // 监听路由变化
   window.addEventListener('popstate', onPopState);
   
   // 路由视图
   var routerView = null;
   
   function onLoad() {
       routerView = document.querySelector('.vanilla.history .container');
       onPopState();
   
       // 拦截 <a> 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。
       var linkList = document.querySelectorAll('.vanilla.history a[href]');
       linkList.forEach(el =>
           el.addEventListener('click', function(e) {
               e.preventDefault();
               history.pushState(null, '', el.getAttribute('href'));
               onPopState();
           })
       );
   }
   
   // 路由变化时，根据路由渲染对应 UI
   function onPopState() {
       switch (location.pathname) {
           case '/home':
               routerView.innerHTML = '<h2>Home</h2>';
               return;
           case '/about':
               routerView.innerHTML = '<h2>About</h2>';
               return;
           default:
               return;
       }
   }
</script> 
```

## router 和 route 的区别

route 就是一条路由，它将一个 URL 路径和一个函数进行映射。而 router 可以理解为一个容器，或者说一种机制，它管理了一组 route。

概括为：route 只是进行了 URL 和函数的映射，在当接收到一个 URL 后，需要去路由映射表中查找相应的函数（组件函数），这个过程是由 router 来处理的。

## 实现

### vue/react路由

- 以 Vue为例，需要有 `<router-link>`链接、`<router-view>`容器、`component`组件和`path`路由路径：

```
<div id="app">
    <h1>Hello World</h1>
    <p>
        <!-- 使用 router-link 组件进行导航 -->
        <!-- 通过传递 to 来指定链接 -->
        <!-- <router-link> 将呈现一个带有正确 href属性的<a>标签 -->
        <router-link to="/">Go to Home</router-link>
        <router-link to="/about">Go to About</router-link>
    </p>
    <!-- 路由出口 -->
    <!-- 路由匹配到的组件将渲染在这里 -->
    <router-view></router-view>
</div>
复制代码
const routes = [{
    path: '/',
    component: Home
},
{
    path: '/about',
    component: About
}]
复制代码
```

- 以React为例，需要有`<BrowserRouter>`容器、`<Route>`路由、组件和链接：

```
<BrowserRouter>
    <Routes>
        <Route path="/" element={<App />}>
            <Route index element={<Home />} />
            <Route path="teams" element={<Teams />}>
                <Route path=":teamId" element={<Team />} />
                <Route path="new" element={<NewTeamForm />} />
                <Route index element={<LeagueStandings />} />
            </Route>
        </Route>
    </Routes>
</BrowserRouter>
复制代码
<div>
    <h1>Home</h1>
    <nav>
        <Link to="/">Home</Link> | {""}
        <Link to="about">About</Link>
    </nav>
</div>
复制代码
```

综上，一个简单的 Router 应该具备以下功能：

- 容器（组件）

- 路由
- 业务组件（router-view） & 链接组件（router-link）

### 技术背景

https://www.ruanyifeng.com/blog/2019/08/web_components.html

1. 使用`CustomElementRegistry.define()`注册自定义元素

   ```
   <my-text></my-text>
   
   <script>
       class MyText extends HTMLElement{
           constructor(){
               super();
               this.append(“我的文本”);
           }
       }
       window.customElements.define("my-text",MyText);
   </script>
   复制代码
   ```

2. Web Components 的生命周期：

   **connectedCallback**：当 custom element 首次被插入文档DOM时，被调用

   **disconnectedCallback**：当 custom element 从文档DOM中删除时，被调用

   **adoptedCallback**：当custom element 被移动到新的文档时，被调用

   **attributeChangedCallback**：当 custom element 增加、删除、修改自身属性时，被调用


### 组件

![图片](https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq2mFYEc2kKuKic6OraWTibeRrLP7HiasHoz5fbSc2uD16SIxhSkkZiaYaLpZeoJJ9YKuCrjg6FvSf9gQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1)

#### 链接组件

链接组件 — CustomLink(c-link)

当用户点击`<c-link>`标签后，通过`event.preventDefault();`阻止页面默认跳转。根据当前标签的`to`属性获取路由，通过`history.pushState("","",to)`进行路由切换。

```
//  <c-link to="/" class="c-link">首页</c-link>
class CustomLink extends HTMLElement {
    connectedCallback() {
        this.addEventListener("click", ev => {
            ev.preventDefault();
            const to = this.getAttribute("to");
            // 更新浏览器历史记录
            history.pushState("", "", to)
        })

    }
}
window.customElements.define("c-link", CustomLink);
复制代码
```

#### 容器组件

容器组件 — CustomRouter(c-router)

主要是收集路由信息，监听路由信息的变化，然后加载对应的组件

#### 路由组件

路由 — CustomRoute(c-route)

```
// 优先于c-router注册
//  <c-route path="/" component="home" default></c-route>
class CustomRoute extends HTMLElement {
    #data = null;
    getData() {
        return {
            default: this.hasAttribute("default"),
            path: this.getAttribute("path"),
            component: this.getAttribute("component")
        }
    }
}
window.customElements.define("c-route", CustomRoute);
```



## install分析

1. 首先会对重复安装进行过滤

2. 全局混入beforeCreate和destroyed 生命钩子，为每个Vue实例设置 _routerRoot属性，并为跟实例设置_router属性

3. 调用Vue中定义的defineReactive对_route进行劫持，其实是执行的依赖收集的过程，执行_route的get就会对当前的组件进行依赖收集，如果对_route进行重新赋值触发setter就会使收集的组件重新渲染，这里也是路由重新渲染的核心所在

   ```
   Vue.mixin({
       beforeCreate () {
         if (isDef(this.$options.router)) { // 设置根路由-根组件实例
           this._routerRoot = this
           this._router = this.$options.router
           this._router.init(this)
           // 定义响应式的 _route 对象
           Vue.util.defineReactive(this, '_route', this._router.history.current)
         } else { // 非根组件设置
           this._routerRoot = (this.$parent && this.$parent._routerRoot) || this
         }
         registerInstance(this, this)
       },
       destroyed () {
         registerInstance(this)
       }
     })
   ```

4. 为Vue原型对象定义router和router和router和route属性，并对两个属性进行了劫持，使我们可以直接通过Vue对象实例访问到

   ```
    Object.defineProperty(Vue.prototype, '$router', {
       get () { return this._routerRoot._router }
     })
   
     Object.defineProperty(Vue.prototype, '$route', {
       get () { return this._routerRoot._route }
     })
   ```

5. 全局注册了Routerview和RouterLink两个组件，所以我们才可以在任何地方使用这两个组件，这两个组件的内容我们稍后分析

## 刷新

浏览器刷新vue为什么不会走beforeDestroy和destroyed生命周期
业务场景:
需要在页面卸载的时候去处理一些数据,比如清空 localStorage
然后就会把一些业务逻辑写在beforeDestroy或者destroyed的生命周期里

浏览器刷新的时候会走这两个生命周期吗
答案是不会
不是说在组件卸载的时候会走这两个生命周期么,为什么不会走呢?

浏览器刷新是做了些什么
浏览器的刷新其实相当于重新访问这个ip地址,包括html和js,css文件都会重新获取(这里会涉及到文件缓存的问题,但与vue的生命周期没有关系)
浏览器不在乎你之前的页面是什么,相当于把你之前的页面给关了再打开(直接拉闸再接电)

这种情况怎么处理
可以在页面加载的时候添加一个监听事件去监听浏览器刷新,关闭,这样就可以在浏览器刷新或者关闭的时候也能处理对应的业务逻辑

---
slug: 常识
title: 常识
description: 关于浏览器，网络，安全优化，以及面试考点
keywords: html css es5 jq
category: 常识
tags: [浏览器,网络,安全优化,面试]
author: liming
date: 25-September-2020
sticky: 2
swiper_index: 2
swiper_desc: 关于浏览器，网络，安全优化，以及面试考点
cover: https://i0.hippopx.com/photos/457/88/1021/microphone-boy-studio-screaming-preview.jpg
---

# 浏览器

## 渲染引擎  

浏览器内核：浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。

- `Trident`内核：`IE,MaxThon,TT,The World,360`,搜狗浏览器等。
- `Gecko`内核：`Netscape6`及以 上版本，`FF,MozillaSuite/SeaMonkey`等
- `Presto`内核：`Opera7`及以上。 [`Opera`内核原为：Presto，现为：`Blink`;]
- `Webkit`内核：`Safari,Chrome`等。 [ `Chrome`的`Blink`（`WebKit`的分支）]

## 浏览器渲染机制

https://mp.weixin.qq.com/s/fUduX-AA618rsE3HHWySgA

### 线程和进程

进程和线程的概念可以这样理解：

> 进程是一个工厂，工厂有它的独立资源--工厂之间相互独立--线程是工厂中的工人，多个工人协作完成任务--工厂内有一个或多个工人--工人之间共享空间

工厂有多个工人，就相当于一个进程可以有多个线程，而且线程共享进程的空间。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KzcDnDRlicWl0V3fV9Qtzg8n4segZjiaiaCqr982pXRSEIGOq7ics1CRm4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

进程是`cpu`资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存） 线程是`cpu`调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）

#### 浏览器是多进程的

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KDibJqU6bBoWCNcT6QS22cFxOygakR1519HdRzOp2iagK5ibfJQWm2e4xA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 67%;" />

浏览器是多进程的，每打开一个`tab`页，就相当于创建了一个独立的浏览器进程。

#### 浏览器包含的进程

1. `Browser`进程：浏览器的主进程（负责协调，主控），只有一个，作用有：

2. - 负责浏览器的界面显示，与用户交互，如前进，后退等
   - 负责各个页面的管理，创建和销毁其它进程
   - 将`Rendered`进程得到的内存中的`Bitmap`,绘制到用户界面上
   - 网络资源的管理，下载

3. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。

4. `GPU`进程：最多一个，用于`3D`绘制等。

5. 浏览器渲染进程（浏览器内核）（`Render`进程，内部是多线程的）：默认每个`Tab`页面一个进程，互不影响。主要作用为：页面渲染，脚本执行，事件处理等


在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）

#### 浏览器多进程的优势

- 避免单个`page crash`影响整个浏览器
- 避免第三方插件`crash`影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

简单理解就是：如果浏览器是单进程的，某个`Tab`页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器; 当然，内存等资源消耗也会更大，像空间换时间一样。

### 浏览器内核(渲染进程)

对于普通的前端操作来说，最重要的**渲染进程**：页面的渲染，`js`的执行，事件的循环等都在这个进程内执行

**浏览器是多进程的，浏览器的渲染进程是多线程的；**

渲染进程如下：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KO3Pmiabeq4UPvMSR2fM00YkQAicSmHoXtezy928XErvNLpFlBwcVXic0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### `GUI`渲染线程

- 负责渲染浏览器界面，解析`HTML`,`CSS`,构建`DOM`树和`RenderObject`树，布局和绘制等。
- 当界面需要重绘或由于某种操作引发回流时，该线程就会执行。
- 注意，**`GUI`渲染线程与`JS`引擎线程是互斥的**，当`JS`引擎执行时`GUI`线程会被挂起（相当于冻结了）,`GUI`更新会被保存在一个队列中等到`JS`引擎空闲时立即被执行。

#### `JS`引擎线程

- 也称为`JS`内核，负责处理`JavaScript`脚本程序。（例如`V8`引擎）。
- `JS`引擎线程负责解析`JavaScript`脚本，运行代码。
- `JS`引擎一直等待着任务队列中任务的到来，然后加以处理，一个`Tab`页（`render`进程）中无论什么时候都只有一个`JS`线程在运行`JS`程序。
- 同样注意，**GUI渲染线程与JS引擎线程是互斥的**，所以如果`JS`执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
- javascript是单线程的， 假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点。所以javascript是单线程的。

#### 事件触发线程

- 归属于浏览器而不是`JS`引擎，用来控制事件循环（可以理解成`JS`引擎自己都忙不过来，需要浏览器另开线程协助）。
- 当`JS`引擎执行代码块如`setTimeout`时（也可来自浏览器内核的其它线程，如鼠标点击，`AJAX`异步请求等），会将对应任务添加到事件线程中。
- 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待`JS`引擎的处理。
- 注意，由于`JS`的单线程关系，所以这些待处理队列中的事件都得排队等待`JS`引擎处理（当`JS`引擎空闲时才会去执行）。

#### 定时触发器线程

- 传说中的`setTimeout`和`setInterval`所在的线程
- 浏览器定时计数器并不是由`JavaScript`引擎计数的，（因为`JavaScript`引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确）
- 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待`JS`引擎空闲后执行）
- 注意，`W3C`在`HTML`标准中规定，规定要求`setTimeout`中低于`4ms`的时间间隔算为`4ms`。

#### 异步`http`请求线程

- 在`XMLHttpRequest`在连接后是通过浏览器新型一个线程请求
- 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由`JavaScript`引擎执行



### Browser主进程和浏览器内核（渲染进程）的通信过程

打开一个浏览器，可以看到：任务管理器出现了2个进程（一个主进程，一个是打开`Tab`页的渲染进程）

- `Browser`主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过`RendererHost`接口传递给`Render`渲染进程
- `Render`渲染进程的`Renderer`接口收到消息，简单解释后，交给渲染线程`GUI`，然后开始渲染
- `GUI`渲染线程接收请求，加载网页并渲染网页，这其中可能需要`Browser`主进程获取资源和需要`GPU`进程来帮助渲染
- 当然可能会有`JS`线程操作`DOM`（这可能会造成回流并重绘）
- 最后`Render`渲染进程将结果传递给`Browser`主进程
- `Browser`主进程接收到结果并将结果绘制出来

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KHgay7bNfvibNicDvJGvOhbupYVh19Vgbbm37TxbgqxYgMtEJwdIibolsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 衍生

#### 普通图层和复合图层

1. 普通文档流内可以理解为一个复合图层（这里默认复合层，里面不管添加多少元素，其实都是在同个复合图层中）
2. `absolute`布局（`fixed`也一样），虽然可以脱离文档流，但它仍然属于默认复合层
3. 可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）

可以简单理解下：`GPU`中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒

**如何变成复合图层（硬件加速）**

将元素变成一个复合图层，就是传说中的硬件加速技术

- 最常用的方式：`translate3d`,`translatez`

- `opacity`属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）

- `will-chang`属性（这个比较偏僻），一般配合`opacity`与`translate`使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）

- ```
  <video><iframe><canvas><webgl>等元素
  ```

- 其它，譬如以前的`flash`插件

**复合图层的作用**

一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。

#### JS的多线程WebWorker

`JS`引擎是单线程的，而且`JS`执行时间过长会阻塞页面，那么`JS`就真的对`cpu`密集型计算无能为力么？

所以，后来`HTML5`中支持了`WebWorker`。

这样理解下：

创建`Worker`时，`JS`引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作`DOM`）`JS`引擎线程与`worker`线程间通过特定的方式通信（`postMessage API`，需要通过序列化对象来与线程交互特定的数据）

所以，如果有非常耗时的工作，请单独开一个`Worker`线程，这样里面不管如何翻天覆地都不会影响`JS`引擎主线程，只待计算出结果后，将结果通信给主线程即可。

而且注意下，`JS`引擎是单线程的，这一点的本质仍然未改变，`Worker`可以理解是浏览器给`JS`引擎开的外挂，专门用来解决那些大量计算问题。

**`WebWorker`与`SharedWorker`**

既然都到了这里，就再提一下`SharedWorker`（避免后续将这两个概念搞混）

`WebWorker`只属于某个页面，不会和其他页面的`Render`进程（浏览器内核进程）共享 所以`Chrome`在`Render`进程中（每一个`Tab`页就是一个`render`进程）创建一个新的线程来运行`Worker`中的`JavaScript`程序。

`SharedWorker`是浏览器所有页面共享的，不能采用与`Worker`同样的方式实现，因为它不隶属于某个`Render`进程，可以为多个`Render`进程共享使用 所以`Chrome`浏览器为`SharedWorker`单独创建一个进程来运行`JavaScript`程序，在浏览器中每个相同的`JavaScript`只存在一个`SharedWorker`进程，不管它被创建多少次。

看到这里，应该就很容易明白了，本质上就是进程和线程的区别。`SharedWorker`由独立的进程管理，`WebWorker`只是属于`render`进程下的一个线程

#### microtask与macrotask

MacroTask（宏任务）

- `script`全部代码、`setTimeout`、`setInterval`、`setImmediate`（浏览器暂时不支持，只有IE10支持，具体可见`MDN`）、`I/O`、`UI Rendering`。

MicroTask（微任务）

- `Process.nextTick（Node独有）`、`Promise`、`Object.observe(废弃)`、`MutationObserver`

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3K0kUDZVKgibMd3rBeeBeGfGlRicQfffWIia7lWPAWXIEtkzLQB5vpl9iaFw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

#### 从`Event Loop`谈`JS`的运行机制

`Event Loop`即事件循环，是指浏览器或`Node`的一种解决`javaScript`单线程运行时不会阻塞的一种机制，也就是我们经常使用**异步**的原理。

javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。

单线程是必要的，也是javascript这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的dom操作。试想一下 如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。

- `JS`分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件
- 一旦执行栈中的所有同步任务执行完毕（此时`JS`引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈，开始执行。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3K4aULQ2mmxexCFrU6kicG7ly2995IniaAm21CVBnBSLA9qmntNE27kPhQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KxYCZN7mibAPNZlibpHtZdMC19NoicE9OViakek1iafSviciaYQD6rI3GiaicVOg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />



## JS 代码是怎样运行起来的

https://mp.weixin.qq.com/s/UGf-VgcZ0jAD5SXIlHO9-Q

### V8 引擎

在介绍 V8 引擎的概念之前，我们先来回顾一下编程语言。**编程语言可以分为机器语言、汇编语言、高级语言。**

- 机器语言：由 0 和 1 组成的二进制码，对于人类来说是很难记忆的，还要考虑不同 CPU 平台的兼容性。

- 汇编语言：用更容易记忆的英文缩写标识符代替二进制指令，但还是需要开发人员有足够的硬件知识。

- 高级语言：更简单抽象且不需要考虑硬件，但是需要更复杂、耗时更久的翻译过程才能被执行。

  ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0sXFMfsjvzic9vOarl9rHq8jWYtJBw47F3yrUqcasQcqjMENoSDYpCJw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

高级语言一定要转化为机器语言才能被计算机执行，而且越高级的语言转化的时间越久。**高级语言又可以分为解释型语言、编译型语言。**

- 编译型语言：需要编译器进行一次编译，被编译过的文件可以多次执行。如 C++、C 语言。

- 解释型语言：不需要事先编译，通过解释器一边解释一边执行。启动快，但执行慢。

```
我们知道 JavaScript 是一门高级语言，并且是动态类型语言，我们在定义一个变量时不需要关心它的类型，并且可以随意的修改变量的类型。而在像 C++这样的静态类型语言中，我们必须提前声明变量的类型并且赋予正确的值才行。也正是因为 JavaScript 没有像 C++那样可以事先提供足够的信息供编译器编译出更加低级的机器代码，它只能在运行阶段收集类型信息，然后根据这些信息进行编译再执行，所以 JavaScript 也是解释型语言。
```

这也就意味着 JavaScript 要想被计算机执行，需要一个能够快速解析并且执行 JavaScript 脚本的程序，这个程序就是我们平时所说的 JavaScript 引擎。这里我们给出 V8 引擎的概念:**V8 是 Google 基于 C++ 编写的开源高性能 Javascript 与 WebAssembly 引擎。用于 Google Chrome（Google 的开源浏览器） 以及 Node.js 等。**

### CPU 是如何执行机器指令的？

将高级语言转化为机器语言之后，CPU 又是怎样执行的呢？我们以一段 C 代码为例：

```c
int main()

{
    int x = 1;

    int y = 2;

    int z = x + y;

    return z;

}}
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0x7A7PvzwweIap7bYulfTot4icLibCwQ2ICnwB5icTyeia1Eibic85oWjndfw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**CPU 执行机器指令的流程**

- 首先程序在执行之前会被装进内存。

- 系统会将二进制代码中的第一条指令的地址写入到 PC 寄存器中。

![图片](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0xQbLlrWaKxm7ttRQP39rbKjxJUILrbJA4g6yA292QxMbrko5viaKZ3g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- CPU 根据 PC 寄存器中的地址，从内存中取出指令。

- 将下一条指令的地址更新到 PC 寄存器中。
- 分析当前取出指令，并识别出不同的类型的指令，以及各种获取操作数的方法。
- 加载指令：从内存中复制指定长度的内容到通用寄存器中，并覆盖寄存器中原来的内容。
- 存储指令：将寄存器中的内容复制到内存某个位置，并覆盖掉内存中的这个位置上原来的内容。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0EgzgickcldFO9KFr7D2qaYeWBfyjEwbVYKf24Splib3EcFOa4y4tv0Lw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

上图中 movl 指令后面的 %ecx 就是寄存器地址，-8(%rbp) 是内存中的地址，这条指令的作用是将寄存器中的值拷贝到内存中。

- 更新指令：复制两个寄存器中的内容到 ALU 中，也可以是一块寄存器和一块内存中的内容到 ALU 中，ALU 将两个字相加，并将结果存放在其中的一个寄存器中，并覆盖该寄存器中的内容。

...

- 执行指令完毕，进入下一个 CPU 时钟周期。

### V8 引擎的编译流水线

接下来我们先从宏观的角度来看一下 V8 是怎么执行 JavaScript 代码的，然后再对每一步进行分析。

- 初始化基础环境；

- 解析源码生成 AST 和作用域；

- 依据 AST 和作用域生成字节码；

- 解释执行字节码；监听热点代码；

  ![图片](https://mmbiz.qpic.cn/mmbiz_jpg/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0FEIGZwRe79nNsAnx7YNAupDEj7NdT0rWGmhk9CEtIfMMO5nmcNJDiag/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

# 渲染/优化

## 重绘和重排

**重绘（repaint或redraw）**：当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。

触发重绘的条件：改变元素外观属性。如：color，background-color等。

**重排（重构/回流/reflow）**：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建, 这就称为回流(**reflow**)。每个页面至少需要一次回流，就是在页面第一次加载的时候。

重绘和重排的关系：在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘。

**重排必定会引发重绘，但重绘不一定会引发重排。**

## 浏览器渲染流程

**基础版本**

- 浏览器根据请求的`URL`交给`DNS`域名解析，找到真实`IP`，向服务器发起请求；

- 服务器交给后台处理完成后返回数据，浏览器接收文件（`HTML、JS、CSS`、图象等）；

- 浏览器对加载到的资源（`HTML、JS、CSS`等）进行语法解析，建立相应的内部数据结构（如`HTML`的`DOM`）

  - 解析`html`建立`dom`树

  - 解析`css`构建`render`树（将`css`代码解析成树形的数据结构，然后结合`dom`合并成`render`树）

  - 布局`render`树（`Layout/reflow`）,负责各元素尺寸，位置的计算

  - 绘制`render`树（`paint`），绘制页面像素信息

  - 浏览器会将各层的信息发送给`GPU`，`GPU`会将各层合成（`composite`）,显示在屏幕上

    渲染完毕后就是`load`事件了，之后就是自己的`JS`逻辑处理

    - composite：普通图层和复合图层
      - 普通文档流内可以理解为一个复合图层
      - `absolute`布局（`fixed`也一样），虽然可以脱离文档流，但它仍然属于默认复合层

**详细版**

1. 在浏览器地址栏输入URL

2. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤

   1. 如果资源未缓存，发起新请求

   2. 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。

   3. 检验新鲜通常有两个HTTP头进行控制

      Expires和Cache-Control：

      - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
      - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间

3. 浏览器**解析URL**获取协议，主机，端口，path

4. 浏览器获取主机ip地址，过程如下：

   1. 浏览器缓存
   2. 本机缓存
   3. hosts文件
   4. 路由器缓存
   5. ISP DNS缓存
   6. DNS递归查询（可能存在负载均衡导致每次IP不一样）

5. 浏览器**组装一个HTTP（GET）请求报文**

6. 打开一个socket与目标IP地址，端口建立TCP链接

   三次握手如下：

   1. 客户端发送一个TCP的**SYN=1，Seq=X**的包到服务器端口
   2. 服务器发回**SYN=1， ACK=X+1， Seq=Y**的响应包
   3. 客户端发送**ACK=Y+1， Seq=Z**

7. TCP链接建立后**发送HTTP请求**

8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序

9. 服务器检查**HTTP请求头是否包含缓存验证信息**如果验证缓存新鲜，返回**304**等对应状态码

10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作

11. 服务器将**响应报文通过TCP连接发送回浏览器**

12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下

    1. 主动方发送**Fin=1， Ack=Z， Seq= X**报文
    2. 被动方发送**ACK=X+1， Seq=Z**报文
    3. 被动方发送**Fin=1， ACK=X， Seq=Y**报文
    4. 主动方发送**ACK=Y， Seq=X**报文

13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同

14. 如果资源可缓存，**进行缓存**

15. 对响应进行**解码**（例如gzip压缩）

16. 根据资源类型决定如何处理（假设资源为HTML文档）

17. **解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本**，这些操作没有严格的先后顺序，以下分别解释

18. 构建DOM树：

    1. **Tokenizing**：根据HTML规范将字符流解析为标记
    2. **Lexing**：词法分析将标记转换为对象并定义属性和规则
    3. **DOM construction**：根据HTML标记关系将对象组成DOM树

19. 解析过程中遇到图片、样式表、js文件，**启动下载**

20. 构建CSSOM树：

    1. **Tokenizing**：字符流转换为标记流
    2. **Node**：根据标记创建节点
    3. **CSSOM**：节点创建CSSOM树

21. [根据DOM树和CSSOM树构建渲染树](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction):

    1. 从DOM树的根节点遍历所有**可见节点**，不可见节点包括：
    
       1）`script`,`meta`这样本身不可见的标签。
    
       2)被css隐藏的节点，如`display: none`
    
    2. 对每一个可见节点，找到恰当的CSSOM规则并应用
    
    3. 发布可视节点的内容和计算样式

## 优化

- **网络**
  - 域名：利用多个域名来存储网站资源，节约主域名的连接数，优化页面响应速度 
  - 减少`HTTP`请求次数：合并文件、`CSS`精灵、`inline Image`
  - 减少`DNS`查询：`DNS`缓存、将资源分布到恰当数量的主机名
  - 懒加载也是一个经常被提及的技术，视窗外的内容是不会被用户立即看到的，这时加载过多的内容反而拖慢了网站整体的渲染，我们就可以用懒加载推迟这部分内容的加载来达到加速可访问和可交互性的目的，等用户即将到达视窗内的时候再开始加载这部分内容，通常懒加载会与loading和骨架屏等技术搭配使用。

- **缓存**
  - CDN缓存
  - 强缓存和协商缓存
- **代码优化**
  - 对组件使用`Gzip`压缩
  - `Tree-shaking`指的是消除没被引用的模块代码，减少代码体积大小，以提高页面的性能

- **html**
  - 减少`DOM`元素数量
  
  - 禁止使用`iframe`（阻塞父文档`onload`事件）
    - `iframe`会阻塞主页面的`Onload`事件
    - 搜索引擎的检索程序无法解读这种页面，不利于SEO
    - `iframe`和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载
    - 使用`iframe`之前需要考虑这两个缺点。如果需要使用`iframe`，最好是通过`javascript`
    - 动态给`iframe`添加`src`属性值，这样可以绕开以上两个问题
  - 页面头部的`<style></style>` `<script></script>` 会阻塞页面；（因为 `Renderer`进程中 `JS`线程和渲染线程是互斥的）
  - 用`innerHTML`代替`DOM`操作，减少`DOM`操作次数，优化`javascript`性能
  - 页面中空的 `href` 和 `src` 会阻塞页面其他资源的加载 (阻塞下载进程)
  
- **css**
  - 将样式表放到页面顶部
  - 不使用`CSS`表达式
  - 使用`<link>`不使用`@import`
  - 使用`CSS3`代码代替`JS`动画（尽可能避免重绘重排以及回流）
  - 当需要设置的样式很多时设置`className`而不是直接操作`style`
  
- **Javascript**
  - 将脚本放到页面底部
  - 将`javascript`和`css`从外部引入
  - 压缩`javascript`和`css`
  - 删除不需要的脚本
  - 减少`DOM`访问
  
- **图片**
  - 优化图片：根据实际颜色需要选择色深、压缩
  - 优化`css`精灵
  - 不要在`HTML`中拉伸图片
  - 禁止使用`gif`图片实现`loading`效果（降低`CPU`消耗，提升渲染性能）
  - 对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费`CPU`
    - 小图标优势在于
      - 减少`HTTP`请求
      - 避免文件跨域
      - 修改及时生效
  - 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳

### 白屏

https://mp.weixin.qq.com/s/-MbBKo6l-SxSmJmKvaWTGQ

白屏大概可能的原因有两种：

1. js 执行过程中的错误
2. 资源错误

**从而造成根节点下所有 DOM 被卸载**


## 调试工具Network及优化

https://mp.weixin.qq.com/s/CfL-uVNcKPasfcBcrifROA

Network面板记录了与服务器交互的具体细节。

在这里我们可以看到发起的请求数量，传输体积以及解压缩后的体积，同时还可以知道哪些资源是命中了强缓存，哪些资源命中的协商缓存。

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/HLN2IKtpicicGicicOVtKg9wVF4czfJvEIdeo09qdFM2poL7rdmxdriaHl6F5zQZXyNeze3lzic6Nia5Su2awfdjpREDw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

查看某一个请求的瀑布流可以让我们清晰的看到一个资源从服务器到达我们的电脑所花的时间。如上图，排队用了1.65ms，DNS查询用了21.47ms，initial connection(进行TCP握手的时间)用了56.25ms，SSL握手的时间用了37.87ms，然后又用了100多ms第一个字节到达我们的电脑(TTFB - 上面的查询/建立)，接收整个文档花了17ms。这时候我们基于上面的信息就可以粗略的得到，如果能在请求资源之前如果已经得到DNS地址(预查询)可以省去21ms，已经进行过握手可以省去100ms(预连接)，如果干脆请求也不请求可以省去200ms(缓存)继而针对这些点做对应的策略。Network面板可以让我们初步评估网站性能，对网站整体的体积，网络的影响带来一个整体的认知，同时提供一些辅助功能，如禁用缓存，block某些资源。

### DNS查询

与服务器交互首先要进行DNS查询，得到服务器的IP地址，浏览器会首先查询自己的缓存，之后会查询本地HOSTS，如果仍然没找到会发起向DNS服务器查询的请求。

### 建立HTTP(TCP)连接

得到服务器IP之后，首先进行三次握手，之后会进行SSL握手(HTTPS)，SSL握手时会向服务器端确认HTTP的版本

#### keep-alive

由于TCP的可靠性，每条独立的TCP连接都会进行一次三次握手，从上面的Network的分析中可以得到握手往往会消耗大部分时间，真正的数据传输反而会少一些(当然取决于内容多少)。HTTP1.0和HTTP1.1为了解决这个问题在header中加入了`Connection: Keep-Alive`，`keep-alive`的连接会保持一段时间不断开，后续的请求都会复用这一条TCP，不过由于管道化的原因也会发生**队头阻塞**的问题。HTTP1.1默认开启Keep-Alive，HTTP1.0可能现在不多见了，如果你还在用，可以升级一下版本，或者带上这个header。connection keep-alive

#### HTTP2

HTTP2相对于HTTP1.1的一个主要升级是多路复用，多路复用通过更小的二进制帧构成多条数据流，交错的请求和响应可以**并行传输**而不被阻塞，这样就解决了HTTP1.1时复用会产生的**队头阻塞**的问题，同时HTTP2有首部压缩的功能，如果两个请求首部(headers)相同，那么会省去这一部分，只传输不同的首部字段，进一步减少请求的体积。Nginx开启HTTP2的方式特别容易，只需要加一句`http2`既可开启：

```
server {
 listen 443 ssl http2; # 加一句 http2.
 server_name domain.com;
}
```

#### 缓存

缓存通过复用之前的获取过的资源，可以显著提高网站和应用程序的性能，合理的缓存不仅可以节省巨大的流量也会让用户二次进入时身心愉悦，如果一个资源完全走了本地缓存，那么就可以节省下整个与服务器交互的时间，如果整个网站的内容都被缓存在本地，那即使离线也可以继续访问(很酷，但还没有完全很酷)。HTTP缓存主要分为两种，一种是强缓存，另一种是协商缓存，都通过Headers控制。整体流程如下：

<img src="https://mmbiz.qpic.cn/mmbiz_png/HLN2IKtpicicGicicOVtKg9wVF4czfJvEIdeL4DnraNibZ7SicOaeSyKiaH36VRU8z4mvYhxO6ELYSUu5e4ibsANYvohLw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 67%;" />

**强缓存**

强缓存根据请求头的`Expires`和`Cache-Control`判断是否命中强缓存，命中强缓存的资源直接从本地加载，不会发起任何网络请求。`Cache-Control`的值有很多:

```
Cache-Control: max-age=<seconds>
Cache-Control: max-stale[=<seconds>]
Cache-Control: min-fresh=<seconds>
Cache-control: no-cache
Cache-control: no-store
Cache-control: no-transform
Cache-control: only-if-cached
```

常用的有`max-age`，`no-cache`和`no-store`。`max-age` 是资源从响应开始计时的最大新鲜时间，一般响应中还会出现`age`标明这个资源当前的新鲜程度。`no-cache` 会让浏览器缓存这个文件到本地但是不用，Network中`disable-cache`勾中的话就会在请求时带上这个haader，会在下一次新鲜度验证通过后使用这个缓存。`no-store` 会完全放弃缓存这个文件。服务器响应时的`Cache-Control`略有不同，其中有两个需要注意下:

1. public, public 表明这个请求可以被任何对象缓存，代理/CDN等中间商。
2. private，private 表明这个请求只能被终端缓存，不允许代理或者CDN等中间商缓存。

`Expires`是一个具体的日期，到了那个日期就会让这个缓存失活，优先级较低，存在`max-age`的情况下会被忽略，和本地时间绑定，修改本地时间可以绕过。另外，如果你的服务器的返回内容中不存在`Expires`，`Cache-Control: max-age`，或 `Cache-Control:s-maxage`但是存在`Last-Modified`时，那么浏览器默认会采用一个启发式的算法，即启发式缓存。通常会取响应头的`Date_value - Last-Modified_value`值的10%作为缓存时间，之后浏览器仍然会按强缓存来对待这个资源一段时间，如果你不想要缓存的话务必确保有`no-cache`或`no-store`在响应头中。

**协商缓存**

协商缓存一般会在强缓存新鲜度过期后发起，向服务器确认是否需要更新本地的缓存文件，如果不需要更新，服务器会返回304否则会重新返回整个文件。服务器响应中会携带`ETag`和`Last-Modified`，`Last-Modified` 表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（上次返回的`Last-Modified`的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成`Last-Modified`被修改，所以在HTTP / 1.1 出现了`ETag`。`Etag`就像一个指纹，资源变化都会导致`ETag`变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的`If-None-Match`的header会将上次返回的`ETag`发送给服务器，询问该资源的`ETag`是否有更新，有变动就会发送新的资源回来`ETag`(`If-None-Match`)的优先级高于`Last-Modified`(`If-Modified-Since`)，优先使用`ETag`进行确认。协商缓存比强缓存稍慢，因为还是会发送请求到服务器进行确认。

**CDN**

CDN会把源站的资源缓存到CDN服务器，当用户访问的时候就会从**最近的CDN服务器拿取资源而不是从源站拿取**，这样做的好处是分散了压力，同时也会提升返回访问速度和稳定性。

#### **压缩**

合理的压缩资源可以有效减少传输体积，减少传输体积的结果就是用户更快的拿到资源开始解析。压缩在各个阶段都会出现，比如上面提到的HTTP2的首部压缩，进行到这一步的压缩是指对整个资源文件进行的压缩。浏览器在发起请求时会在headers中携带`accept-encoding: gzip, deflate, br`，告知服务器客户端可以接受的压缩算法，之后响应资源会在响应头中携带`content-encoding: gzip`告知本文件的压缩算法。

**GZIP压缩**

GZIP是非常常用的压缩算法，现代客户端都会支持，你可以在上传文件时就上传一份压缩后的文件，也可以让Nginx动态压缩。

## 内存泄漏

- 未使用 var 声明的全局变量
- 闭包函数(Closures)
- 循环引用(两个对象相互引用)
- 控制台日志(console.log)
- 移除存在绑定事件的DOM元素(IE)
- `setTimeout` 的第一个参数使用字符串而非函数的话，会引发内存泄漏
- 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收

# 网络 安全

## 计算机网络

- 应用层包括:

  1、超文本传输协议（HTTP）:万维网的基本协议；
  2、文件传输（TFTP简单文件传输协议）；
  3、远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；
  4、网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；
  5、域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。


- 计算机上的应用程序如何找到另一台计算机上的相同的应用程序？

  IP地址：唯一确定网络的一台电脑

  端口：**确定电脑上的具体哪个应用程序**

  域名：由于IP地址不方便记忆，所以给IP地址起了个别名---域名，也就是通过域名可以找到对应的IP地址

  DNS：domain name system 域名系统，保存了域名和IP地址的对应关系

### TCP/UDP

https://zhuanlan.zhihu.com/p/24860273

TCP协议和UDP协议与TCP/IP协议的联系:TCP/IP协议是一个协议簇。里面包括很多协议的，UDP只是其中的一个， 之所以命名为TCP/IP协议，因为TCP、IP协议是两个很重要的协议，就用他两命名了。

TCP/IP协议集包括

1. 应用层（**应用进程间通信和交互的规则**：如域名DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议）
2. 传输层（**两台主机中进程之间的通信**：**传输控制协议TCP**，**用户数据报协议 UDP**）
3. 网络层（**不同主机提供通信服务**）

#### TCP

TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 一个TCP连接必须要经过三次“对话”才能建立起来

##### 三次握手

第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信；你可以用哪个序列号作为起始数据段来回应我。

第二次握手：主机B 收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我

第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段："我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了。

**3次握手的特点**
没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。

##### 4次挥手

第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；

第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；

第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；

第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。

由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。

##### 名词解释

1、ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。

2、SYN 同步序列号，TCP建立连接时将这个位置1。

3、FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,，提出断开连接的一方将这位置1。

#### **UDP**

**User Data Protocol，用户数据报协议**

1、UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。

2、 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。

3、UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。

4、吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。

5、UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。

6、UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。



我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。



**ping命令**是用来探测主机到主机之间是否可通信，如果不能**ping**到某台主机，表明不能和这台主机建立连接。**ping命令**是使用 IP 和网络控制信息协议 (ICMP)，因而没有涉及到任何传输协议(UDP/TCP) 和应用程序。它发送icmp回送请求消息给目的主机。

ICMP协议规定：目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。

#### 区别

![img](https://image-static.segmentfault.com/563/628/563628850-5fa50187ba70e_fix732)

### HTTP

HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。
HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

HTTP三点注意事项：

- HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
- HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
- HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。无状态协议，即：服务器不需要知道客户端是谁,只认请求（一次请求request,一次相应response）

![img](https://img-blog.csdn.net/20140610210038140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YW5kcm9pZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

![img](https://img-blog.csdnimg.cn/2019022420515851.png)

#### HTTP 请求响应报文

HTTP 请求报文由3部分组成(请求行+请求头+请求体)

<img src="https://upload-images.jianshu.io/upload_images/12603307-27e3bf8fde18f443.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%;" />



响应报文与请求报文一样,由三个部分组成(响应行,响应头,响应体)

<img src="https://upload-images.jianshu.io/upload_images/12603307-cf75b41f632499a3.png?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp" alt="img" style="zoom: 67%;" />



#### HTTP状态码及其含义

- 1XX：信息状态码

  - `100 Continue` 继续，一般在发送`post`请求时，已发送了`http header`之后服务端将返回此信息，表示确认，之后发送具体参数信息

- 2XX：成功状态码

  | 200  | OK                            | 请求成功。一般用于GET与POST请求                              |
  | ---- | ----------------------------- | ------------------------------------------------------------ |
  | 201  | Created                       | 已创建。成功请求并创建了新的资源                             |
  | 202  | Accepted                      | 已接受。已经接受请求，但未处理完成                           |
  | 203  | Non-Authoritative Information | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
  | 204  | No Content                    | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
  | 205  | Reset Content                 | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
  | 206  | Partial Content               | 部分内容。服务器成功处理了部分GET请求                        |

- 3XX：重定向JSON.parse(

  | 300  | Multiple Choices   | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
  | ---- | ------------------ | ------------------------------------------------------------ |
  | 301  | Moved Permanently  | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
  | 302  | Found              | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
  | 303  | See Other          | 查看其它地址。与301类似。使用GET和POST请求查看               |
  | 304  | Not Modified       | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
  | 305  | Use Proxy          | 使用代理。所请求的资源必须通过代理访问                       |
  | 306  | Unused             | 已经被废弃的HTTP状态码                                       |
  | 307  | Temporary Redirect | 临时重定向。与302类似。使用GET请求重定向                     |

- 4XX：客户端错误

  | 400  | Bad Request      | 客户端请求的语法错误，服务器无法理解                         |
  | ---- | ---------------- | ------------------------------------------------------------ |
  | 401  | Unauthorized     | 请求要求用户的身份认证                                       |
  | 402  | Payment Required | 保留，将来使用                                               |
  | 403  | Forbidden        | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
  | 404  | Not Found        | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |

- 5XX:服务器错误

  | 500  | Internal Server Error      | 服务器内部错误，无法完成请求                                 |
  | ---- | -------------------------- | ------------------------------------------------------------ |
  | 501  | Not Implemented            | 服务器不支持请求的功能，无法完成请求                         |
  | 502  | Bad Gateway                | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
  | 503  | Service Unavailable        | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
  | 504  | Gateway Time-out           | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
  | 505  | HTTP Version not supported | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

#### 请求头和响应头



![img](https://img2018.cnblogs.com/blog/1301998/201906/1301998-20190621104932351-2057147169.png)

##### HTTP消息头

`HTTP消息头`是指，在超文本传输协议（ Hypertext Transfer Protocol ，HTTP）的请求和响应消息中，协议头部分的那些组件。HTTP消息头用来准确描述正在获取的资源、服务器或者客户端的行为，定义了HTTP事务中的具体操作参数。

Query Params：常用是**get**方式请求，query是指**请求行**中请求的参数，一般是指URL中？后面的参数

Body Params：常用是**post**方式请求，body是指**请求体**中的数据

##### Request Header

**HTTP协议使用TCP协议进行传输，在应用层协议发起交互之前，首先是TCP的三次握手。完成了TCP三次握手后，客户端会向服务器发出一个请求报文**

**HTTP最常见的请求头如下：**

| 协议头              | 说明                                                         | 示例                                                         | 状态       |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- |
| Accept              | 可接受的响应内容类型（`Content-Types`）。                    | `Accept: text/plain`                                         | 固定       |
| Accept-Charset      | 可接受的字符集                                               | `Accept-Charset: utf-8`                                      | 固定       |
| Accept-Encoding     | 可接受的响应内容的编码方式。                                 | `Accept-Encoding: gzip, deflate`                             | 固定       |
| Accept-Language     | 可接受的响应内容语言列表。                                   | `Accept-Language: en-US`                                     | 固定       |
| Accept-Datetime     | 可接受的按照时间来表示的响应内容版本                         | Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT               | 临时       |
| Authorization       | 用于表示HTTP协议中需要认证资源的认证信息                     | Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==            | 固定       |
| Cache-Control       | 用来指定当前的请求/回复中的，是否使用缓存机制。              | `Cache-Control: no-cache`              max-age：缓存无法返回缓存时间长于max-age规定秒的文档 | 固定       |
| Connection          | 客户端（浏览器）想要优先使用的连接类型                       | `Connection: keep-alive``Connection: Upgrade`                | 固定       |
| Cookie              | 由之前服务器通过`Set-Cookie`（见下文）设置的一个HTTP协议Cookie | `Cookie: $Version=1; Skin=new;`                              | 固定：标准 |
| Content-Length      | 以8进制表示的请求体的长度                                    | `Content-Length: 348`                                        | 固定       |
| Content-MD5         | 请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果 | Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==                        | 废弃       |
| Content-Type        | 请求体的MIME类型 （用于POST和PUT请求中）                     | Content-Type: application/x-www-form-urlencoded              | 固定       |
| Date                | 发送该消息的日期和时间（以[RFC 7231](http://tools.ietf.org/html/rfc7231#section-7.1.1.1)中定义的"HTTP日期"格式来发送） | Date: Dec, 26 Dec 2015 17:30:00 GMT                          | 固定       |
| Expect              | 表示客户端要求服务器做出特定的行为                           | `Expect: 100-continue`                                       | 固定       |
| From                | 发起此请求的用户的邮件地址                                   | `From: user@itbilu.com`                                      | 固定       |
| Host                | 表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。 | `Host: www.itbilu.com:80``Host: www.itbilu.com`              | 固定       |
| If-Match            | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。 | If-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"                 | 固定       |
| If-Modified-Since   | 把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中. | If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT             | **固定**   |
| **If-None-Match**   | If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能 | If-None-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"            | 固定       |
| If-Range            | 如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体 | If-Range: "9jd00cdj34pss9ejqiw39d82f20d0ikd"                 | 固定       |
| If-Unmodified-Since | 仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。   | If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT           | 固定       |
| Max-Forwards        | 限制该消息可被代理及网关转发的次数。                         | `Max-Forwards: 10`                                           | 固定       |
| Origin              | 发起一个针对[跨域资源共享](http://itbilu.com/javascript/js/VkiXuUcC.html)的请求（该请求要求服务器在响应中加入一个`Access-Control-Allow-Origin`的消息头，表示访问控制所允许的来源）。 | `Origin: http://www.itbilu.com`                              | 固定: 标准 |
| Pragma              | 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。 | `Pragma: no-cache`                                           | 固定       |
| Proxy-Authorization | 用于向代理进行认证的认证信息。                               | Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2==      | 固定       |
| Range               | 表示请求某个实体的一部分，字节偏移以0开始。                  | `Range: bytes=500-999`                                       | 固定       |
| Referer             | 表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。`Referer`其实是`Referrer`这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用`Referer`了。 | Referer: http://itbilu.com/nodejs                            | 固定       |
| TE                  | 浏览器预期接受的传输时的编码方式：可使用回应协议头`Transfer-Encoding`中的值（还可以使用"trailers"表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。 | `TE: trailers,deflate`                                       | 固定       |
| User-Agent          | 浏览器的身份标识字符串                                       | `User-Agent: Mozilla/……`                                     | 固定       |
| Upgrade             | 要求服务器升级到一个高版本协议。                             | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11               | 固定       |
| Via                 | 告诉服务器，这个请求是由哪些代理发出的。                     | Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)               | 固定       |
| Warning             | 一个一般性的警告，表示在实体内容体中可能存在错误。           | Warning: 199 Miscellaneous warning                           | 固定       |

##### Response Header

**响应报文**：**当收到get或post等方法发来的请求后，服务器就要对报文进行响应。**

| 响应头                      | 说明                                                         | 示例                                                         | 状态       |
| :-------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--------- |
| Access-Control-Allow-Origin | 指定哪些网站可以`跨域源资源共享`                             | `Access-Control-Allow-Origin: *`                             | 临时       |
| Accept-Patch                | 指定服务器所支持的文档补丁格式                               | Accept-Patch: text/example;charset=utf-8                     | 固定       |
| Accept-Ranges               | 服务器所支持的内容范围                                       | `Accept-Ranges: bytes`                                       | 固定       |
| Age                         | 响应对象在代理缓存中存在的时间，以秒为单位                   | `Age: 12`                                                    | 固定       |
| Allow                       | 对于特定资源的有效动作;                                      | `Allow: GET, HEAD`                                           | 固定       |
| Cache-Control               | 通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒 | `Cache-Control: max-age=3600`                                | 固定       |
| Connection                  | 针对该连接所预期的选项                                       | `Connection: close`                                          | 固定       |
| Content-Disposition         | 对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。 | Content-Disposition: attachment; filename="fname.ext"        | 固定       |
| Content-Encoding            | 响应资源所使用的编码类型。                                   | `Content-Encoding: gzip`                                     | 固定       |
| Content-Language            | 响就内容所使用的语言                                         | `Content-Language: zh-cn`                                    | 固定       |
| Content-Length              | 响应消息体的长度，用8进制字节表示                            | `Content-Length: 348`                                        | 固定       |
| Content-Location            | 所返回的数据的一个候选位置                                   | `Content-Location: /index.htm`                               | 固定       |
| Content-MD5                 | 响应内容的二进制 MD5 散列值，以 Base64 方式编码              | Content-MD5: IDK0iSsgSW50ZWd0DiJUi==                         | 已淘汰     |
| Content-Range               | 如果是响应部分消息，表示属于完整消息的哪个部分               | Content-Range: bytes 21010-47021/47022                       | 固定       |
| Content-Type                | 当前内容的`MIME`类型                                         | Content-Type: text/html; charset=utf-8                       | 固定       |
| Date                        | 此条消息被发送时的日期和时间(以[RFC 7231](http://tools.ietf.org/html/rfc7231#section-7.1.1.1)中定义的"HTTP日期"格式来表示) | Date: Tue, 15 Nov 1994 08:12:31 GMT                          | 固定       |
| ETag                        | 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列  | ETag: "737060cd8c284d8af7ad3082f209582d"                     | 固定       |
| Expires                     | 指定一个日期/时间，超过该时间则认为此回应已经过期            | Expires: Thu, 01 Dec 1994 16:00:00 GMT                       | 固定: 标准 |
| Last-Modified               | 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) | Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT                 | 固定       |
| Link                        | 用来表示与另一个资源之间的类型关系，此类型关系是在[RFC 5988](https://tools.ietf.org/html/rfc5988)中定义 | `Link: `; rel="alternate"                                    | 固定       |
| Location                    | 用于在进行重定向，或在创建了某个新资源时使用。               | Location: http://www.itbilu.com/nodejs                       | 固定       |
| P3P                         | P3P策略相关设置                                              | P3P: CP="This is not a P3P policy!                           | 固定       |
| Pragma                      | 与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果 | `Pragma: no-cache`                                           | 固定       |
| Proxy-Authenticate          | 要求在访问代理时提供身份认证信息。                           | `Proxy-Authenticate: Basic`                                  | 固定       |
| Public-Key-Pins             | 用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值   | Public-Key-Pins: max-age=2592000; pin-sha256="……";           | 固定       |
| Refresh                     | 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。 | Refresh: 5; url=http://itbilu.com                            |            |
| Retry-After                 | 如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。 | 示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT | 固定       |
| Server                      | 服务器的名称                                                 | `Server: nginx/1.6.3`                                        | 固定       |
| Set-Cookie                  | 设置`HTTP cookie`                                            | Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1           | 固定标准   |
| Status                      | 通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。   | `Status: 200 OK`                                             |            |
| Trailer                     | `Trailer`用户说明传输中分块编码的编码信息                    | `Trailer: Max-Forwards`                                      | 固定       |
| Transfer-Encoding           | 用表示实体传输给用户的编码形式。包括：`chunked`、`compress`、 `deflate`、`gzip`、`identity`。 | Transfer-Encoding: chunked                                   | 固定       |
| Upgrade                     | 要求客户端升级到另一个高版本协议。                           | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11               | 固定       |
| Vary                        | 告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。 | `Vary: *`                                                    | 固定       |
| Via                         | 告知代理服务器的客户端，当前响应是通过什么途径发送的。       | Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)                  | 固定       |
| Warning                     | 一般性警告，告知在实体内容体中可能存在错误。                 | Warning: 199 Miscellaneous warning                           | 固定       |
| WWW-Authenticate            | 表示在请求获取这个实体时应当使用的认证模式。                 | `WWW-Authenticate: Basic`                                    | 固定       |

**在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，是解决跨域的一种方法。**

## 浏览器缓存

### ETag

在HTTP1.1规范中，新增了一个HTTP头信息：ETag。

浏览器**第一次**请求一个资源的时候，服务端给予返回，并且返回了**ETag**: "50b1c1d4f775c61:df3" 这样的字样给浏览器，当浏览器再次请求这个资源的时候，浏览器会将**If-None-Match**: W/"50b1c1d4f775c61:df3" 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化，如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。

通过Etag来利用浏览器的缓存，降低我们服务器的带宽压力。



**第一次请求，服务器返回Etag。强缓存，expires和Cache-Control，判断是否过期，过期，请求服务器，服务端拿到该ETAG，对比资源是否发生变化，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；**

https://www.jianshu.com/p/cb72dfb0f7b3

https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556794&idx=1&sn=0186d0c4b36b6e7e0adf7ffaf7b3f9b8

https://louiszhai.github.io/2017/04/07/http-cache/

![img](https://upload-images.jianshu.io/upload_images/7567844-3fa31eccdfc2f4f9.png?imageMogr2/auto-orient/strip|imageView2/2/w/597/format/webp)

### 缓存的流程

浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下

- 先根据这个资源的一些 `http header` 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；
- 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些`request header`验证这个资源是否命中协商缓存，称为`http`再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；
- 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。
- 当协商缓存也没命中时，服务器就会将资源发送回客户端。
- 当 `ctrl+f5` 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；
- 当 `f5`刷新网页时，跳过强缓存，但是会检查协商缓存；

**本地缓存阶段(也称强缓存)**

先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器；

- `Expires`（该字段是 `http1.0` 时的规范，值为一个绝对时间的 `GMT` 格式的时间字符串，代表缓存资源的过期时间）
- `Cache-Control:max-age`（该字段是 `http1.1`的规范，强缓存利用其 `max-age` 值来判断缓存资源的最大生命周期，它的值单位为秒）

**协商缓存阶段(也称弱缓存)**

如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器，然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；

- `Last-Modified`（值为资源最后更新时间，随服务器response返回）
- `If-Modified-Since`（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）
- `ETag`（表示资源内容的唯一标识，随服务器`response`返回）
- `If-None-Match`（服务器通过比较请求头部的`If-None-Match`与当前资源的`ETag`是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）

### 缓存有关的HTTP消息报头

#### Cache-Control

- **max-age**（单位为s）指定设置缓存最大的有效时间，定义的是时间长短。当浏览器向服务器发送请求后，在max-age这段时间里浏览器就不会再向服务器发送请求了。
- **s-maxage**（单位为s）同max-age，只用于共享缓存（比如CDN缓存）。比如，当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。也就是说**max-age用于普通缓存，而s-maxage用于代理缓存**。如果存在s-maxage，则会覆盖掉max-age和Expires header。
- **no-cache** 指定不缓存响应，**表明资源不进行缓存**，但是设置了 no-cache 之后并**不代表浏览器不缓存**，而是在**获取缓存前要向服务器确认资源是否被更改**。因此有的时候只设置 no-cache 防止缓存还是不够保险，还可以加上 private 指令，将过期时间设为过去的时间。（no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期，即走协商缓存的路线）
- **no-store** 绝对禁止缓存，如果用了这个命令就是**不会进行缓存**，**每次请求资源都要从服务器重新获取**。（no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。）

#### Cache-Control与Expires

Cache-Control与 Expires的作用一致，都是**指明当前资源的有效期**，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过 Cache-Control的选择更多，设置更细致，如果同时设置的话，其**优先级高于 Expires**。

#### public 与 private

public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。如果我们为资源设置了 public，那么它**既可以被浏览器缓存，也可以被代理服务器缓存**；如果我们设置了 private，则该资源**只能被浏览器缓存**。private 为默认值。

#### Last-Modified与ETag

**Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符**，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，**服务器会优先验证ETag**，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

#### Last-Modified/ETag 与 Cache-Control/Expires

- 配置 Last-Modified/ETag的情况下，浏览器再次访问统一URI的资源，**还是会发送请求到服务器**询问文件是否已经修改，如果没有，服务器会只发送一个304回给浏览器，告诉浏览器直接从自己本地的缓存取数据；如果修改过那就整个数据重新发给浏览器；
- Cache-Control/Expires则不同，如果检测到本地的缓存还是有效的时间范围内，浏览器直接使用本地副本，**不会发送任何请求**。两者一起使用时， Cache-Control/Expires的优先级要高，即**当本地副本根据 Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间 Last-Modified或实体标识 Etag了。**
- 一般情况下，两者会配合一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时 Last-Modified/ETag将能够很好利用304，从而减少响应开销。

#### 有Last-Modified为什么还要有ETag？

HTTP1.1中Etag的出现主要是为了解决几个 Last-Modified 比较难解决的问题：

- Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度
- 如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存
- 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

## 描述一下XSS和CRSF攻击？防御方法？

### XSS

即为（Cross Site Scripting）, 中文名为跨站脚本,XSS 的攻击方式是黑客往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户页面的数据上传到黑客的服务器上，最后黑客再利用这些数据进行一些恶意操作。

### CSRF

Cross Site Request Forgery，跨站请求伪造，字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。

eg:David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗

![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0ng0DPsEaWQULZjqQ8Sw6KICkbQpPuo0GrtWLqYpw5aehchurtbqo0ibfvkls6mNWxHiaSOoMQIeHmoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。
- 接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。
- 最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。

如何防止 CSRF 攻击，具体来讲主要有三种方式：充分利用好 Cookie 的 SameSite 属性、验证请求的来源站点和使用 CSRF Token。

**网页验证码是干嘛的，是为了解决什么安全问题**

- 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水
- 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试

### **XSS与CSRF有什么区别吗？**

- `XSS`是获取信息，不需要提前知道其他用户页面的代码和数据包。`CSRF`是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次`CSRF`攻击，受害者必须依次完成两个步骤
- 登录受信任网站`A`，并在本地生成`Cookie`
- 在不登出`A`的情况下，访问危险网站`B`

## web安全及防护原理

- `sql`注入原理
  - 就是通过把`SQL`命令插入到`Web`表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令
- 总的来说有以下几点
  - 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双`"-"`进行转换等
  - 永远不要使用动态拼装SQL，可以使用参数化的`SQL`或者直接使用存储过程进行数据查询存取
  - 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接
  - 不要把机密信息明文存放，请加密或者`hash`掉密码和敏感的信息

**XSS原理及防范**

- `Xss(cross-site scripting)`攻击指的是攻击者往`Web`页面里插入恶意`html`标签或者`javascript`代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取`cookie`中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点

**XSS防范方法**

- 首先代码里对用户输入的地方和变量都需要仔细检查长度和对`”<”,”>”,”;”,”’”`等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把`html tag` 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击

**XSS与CSRF有什么区别吗？**

- `XSS`是获取信息，不需要提前知道其他用户页面的代码和数据包。`CSRF`是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次`CSRF`攻击，受害者必须依次完成两个步骤
- 登录受信任网站`A`，并在本地生成`Cookie`
- 在不登出`A`的情况下，访问危险网站`B`

**CSRF的防御**

- 服务端的`CSRF`方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数
- 通过验证码的方法

## CORS跨域

https://javascript.ruanyifeng.com/bom/cors.html

 cross-origin resource sharing, 跨域资源共享.  它允许浏览器向跨域的服务器，发出`XMLHttpRequest`请求，从而克服了AJAX只能同源使用的限制。 

CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。

整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。

### 跨域请求分类

浏览器将跨域请求分为两大类: 简单请求和非简单请求.

同时满足以下条件的请求都为简单请求:

- a. 请求方式为下列之一: 
  - GET
  - POST
  - HEAD
- b. 请求头信息不超出以下字段: 
  - Accept
  - Accept-Language
  - Content-Language
  - Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

### 简单请求

#### 基本流程

对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个`Origin`字段。

下面是一个例子，浏览器发现这次跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个`Origin`字段。

```
GET /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面的头信息中，`Origin`字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

```
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
Content-Type: text/html; charset=utf-8
```

上面的头信息之中，有三个与 CORS 请求相关的字段，都以`Access-Control-`开头。

**（1）`Access-Control-Allow-Origin`**

该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

**（2）`Access-Control-Allow-Credentials`**

该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为`true`，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送 Cookie，不发送该字段即可。

**（3）`Access-Control-Expose-Headers`**

该字段可选。CORS 请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个服务器返回的基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。

#### withCredentials 属性

上面说到，CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等）。如果需要包含 Cookie 信息，一方面要服务器同意，指定`Access-Control-Allow-Credentials`字段。

```
Access-Control-Allow-Credentials: true
```

另一方面，开发者必须在 AJAX 请求中打开`withCredentials`属性。

```
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。

但是，如果省略`withCredentials`设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭`withCredentials`。

```
xhr.withCredentials = false;
```

需要注意的是，如果要发送 Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的`document.cookie`也无法读取服务器域名下的 Cookie。

### 非简单请求

#### 预检请求

非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。

非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器大量收到`DELETE`和`PUT`请求，这些传统的表单不可能跨域发出的请求。

下面是一段浏览器的 JavaScript 脚本。

```
var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
```

上面代码中，HTTP 请求的方法是`PUT`，并且发送一个自定义头信息`X-Custom-Header`。

浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。

```
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

“预检”请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。

除了`Origin`字段，“预检”请求的头信息包括两个特殊字段。

**（1）`Access-Control-Request-Method`**

该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是`PUT`。

**（2）`Access-Control-Request-Headers`**

该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是`X-Custom-Header`。

#### 预检请求的回应

服务器收到“预检”请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

```
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

上面的 HTTP 回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

```
Access-Control-Allow-Origin: *
```

如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。

```
OPTIONS http://api.bob.com HTTP/1.1
Status: 200
Access-Control-Allow-Origin: https://notyourdomain.com
Access-Control-Allow-Method: POST
```

上面的服务器回应，`Access-Control-Allow-Origin`字段明确不包括发出请求的`http://api.bob.com`。

这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

```
XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
```

服务器回应的其他 CORS 相关字段如下。

```
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
```

**（1）`Access-Control-Allow-Methods`**

该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。

**（2）`Access-Control-Allow-Headers`**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。

**（3）`Access-Control-Allow-Credentials`**

该字段与简单请求时的含义相同。

**（4）`Access-Control-Max-Age`**

该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

#### 浏览器的正常请求和回应

一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

下面是“预检”请求之后，浏览器的正常 CORS 请求。

```
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面头信息的`Origin`字段是浏览器自动添加的。

下面是服务器正常的回应。

```
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```

上面头信息中，`Access-Control-Allow-Origin`字段是每次回应都必定包含的。

### 为什么要有同源限制？

- 同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议
- 举例说明：比如一个黑客程序，他利用`Iframe`把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过`Javascript`读取到你的表单中`input`中的内容，这样用户名，密码就轻松到手了。



## Ajax

### XMLHttpRequest

**XMLHttpRequest**

 XMLHttpRequest(XHR) 对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。 

 `XMLHttpRequest` 可以用于获取任何类型的数据，而不仅仅是 XML。它甚至支持 [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP) 以外的协议（包括 file:// 和 FTP），尽管可能受到更多出于安全等原因的限制。 

 **1.  属性**

- **XMLHttpRequest.responseType**  表示服务器返回数据的类型，这个属性是可写的，在 open 之后，send 之前，告诉服务器返回指定类型的数据。如果 responseType 设为空字符串，就等同于默认值 text 表示服务器返回文本数据； 
- **XMLHttpRequest.onreadystatechange**当 `readyState` 属性发生变化时，调用的 [`EventHandler`](https://developer.mozilla.org/zh-CN/docs/Web/API/EventHandler)。
- **readyState** HTTP 请求的状态，当一个 XMLHttpRequest 初次创建时，这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。 
- **status**   由服务器返回的 HTTP 状态代码，如 200 表示成功，而 404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。 
- **response**   该属性只读表示服务器返回的数据体，可能是任意的数据类型，比如字符串，对象，二进制对象等，具体类型由responseType 属性决定。如果本次请求没有成功或者数据不完整，该属性等于 null 

 **2.  方法**

| abort()                 | 取消当前响应，关闭连接并且结束任何未决的网络活动             |
| ----------------------- | ------------------------------------------------------------ |
| getAllResponseHeaders() | 把 HTTP 响应头部作为未解析的字符串返回                       |
| getResponseHeader()     | 返回指定的 HTTP 响应头部的值                                 |
| open()                  | 初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求 |
| send()                  | 发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体 |
| setRequestHeader()      | 向一个打开但未发送的请求设置或添加一个 HTTP 请求头           |

### 原生Ajax

- `Ajax`的原理简单来说是在用户和服务器之间加了—个中间层(`AJAX`引擎)，通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用`javascrip`t来操作`DOM`而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据

- `Ajax`的过程只涉及`JavaScript`、`XMLHttpRequest`和`DOM`。`XMLHttpRequest`是`aja`x的核心机制

  

  **Ajax**表示Asynchronous JavaScript and XML(异步JavaScript和XML)，使我们可以获取数据并显示新的内容而不必载入一个新的Web页面

  **1)	创建XMLHttpRequest**	

  var xhr = new XMLHttpRequest()；标准浏览器

  var xhr = new ActiveXObject('Microsoft.XMLHTTP')；IE老版本

  **2)	准备发送	xhr.open(1，2，3)** 

  ```
  参数1，请求方式，get获取数据，post提交数据
  参数2，请求地址url
  参数3，同步异步标志位，true是异步
  ```

  - get请求，url要加参数，这样php才能接受到参数

    ```
    '/01.php?username'+username+'&password'+password
    ```

    `encodeURI（）`用来对中文参数进行编码，防止中文乱码

  - post请求，url只需要地址,不需要参数,参数在send中传递


  **3)	执行发送动作**   

  - get请求 xhr.send(null)；


  - post请求 

    xhr.setRequestHeader("content-Type","application/x-www-form-urlencoded")**//必须要请求头信息**

    ​	在Form元素的语法中，EncType表明提交数据的格式

    ​	用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。

    - application/x-www-form-urlencoded ： 窗体数据被编码为名称/值对。这是标准的编码格式。（默认）
    - multipart/form-data ： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。(type=file使用)
    - text/plain ： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。

    var param='username'+username+'password'+password;

    xhr.send(param);这里不需要encodeURI编码

  **4）指定回调函数	浏览器调用**

  ```js
  xhr.onreadystatechange = function(){
  
  if(xhr.readystate == 4)是否接收到数据{
  
  ​	if(xhr.status == 200)数据是否正常{
  
  ​			var data = xhr.responseXML;
  }
  
  }
  ```

  # 

```javascript
/** 1. 创建连接 **/
var xhr = null;
xhr = new XMLHttpRequest()
/** 2. 连接服务器 **/
xhr.open('get', url, true)
/** 3. 发送请求 **/
xhr.send(null);
/** 4. 接受请求 **/
xhr.onreadystatechange = function(){
	if(xhr.readyState == 4){
		if(xhr.status == 200){
			success(xhr.responseText);
		} else { 
			/** false **/
			fail && fail(xhr.status);
		}
	}
}
```

### 跨域

**jsonp的原理**：html中通过动态创建一个script标签，通过它的src属性发送跨域请求，从服务器端响应的**数据格式是一个函数的调用**,函数名要一致。eg:$callback.'(username='.$uname.')'

- html中的函数就是回调函数

  ```js
  var script = document.createElement('script');
  
  var head = document.getElementByTagName('head')[0];
  
  script.src='http::/1.html/1.php?callback=hello&username=123';
  
  head.appendChild(script);
  
  function hello(data){
  
  console.log(data);
  
  }
  ```

- php

  ```php
  $cb = $_Get[$callback];
  
  $uname = $_Get[$username];
  
  echo $cb.'('.'{"username":"'$uname'"}'.')';
  ```

## Token

 1、Token的引入：Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。

  2、Token的定义：Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

  3、使用Token的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。

# 存储

## cookie

https://mp.weixin.qq.com/s/D7tWeUPsUfYsA97au5soNg

### **Cookie机制**

在程序中，会话跟踪是很重要的事情。理论上，**一个用户的所有请求操作都应该属于同一个会话**，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。

而Web应用程序是使用HTTP协议传输数据的。**HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话**。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。

Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。

### 配置

- 在提供标记的接口，通过 HTTP 返回头的 Set-Cookie 字段，直接「种」到浏览器上
- 浏览器发起请求时，会自动把 cookie 通过 HTTP 请求头的 Cookie 字段，带给接口

```http
Set-Cookie: username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 
```

#### **Domain / Path**

> 你不能拿清华的校园卡进北大。

Domain属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前 URL 的一级域名，比如 www.example.com 会设为 example.com，而且以后如果访问example.com的任何子域名，HTTP 请求也会带上这个 Cookie。如果服务器在Set-Cookie字段指定的域名，不属于当前域名，浏览器会拒绝这个 Cookie。

Path属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，Path属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，PATH属性是/，那么请求/docs路径也会包含该 Cookie。当然，前提是域名必须一致。

#### **Expires / Max-Age**

> 你毕业了卡就不好使了。

Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式。如果不设置该属性，或者设为null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。

Max-Age属性指定从现在开始 Cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。

如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。

如果Set-Cookie字段没有指定Expires或Max-Age属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。

#### **Secure / HttpOnly**

> 有的学校规定，不带卡套不让刷（什么奇葩学校，假设）；有的学校不让自己给卡贴贴纸。

### cookie读写

#### **HTTP 头对 cookie 的读写**

HTTP 返回的一个 Set-Cookie 头用于向浏览器写入「一条（且只能是一条）」cookie，格式为 cookie 键值 + 配置键值。例如：

```http
Set-Cookie: username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 
```

那我想一次多 set 几个 cookie 怎么办？多给几个 Set-Cookie 头（一次 HTTP 请求中允许重复）

```http
Set-Cookie: username=jimu; domain=jimu.com
Set-Cookie: height=180; domain=me.jimu.com
Set-Cookie: weight=80; domain=me.jimu.com 
```

#### **前端对 cookie 的读写**

前端可以自己创建 cookie，如果服务端创建的 cookie 没加`HttpOnly`，那恭喜你也可以修改他给的 cookie。

调用`document.cookie`可以创建、修改 cookie，和 HTTP 一样，一次`document.cookie`能且只能操作一个 cookie。

```js
document.cookie = 'username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct
```

调用`document.cookie`也可以读到 cookie，也和 HTTP 一样，能读到所有的非`HttpOnly`cookie。

```js
console.log(document.cookie);
// username=jimu; height=180; weight=80 
```

### 应用方案

#### 服务端 session

现在回想下，你刷卡的时候发生了什么？

> 其实你的卡上只存了一个 id（可能是你的学号），刷的时候物业系统去查你的信息、账户，再决定「这个门你能不能进」「这个鸡腿去哪个账户扣钱」。

这种操作，在前后端鉴权系统中，叫 session。

典型的 session 登陆/验证流程：

<img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhSL9SSvlVyK9rZpYbMEce09OVXcUR7ME0lRty0c2g2gzAdiasgqZMicvw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

- 浏览器登录发送账号密码，服务端查用户库，校验用户
- 服务端把用户登录状态存为 Session，生成一个 sessionId
- 通过登录接口返回，把 sessionId set 到 cookie 上
- 此后浏览器再请求业务接口，sessionId 随 cookie 带上
- 服务端查 sessionId 校验 session
- 成功后正常做业务处理，返回结果

**「Session 的存储方式」**

显然，**服务端只是给 cookie 一个 sessionId**，而 session 的具体内容（可能包含用户信息、session 状态等），要自己存一下。存储的方式有几种：

- Redis（推荐）：内存型数据库，redis中文官方网站。以 key-value 的形式存，正合 sessionId-sessionData 的场景；且访问快。
- 内存：直接放到变量里。一旦服务重启就没了
- 数据库：普通数据库。性能不高。

**「Session 的过期和销毁」**

很简单，只要把存储的 session 数据销毁就可以。

**「Session 的分布式问题」**

> 由于服务器要存储所有用户 的sessionId,所以需要多台机器来存储用户信息，从而形成一个集群。假设小明通过手机登录系统，sessionId保存在机器A中，但是请求被转发到机器B中，就访问不到小明的id。

通常服务端是**集群**，而用户请求过来会走一次负载均衡，不一定打到哪台机器上。那一旦用户后续接口请求到的机器和他登录请求的机器不一致，或者登录请求的机器宕机了，session 不就失效了吗？

这个问题现在有几种解决方式。

- 一是从「存储」角度，把 session 集中存储。如果我们用独立的 Redis 或普通数据库，就可以把 session 都存到一个库里。
- 二是从「分布」角度，让相同 IP 的请求在负载均衡时都打到同一台机器上。以 nginx 为例，可以配置 ip_hash 来实现。

但通常还是采用第一种方式，因为第二种相当于阉割了负载均衡，且仍没有解决「用户请求的机器宕机」的问题。

如果不保存这些sessionId，怎么**验证**客户端发给我的sessionId是服务端生成的。如果不去验证，就可以伪造sessionId,为所欲为。

嗯，对了，关健点就是验证！
比如说，小明已经登录了系统，服务端给他发一个令牌（token），里边包含了小的user id，下一次小明再次通过Http请求访问我的时候，把这个token 通过Http header 带过来进行校验就可以了。这样id就存储在了客户端，服务端只是生成token。

#### token

session 的维护给服务端造成很大困扰，我们必须找地方存放它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。有没有更好的办法？

> 我又想到学校，在没有校园卡技术以前，我们都靠「学生证」。门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年级等信息，就可以放行了。

一个登录场景，也不必往 session 存太多东西，那为什么不直接打包到 cookie 中呢？这样服务端不用存了，每次只要核验 cookie 带的「证件」**有效性**就可以了，也可以携带一些轻量的信息。这种方式通常被叫做 token。

<img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxh1pp5jQibGiafq4a1Fbzf8of4KJONMrkl05WgoWQUc5nicY6ENibJoqCoIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

token 的流程是这样的：

- 用户登录，服务端校验账号密码，获得用户信息
- 把用户信息、token 配置编码成 token，通过 cookie set 到浏览器
- 此后用户请求业务接口，通过 cookie 携带 token
- 接口校验 token 有效性，进行正常业务接口处理

**「客户端 token 的存储方式」**

在前面 cookie 说过，cookie 并不是客户端存储凭证的唯一方式。token 因为它的「无状态性」，有效期、使用限制都包在 token 内容里，**对 cookie 的管理能力依赖较小**，客户端存起来就显得更自由。但 web 应用的主流方式仍是放在 cookie 里，毕竟少操心

**「token 的编码」**

编码的方式丰俭由人。

**1.base64**

比如 node 端的 cookie-session - npm 库

> 不要纠结名字，其实是个 token 库，但保持了和 express-session - npm 高度一致的用法，把要存的数据挂在 session 上

默认配置下，当我给他一个 userid，他会存成这样：



![图片](https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxh847kRibkcoibrtVwU5OcaVT3YibNicicSVkwXF5xehjHiac9lV9n633G51QQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



这里的 `eyJ1c2VyaWQiOiJhIn0=`，就是 `{"userid":"abb”}` 的 base64 而已。

**2.防篡改**

> 那问题来了，如果用户 cdd 拿`{"userid":"abb”}`转了个 base64，再手动修改了自己的 token 为 `eyJ1c2VyaWQiOiJhIn0=`，是不是就能直接访问到 abb 的数据了？

如果 token 涉及到敏感权限，就要想办法避免 token 被篡改。

解决方案就是给 token 加签名，来识别 token 是否被篡改过。例如在 cookie-session - npm 库中，增加两项配置：

```
secret: 'iAmSecret',
signed: true, 
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhGQnmqNyYKagPYWBVJnet30xhia2ibslMtsEEyE6YUqeHC0NdxztaBfsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

但上面的做法额外增加了 cookie 数量，数据本身也没有规范的格式，所以 JSON Web Token Introduction - jwt.io 横空出世了。

> JSON Web Token (JWT) 是一个开放标准，定义了一种传递 JSON 信息的方式。这些信息通过数字签名确保可信。

它是一种成熟的 token 字符串生成方案，包含了我们前面提到的数据、签名。不如直接看一下一个 JWT token 长什么样：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiJhIiwiaWF0IjoxNTUxOTUxOTk4fQ.2jf3kl_u
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxhMrU4STLto4juI9tPiabwOCewsw3f3icVQkyX79Oo7N9oxpS9tSpG6gsw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 总结

- HTTP 是无状态的，为了维持前后请求，需要前端存储标记
- cookie 是一种完善的标记方式，通过 HTTP 头或 js 操作，有对应的安全策略，是大多数状态管理方案的基石
- session 是一种状态管理方案，前端通过 cookie 存储 id，后端存储数据，但后端要处理分布式问题
- token 是另一种状态管理方案，相比于 session 不需要后端存储，数据全部存在前端，解放后端，释放灵活性
- token 的编码技术，通常基于 base64，或增加加密算法防篡改，jwt 是一种成熟的编码方案
- 在复杂系统中，token 可通过 service token、refresh token 的分权，同时满足安全性和用户体验
- session 和 token 的对比就是「用不用cookie」和「后端存不存」的对比
- 单点登录要求不同域下的系统「一次登录，全线通用」，通常由独立的 SSO 系统记录登录状态、下发 ticket，各业务系统配合存储和认证 ticket

## cookie和storage区别

- 生命周期：

  Cookie：可设置失效时间，否则默认为关闭浏览器后失效

  Localstorage:除非被手动清除，否则永久保存

  Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除

- 存放数据：

  Cookie：4k左右

  Localstorage和sessionstorage：可以保存5M的信息

- http请求：

  cookie数据始终在同源的http请求中携带（即使不需要），会在浏览器和服务器间来回传递

  其他两个：仅在客户端即浏览器中保存，不参与和服务器的通信

- 易用性：

  Cookie：需要程序员自己封装，原生的cookie接口不友好

  其他两个：即可采用原生接口，亦可再次封装

- 应用场景：

  从安全性来说，因为每次http请求都会携带cookie信息，这样子浪费了带宽，所以cookie应该尽可能的少用，此外cookie还需要指定作用域，**不可以跨域调用**，限制很多，但是识别用户登陆来说，cookie还是比storage好用，其他情况下可以用storage，localstorage可以用来在页面传递参数，sessionstorage可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数，

# html

## **对网页标准和标准制定机构重要性的理解** 

网页标准和标准制定机构都是为了能让 web 发展的更‘健康’，开发者遵循统一的标准，降 

低开发难度，开发成本，SEO 也会更好做，也不会因为滥用代码导致各种 BUG、安全问题， 

最终提高网站易用性。 

##  iframe有那些缺点？

- `iframe`会阻塞主页面的`Onload`事件
- 搜索引擎的检索程序无法解读这种页面，不利于`SEO`
- `iframe`和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载
- 使用`iframe`之前需要考虑这两个缺点。如果需要使用`iframe`，最好是通过`javascript`动态给`iframe`添加`src`属性值，这样可以绕开以上两个问题

##  Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

- `<!DOCTYPE>` 声明位于文档中的最前面，处于 `<html>` 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档
- 严格模式的排版和 `JS` 运作模式是 以该浏览器支持的最高标准运行
- 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
- DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现

## 严格模式的限制

- 变量必须声明后再使用
- 函数的参数不能有同名属性，否则报错
- 不能使用with语句
- 不能对只读属性赋值，否则报错
- 不能使用前缀0表示八进制数，否则报错
- 不能删除不可删除的属性，否则报错
- 不能删除变量`delete prop`，会报错，只能删除属性`delete global[prop]`
- `eval`不会在它的外层作用域引入变量
- `eval`和`arguments`不能被重新赋值
- `arguments`不会自动反映函数参数的变化
- 不能使用`arguments.callee`
- 不能使用`arguments.caller`
- 禁止`this`指向全局对象
- 不能使用`fn.caller`和`fn.arguments`获取函数调用的堆栈
- 增加了保留字（比如`protected`、`static`和`interface`）

## src 与 href 的区别

src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。 

src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在 

位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片 

和 frame 等元素。 

<script src =”js.js”></script> 

当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行 

完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 

js 脚本放在底部而不是头部。 

href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点） 

或当前文档（链接）之间的链接，如果我们在文档中添加 

<link href=”common.css” rel=”stylesheet”/> 

那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 

这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。

## XML和JSON的区别

- 数据体积方面
  - `JSON`相对`于XML`来讲，数据的体积小，传递的速度更快些。
- 数据交互方面
  - `JSON`与`JavaScript`的交互更加方便，更容易解析处理，更好的数据交互
- 数据描述方面
  - `JSON`对数据的描述性比`XML`较差
- 传输速度方面
  - `JSON`的速度要远远快于`XML`

# css

## link与@import的区别

1. @import是CSS提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS，rel连接属性等；
2. 加载页面时，link引入的CSS被同时加载，@import引入的CSS将在页面加载完毕后加载；
3. link标签作为HTML元素，不存在兼容性问题，而@import是CSS2.1才有的语法，故老版本浏览器（IE5之前）不能识别；
4. 可以通过JS操作DOM，来插入link标签改变样式；由于DOM方法是基于文档的，无法使用@import方式插入样式；
5. `link`引入的样式权重大于`@import`引入的样式。

建议使用link的方式引入CSS

## 盒模型

https://www.imooc.com/article/68238

<img src="https://img.html.cn/upload/image/445/883/226/1575271471430989.jpg" alt="1.jpg"  />

标准盒子模型

```
盒子实际内容（content）的width/height=我们设置的width/height;
盒子总宽度/高度=width/height+padding+border+margin。
```

IE盒子模型

```
content宽度+内边距padding+边框border宽度=我们设置的width(height也是如此)
盒子总宽度/高度=width/height + margin = content宽度/高度 + padding + border + margin
```

## position

固定定位fixed：

元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。

相对定位relative：

如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。

绝对定位absolute：

绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于<html>。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。

粘性定位sticky：

元素先按照普通文档流定位，然后相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。

默认定位Static：

默认值。没有定位，元素出现在正常的流中（忽略top, bottom, left, right 或者 z-index 声明）。

inherit:

规定应该从父元素继承position 属性的值。

## 水平居中的方法

- 元素为行内元素，设置父元素`text-align:center`
- 如果元素宽度固定，可以设置左右`margin`为`auto`;
- 绝对定位和移动: `absolute + transform`
- 使用`flex-box`布局，指定`justify-content`属性为center
- `display`设置为`tabel-cell`

## 元素的垂直居中

- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`
- 使用`flex`布局，设置为`align-item：center`
- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`
- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值
- 文本垂直居中设置`line-height`为`height`值


## calc属性

Calc用户动态计算长度值，任何长度值都可以使用calc()函数计算，需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；

## 行内元素和块元素

https://blog.csdn.net/Jwhahaha/article/details/102483938

### 块级元素block

可以设置宽高，独自占据一行高度（float浮动除外），一般可以作为其他容器使用，可容纳块级元素和行内元素。块级元素有以下特点：

- 每个块级元素都是独自占一行。 
- 元素的高度、宽度、行高和边距都是可以设置的。　　 
- 元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）,**高度由内容撑开**

```
h1~h6:标题标签，用于标记网页中的大标题，依次从大到小
p：用于标记网页中的段落性文字，默认占满横向区域
div：划分，分隔，作用是就是将页面划分为不同的区域，不设置宽高时，高度有内容撑开，宽度和父级元素一样宽
section：区段，是用来定义文档的某个区域，章节
nav：标签定义导航链接的部分，提示：如果文档中有“前后”按钮，则应该把它放到nav元素中。
header：标签定义文档的页眉
footer：标签定义文档或节的页脚，页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等
pre：格式标签，被包围在pre元素中的文本通常会保留空格和换行符，而文本也会呈现为等宽字体。
address： 标签定义文档或文章的作者/拥有者的联系信息，元素中的文本通常呈现为斜体，大多数浏览器会在 address 元素前后添加折行
audio：音频使用，背景音乐播放，属性autoplay自动播放，loop循环播放，src要播放的音频，controls为音频提供播放控件，比如播放按钮。preload规定是否在页面加载后载入音频，如果设置了 autoplay 属性，则忽略该属性。
/ 表格标签 /
table：用于显示一个表格，不能设置宽高，宽高被内容撑开，设置宽度而内部的td没有宽度时，td会按照内容长度的比例拉伸
thead：表头，用于显示一列的名称，一般省略不写，浏览器在解析时会自动添加
tbody：表主体，一般省略不写，浏览器在解析时会自动添加
tr：表示一行
th：表头中的第一个单元格
td：表示主体中的单元格，有属性rowspan合并单元格，合并行。colspan合并列
/ 有序列表，无序列表 /
ul：无序列表
ol：有序列表
li：列表项
dl：定义列表，用于描述类表中的项目（dt（dd））
```

### **行内元素 inline**

行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的宽和高就是内容撑开的宽高。。行内元素有以下特点： 

- 每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。 
- 行内元素的高度、宽度、行高不可设置。 
- 元素的宽度就是它包含的文字或图片的宽度，不可改变。

- **行内元素不能设置宽高，和竖直方向的margin、padding ,但左右可以**

常见行内元素有以下：

```
span：是超文本标记语言（HTML）的行内标签，被用来组合文档中的行内元素，span没有固定的格式表现，当对它应用样式时，它会产生视觉上的变化

a：标记网页中的超链接，点击可以打开或者跳转到另一个网页，也可以链接到一个要下载的文件
有属性：href：要链接到的资源地址，target:打开的链接方式，值_blank:表示新打开一个窗口打开目标地址
strong：标记页面中的粗体文本，语义化标签，除了文本加粗之外，还有强调的预期，表示标签中的内容是页面中需要重点关注的内容

b：标记网页中的粗体文本，仅仅将文本加粗，标签中的内容不再强调
s：删除线，仅仅是删除的效果
del：具有删除语义，delete删除
em：强调文本，斜体展示
sup：上标
sub：下标
```

### **行内块级元素 inline-block**

行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。比如input、img就是行内块级元素，它可以设置高宽以及一行多个。具体特点如下：

- 和其他行内或行内块级元素元素放置在同一行上；
- 元素的高度、宽度、行高以及顶和底边距都可设置。

```
img：用于标记网页中的图像 ，有属性src:图片资源路径 ，alt:提示信息 当图片加载失败 ，以指定文本形式代替图片显示
button：按钮
input：输入框，有属性type输入框类型，有属性值（text表示文本输入框，file文件选择器，password密码输入框，email邮箱输入框，number数字输入框，button按钮）。placeholder占位字符，用于提示输入框应该输入的内容。value表示输入框中的内容。name和后台服务器交互时，必须携带name属性，发送请求时的参数名。

单选 type=“radio” 表示一个单选选项处于同一组单选框只能选中一个值，将多个radio的name属性值设置为相同的值
type="checkbox"复选框

label:和input标签绑定到一块使用，有属性for，属性值就是input输入框的id值。checked属性为标签选中状态
select:下拉列表
option:下拉选项
```



## display：table和本身的table有什么区别

Display:table和本身table是相对应的，区别在于，display：table的css声明能够让一个html元素和它的子节点像table元素一样，使用基于表格的css布局，使我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了table那样的制表标签导致的语义化问题。

之所以现在逐渐淘汰了table系表格元素，是因为用div+css编写出来的文件比用table边写出来的文件小，而且table必须在页面完全加载后才显示，div则是逐行显示，table的嵌套性太多，没有div简洁

## css优先级

**不同级别**

1. 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。

2. 作为style属性写在元素内的样式 优先级1000

3. id选择器                                        优先级100

4.	类选择器和伪类和属性 				优先级10

4. 标签选择器和伪元素                     优先级1

5. 通配符选择器                                优先级0

6. 浏览器自定义或继承                    没有优先级

   **总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性**

 1.如果是两种相同优先级 为同一个元素 同一个属性设置 的话，是哪个写在代码靠后 最终就按那个的样式

 2.交集选择器的优先级 所有优先级 加起来 运算 然后比较

 3.并集的话 就是各算各的。

## 使得一个 DOM 元素不显示在浏览器可视范围内

最基本的： 

设置 display 属性为 none，或者设置 visibility 属性为 hidden 

技巧性： 

设置宽高为 0，设置透明度为 0，设置 z-index 位置在-1000 

## **rgba()和 opacity 的透明效果有什么不同** 

rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的 

所有内容的透明度，而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明 效果！） 

## BFC

https://zhuanlan.zhihu.com/p/25321647

https://www.jianshu.com/p/4d1dbb041bb2

BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。

**触发条件 (以下任意一条)**

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)

**BFC 特性及应用**

**1. 同一个 BFC 下外边距会发生折叠**

```html
<head>
div{
    width: 100px;
    height: 100px;
    background: lightblue;
    margin: 100px;
}
</head>
<body>
    <div></div>
    <div></div>
</body>
```

<img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img" style="zoom:33%;" />

从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。

**2. BFC 可以包含浮动的元素（清除浮动）**

我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子

```html
<div style="border: 1px solid #000;">
    <div style="width: 100px;height: 100px;background: #eee;float: left;"></div>
</div>
```

<img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img" style="zoom:33%;" />

由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。

```html
<div style="border: 1px solid #000;overflow: hidden">
    <div style="width: 100px;height: 100px;background: #eee;float: left;"></div>
</div>
```

<img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img" style="zoom:33%;" />

**3. BFC 可以阻止元素被浮动元素覆盖**

先来看一个文字环绕效果：

```html
<div style="height: 100px;width: 100px;float: left;background: lightblue">我是一个左浮动的元素</div>
<div style="width: 200px; height: 200px;background: #eee">我是一个没有设置浮动, 
也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;</div>
```

<img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img" style="zoom:33%;" />

这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 **overflow: hidden**，就会变成：

<img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img" style="zoom:33%;" />

这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。

## 伪类和伪元素的区别

- 伪类表状态
- 伪元素是真的有元素
- 前者单冒号，后者双冒号
- 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素

## 如何实现小于12px的字体效果

> `transform:scale()`这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个`display:inline-block`;

```text
transform: scale(0.7);
```

# js

## defer和async

页面的加载和渲染过程：
1. 浏览器通过HTTP协议请求服务器，获取HMTL文档并开始从上到下解析，构建DOM；
2. 在构建DOM过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件；
3. 样式文件下载完成后，构建CSSDOM；脚本文件下载完成后，解释并执行，然后继续解析文档构建DOM
4. 完成文档解析后，将DOM和CSSDOM进行关联和映射，最后将视图渲染到浏览器窗口

只对外部脚本有效（引入的js文件）

- `defer`加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，`DOMContentLoaded` 事件触发之前完成。
- `async`加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。

![img](https://img2018.cnblogs.com/blog/1237064/201902/1237064-20190225103106193-1835436522.jpg)

- 蓝色线代表网络读取，
- 红色线代表执行时间，这俩都是针对脚本的；
- 绿色线代表 HTML 解析。

## 数据类型

### JS的基本数据类型和引用数据类型

- 基本数据类型：`undefined`、`null`、`boolean`、`number`、`string`、`symbol`
- 引用数据类型：`object`、`array`、`function`

### 判断JS数据类型的四种方法

#### **1、typeof**

typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：

- 值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。
- 引用数据类型：对象(Object)、数组(Array)、函数(Function)。

```js
typeof''; // string 有效
typeof1; // number 有效
typeofSymbol(); // symbol 有效
typeoftrue; //boolean 有效
typeofundefined; //undefined 有效
typeofnull; //object 无效
typeof[] ; //object 无效
typeofnewFunction(); // function 有效
typeofnewDate(); //object 无效
typeofnewRegExp(); //object 无效
```

**注意：**

- 对于基本类型，除 null 以外，均可以返回正确的结果。
- 对于引用类型，除 function 以外，一律返回 object 类型。
- 对于 null ，返回 object 类型。因为在定义typeof时还没有null这种类型。

其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，**只返回了处于其原型链最顶端的 Object 类型**，没有错，但不是我们想要的结果。

#### **2、instanceof**

instanceof 是用来**判断 A 是否为 B 的实例**(不能判断一个对象实例具体属于哪种类型)

表达式为：A instanceof B。如果 A 是 B 的实例，则返回 true,否则返回 false。 

在这里需要特别注意的是：**instanceof 检测的是原型**，我们用一段伪代码来模拟其内部执行过程：

```js
instanceof (A,B) = {
    varL = A.__proto__;
    varR = B.prototype;
    if(L === R) {
        // A的内部属性 __proto__ 指向 B 的原型对象
        return true;
    }
    return false;
}
```

从上述过程可以看出，**当 A 的 proto 指向 B 的 prototype 时，就认为 A 就是 B 的实例**，我们再来看几个例子：

```js
[] instanceof Array; // true
{} instanceof Object;// true
newDate() instanceof Date;// true
 
function Person(){};
new Person() instanceof Person;
 
[] instanceof Object; // true
newDate() instanceof Object;// true
newPerson instanceof Object;// true
```

**虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例**

我们来分析一下 [ ]、Array、Object 三者之间的关系：

从 instanceof 能够判断出 [ ].__proto__  指向 Array.prototype，而 Array.prototype.__proto__ 又指向了Object.prototype，最终 Object.prototype.__proto__ 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：

![img](https://images2015.cnblogs.com/blog/849589/201601/849589-20160112232510850-2003340583.png)

从原型链可以看出，[] 的 __proto__  直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，**instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。**

#### **3、constructor**

当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后**在 prototype上添加一个 constructor 属性，并让其指向 F 的引用**。如下所示：

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125250566-1896556617.png)

当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 **F 原型上的 constructor 传递到了 f 上**，因此 f.constructor == F

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125714941-1649387639.png)

可以看出，**F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上**， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。

同样，JavaScript 中的内置对象在内部构建时也是这样做的：

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508131800457-2091987664.png)

**细节问题：**

> - null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。
>
> - 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object

![img](https://images2015.cnblogs.com/blog/849589/201705/849589-20170508132757347-1999338357.png)

为什么变成了 Object？

因为 **prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。**

**因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改**。

#### **4、toString**

toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。

对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。

```
Object.prototype.toString.call('') ;   // [object String]
Object.prototype.toString.call(1) ;    // [object Number]
Object.prototype.toString.call(true) ; // [object Boolean]
Object.prototype.toString.call(Symbol()); //[object Symbol]
Object.prototype.toString.call(undefined) ; // [object Undefined]
Object.prototype.toString.call(null) ; // [object Null]
Object.prototype.toString.call(newFunction()) ; // [object Function]
Object.prototype.toString.call(newDate()) ; // [object Date]
Object.prototype.toString.call([]) ; // [object Array]
Object.prototype.toString.call(newRegExp()) ; // [object RegExp]
Object.prototype.toString.call(newError()) ; // [object Error]
Object.prototype.toString.call(document) ; // [object HTMLDocument]
Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用
```



## 图片的懒加载和预加载

预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。

懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。

懒惰实现方式：
 1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.
 2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。
 3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。

两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。
懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 

## 原型和原型链

### 原型

> ①所有`引用类型`都有一个`__proto__(隐式原型)`属性，属性值是一个普通的对象
> ②所有`函数`都有一个`prototype(原型)`属性，属性值是一个普通的对象
> ③所有`引用类型的__proto__`属性`指向`它`构造函数的prototype`

```js
var a = [1,2,3];
a.__proto__ === Array.prototype; // true
```

<img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img" style="zoom:67%;" />

- instanceof

  ```js
  function a(){}
  let b = new a()
  //判断实例的构造函数
  b instanceof a
  true
  ```

  

- ```js
  function a(){}
  let b = new a()
  b.__proto__.constructor === a
  //true
  ```

  

### 原型链

> 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的`__proto__`隐式原型上查找，即它的构造函数的`prototype`，如果还没有找到就会再在构造函数的`prototype`的`__proto__`中查找，这样一层一层向上查找就会形成一个链式结构，我们称为`原型链`。

举例，有以下代码

```js
function Parent(month){
    this.month = month;
}

var child = new Parent('Ann');

console.log(child.month); // Ann
console.log(child.father); // undefined
```

在child中查找某个属性时，会`执行下面步骤`：

![这里写图片描述](https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

`访问链路`为：

![这里写图片描述](https://img-blog.csdn.net/20180620155400807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

> ①一直往上层查找，直到到null还没有找到，则返回`undefined`
> ②`Object.prototype.__proto__ === null`
> ③所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象

### tips

- 每个函数都有一个原型对象，该原型对象有一个constructor属性，指向创建对象的函数本身。

  ```js
  function A(){}
  let b = new A()
  b.__proto__.constructor === A ===A.prototype.constructor
  b.constructor == A   //b.__proto__.constructor ===b.constructor，原型上的 constructor 传递到了 b上
  //true
  ```

### 原型继承

https://blog.csdn.net/qq_42926373/article/details/83149347

 在传统的基于Class的语言如Java、C++中，继承的本质是扩展一个已有的Class，并生成新的Subclass。

 但是，JavaScript由于采用原型继承，我们无法直接扩展一个Class，因为根本不存在Class这种类型。

```js
function Person (name) {
      // 属性
      this.name = name;
      // 实例方法
      this.sleep = function(){
        console.log(this.name + '正在睡觉！');
      }
    }
    // 原型方法
    Person.prototype.eat = function(food) {
      console.log(this.name + '正在吃：' + food);
    };
```

#### 组合继承

 构造继承与原型继承组合 

```js
// 创建子类、添加子类属性。
	function arrange(name){
      Person.call(this,name) // 执行父构造，将This指向本身，拉取父私有属性；
    }
```

但是，调用了arrange构造函数不等于继承了Person，arrange创建的对象的原型是：

```
new arrange() ----> arrange.prototype ----> Object.prototype ----> null
```

必须想办法把原型链修改为：

```
new arrange() ----> arrange.prototype ----> Person.prototype ----> Object.prototype ----> null
```

```js
// 创建子类、添加子类属性。
	function arrange(name){
      Person.call(this,name) // 执行父构造，将This指向本身，拉取父私有属性；
    }
    // 将父类实例赋值给子类原型对象
    arrange.prototype = new Person(); // 直接拉取父类实例继承原型
    // 将constructor指向本身，保证原型链不断。
    arrange.prototype.constructor = arrange;
    
    // 下面这个方法会替换整个原型对象
    // arrange.prototype = {
    //   init:function(){
    //     console.log('我会替换整个原型')
    //   }
    // }
    // 必须在原型实例继承之后，在给子类原型添加方法，或重写方法，请使用以下方法
    arrange.prototype.eat = function() {
      console.log(this.name + '重写了此方法');
    };
    arrange.prototype.addFn = function(){
      console.log(this.name + '添加了新方法' );
    }
    
    var newObj = new arrange('王五');
    console.log(newObj)
    newObj.eat(); // 王五重写了此方法
    newObj.addFn(); // 王五添加了新方法
```

#### 原型链继承

```js
//将父类实例赋值给子类原型对象

	// 创建子类、添加子类属性。
   function arrange(name){
     this.name = name;
     this.goShop = function(food){
       console.log(name + '叫你去买'+ food)
     }
   }
   // 将父类实例赋值给子类原型对象
   arrange.prototype = new Person();
   // 将constructor指向本身，保证原型链不断。
   arrange.prototype.constructor = arrange; 

   //创建arrange新实例，也是Person实例;
   var newObj = new arrange('李四'); 
   console.log(newObj instanceof Person)  //true
   console.log(newObj instanceof arrange) //true
   // 原型链继承成功，可以访问父类所有属性;
   console.log(newObj)
   console.log(newObj.name) // 李四
   newObj.sleep(); // 李四正在睡觉！
   newObj.eat('苹果'); // 李四正在吃：苹果
   newObj.goShop('香蕉'); // 李四叫你去买香蕉
```

#### 构造继承

执行父构造，将This指向本身，拉取父私有属性

```js
// 创建子类、添加子类属性。
function arrange(name){
  Person.call(this,name) // 执行父构造，将This指向本身，拉取父私有属性；
}
arrange.prototype.getName = function(){
  console.log('我叫' + this.name)
}
var newObj = new arrange('李四');
console.log(newObj)
console.log(newObj.name) //李四
newObj.sleep() // 李四正在睡觉！
newObj.getName() //我叫李四
```
## 事件

### 事件流

> `W3C`中定义事件的发生经历三个阶段：捕获阶段（`capturing`）、目标阶段（`targetin`）、冒泡阶段（`bubbling`）

- 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发
- 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发
- 阻止冒泡：在`W3c`中，使用`stopPropagation()`方法；在IE下设置`cancelBubble = true`
- 阻止捕获：阻止事件的默认行为，例如`click - <a>`后的跳转。在`W3c`中，使用`preventDefault()`方法，在`IE`下设置`window.event.returnValue = false`

addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false（默认），表示在冒泡阶段调用事件处理程序。

### 事件委托

简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。

举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。

好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。可以大量节省内存占用，减少事件注册

###  onload和ready

document.ready和onload的区别——JavaScript文档加载完成事件
页面加载完成有两种事件:

- ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）
- onload，指示页面包含图片等文件在内的所有元素都加载完成。

**jq**

- `window.onload()`方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。

- `$(document).ready()==DOMContentLoaded`是`DOM`结构绘制完毕后就执行，不必等到加载完毕

  ```js
  $(function(){
  });//jq ready()的简写
  $(document).ready(function(){
  })
  ```

##  防抖/节流

https://www.jianshu.com/p/c8b86b09daf0

防抖和节流是针对**响应跟不上触发频率**这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。

### 防抖

当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来**之前**，又一次触发了事件，就重新开始延时

![img](https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144209623-862434090.jpg)

#### **非立即执行版**

```jsx
function debounce(func, wait) {
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        
        timeout = setTimeout(() => {
            func.apply(context, args)
        }, wait);
    }
}
```

非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

![img](https://upload-images.jianshu.io/upload_images/4842858-1f6389b9dd9e5ef9.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1134/format/webp)

#### **立即执行版**

```jsx
function debounce(func,wait) {
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);

        let callNow = !timeout;
        timeout = setTimeout(() => {
            timeout = null;
        }, wait)

        if (callNow) func.apply(context, args)
    }
}
```

立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。

![img](https://upload-images.jianshu.io/upload_images/4842858-067785c056f182d8.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1140/format/webp)

将非立即执行版和立即执行版的防抖函数结合起来，实现最终的双剑合璧版的防抖函数。

#### **双剑合璧版**

```jsx
/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */
function debounce(func,wait,immediate) {
    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(() => {
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }
}
```

### 节流

**连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率**

![img](https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144342847-660853255.jpg)

#### 时间戳版

```jsx
function throttle(func, wait) {
    let previous = 0;
    return function() {
        let now = Date.now();
        let context = this;
        let args = arguments;
        if (now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```

![img](https://upload-images.jianshu.io/upload_images/4842858-80423b8898a27732.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1140/format/webp)

可以看到，在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。

#### 定时器版:

```jsx
function throttle(func, wait) {
    let timeout;
    return function() {
        let context = this;
        let args = arguments;
        if (!timeout) {
            timeout = setTimeout(() => {
                timeout = null;
                func.apply(context, args)
            }, wait)
        }

    }
}
```

![img](https://upload-images.jianshu.io/upload_images/4842858-bf2ed4c8ed4f0ec0.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1136/format/webp)

可以看到，在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。

#### 双剑合璧版

```tsx
/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */
function throttle(func, wait ,type) {
    if(type===1){
        let previous = 0;
    }else if(type===2){
        let timeout;
    }
    return function() {
        let context = this;
        let args = arguments;
        if(type===1){
            let now = Date.now();

            if (now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        }else if(type===2){
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
        }
    }
}
```



# 框架

## MVC和MVVM

https://www.pianshen.com/article/3716256399/

### MVC

MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码。

- **Model（模型）** ：应用程序中用于处理应用程序数据逻辑的部分

  通常模型对象负责在数据库中存取数据。

- **View（视图）** ：  应用程序中处理数据显示的部分

  通常视图是依据模型数据创建的。

- **Controller（控制器）**：应用程序中处理用户交互的部分。

  通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

  <img src="https://user-gold-cdn.xitu.io/2019/5/27/16af72cd60c25062?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" />

> 1.View传送指令到Controller。

> 2.Controller完成业务逻辑后改变Model状态。

> 3.Model将新的数据发送至View,用户得到反馈。            

 **优点**

**耦合性低**       

视图层和业务层分离，这样就允许更改视图层代码而不用重新编译模型和控制器代码

**重用性高**

MVC模式允许使用各种不同样式的视图来访问同一个服务器端的代码，因为多个视图能共享一个模型

**生命周期成本低**

MVC使开发和维护用户接口的技术含量降低。

**部署快**

使用MVC模式使开发时间得到相当大的缩减，它使程序员（Java开发人员）集中精力于业务逻辑，界面程序员（HTML和JSP开发人员）集中精力于表现形式上。

**可维护性高**

分离视图层和业务逻辑层也使得WEB应用更易于维护和修改。

**缺点**

**1.m层和v层直接打交道，导致这两层耦合度高**

**2.因为所有逻辑都写在c层，导致c层特别臃肿**

### MVVM

<img src="https://user-gold-cdn.xitu.io/2019/5/27/16af920a988c5f66?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:50%;" />

**Model-View-ViewModel**即模型-视图-视图模型。

- 模型：后端传递的数据。

- 视图：所看到的页面。

- 视图模型：mvvm模式的核心，它是连接view和model的桥梁。

  它有两个方向：

  - 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：**数据绑定**
  - 二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：**DOM 事件监听**

![img](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=32561255,2826043542&fm=173&app=25&f=JPEG?w=500&h=100&s=C8F78852C4B2FE207E66C9D20200D0AA)

**总结**：**在MVVM的框架下视图和模型是不能直接通信的**。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的**双向绑定**。

### 区别

mvc 和 mvvm 其实区别并不大。都是一种设计思想，主要区别如下：

1. mvvm 通过数据来驱动视图层的显示而不是节点操作。
2. MVC除了简单的 Model、View 以外的所有部分都被放在了 Controller 里面。Controller 负责显示界面、响应用户的操作、网络请求以及与 Model 交互。这就导致了 Controller：
   - 逻辑复杂，难以维护。
   - 和 View 紧耦合，无法测试。
3. MVVM与MVC**最大的区别**就是：MVC中大量的DOM 操作(主要是手动操作dom元素去改变view的显示)使页面渲染性能降低，加载速度变慢，影响用户体验。MVVM实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变。

## 虚拟DOM

### **背景**

前端主流框架 vue 和 react 中都使用了虚拟DOM（virtual DOM）技术，因为渲染真实DOM的开销是很大的，性能代价昂贵，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，而我们只需要更新修改过的那一小块dom而不要更新整个dom，这时使用diff算法能够帮助我们。

**DOM**

DOM全称`文档对象模型`，本质也是一个JS对象。每操作一次DOM都会对页面进行重新渲染，且新生成一颗DOM树。

DOM的本质： 浏览器中的概念，用js对象来表示页面上的元素，并提供操作DOM对象的API

**VDOM**

虚拟dom，通过JS模拟DOM中的真实节点对象，再通过特定的render方法将其渲染成真实的DOM节点。

vdom的本质:是框架中的概念，是程序员用js对象来模拟页面上的DOM和DOM 的嵌套

### **diff算法**



![img](https://user-gold-cdn.xitu.io/2020/5/2/171d3ca4cc6af69a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

现有一个真实的`DOM`，首先会映射为虚拟`DOM`，这个时候，我们删除了最后一个`p`节点和`son2`的节点，得到了新的一个虚拟`DOM`，新的`vdom`会和旧的`vdom`进行差异对比，得到了`pathes`对象，之后，对旧的真实`dom`进行操作，得到了新的`DOM`。

**diff策略**

React用 三大策略 将O(n^3)复杂度 转化为 O(n)复杂度

- 策略一（tree diff）：新旧DOM树，逐层对比的方式
  DOM节点跨层级的移动操作特别少，可以忽略不计。

   ![img](https://images2018.cnblogs.com/blog/1455367/201808/1455367-20180808083547179-1944470540.jpg) 

  只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。

  当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。

  这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。

- 策略二（component diff）：
  拥有相同类的两个组件生成相似的树形结构， 拥有不同类的两个组件 生成不同的树形结构。

- 策略三（element diff）：
  对于同一层级的一组子节点，通过唯一id区分。

## **响应式实现原理**

**主流框架实现双向绑定（响应式）的做法**

**1. 脏值检查：** angular是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply()在 Angular 中组件是以树的形式组织起来的，相应地，检测器也是一棵树的形状。当一个异步事件发生时，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查，这种检查方式的性能存在很大问题。

**2.观察者-订阅者（数据劫持）：vue**Observer 数据监听器，把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty()方法把这些属性全部转成setter、getter方法。当data中的某个属性被访问时，则会调用getter方法，当data中的属性被改变时，则会调用setter方法。Compile指令解析器，它的作用对每个元素节点的指令进行解析，替换模板数据，并绑定对应的更新函数，初始化相应的订阅。Watcher 订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。执行流程如下：

![img](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1581589677,2197583542&fm=173&app=25&f=JPEG?w=640&h=342&s=5926347301CA614B4E65C0CA0000E0B3)

从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。因为VUE使用Object.defineProperty方法来做数据绑定，而这个方法又无法通过兼容性处理，所以Vue 不支持 IE8 以及更低版本浏览器。另外，查看vue原代码，发现在vue初始化实例时， 有一个proxy代理方法，它的作用就是遍历data中的属性，把它代理到vm的实例上，这也就是我们可以这样调用属性：vm.aaa等于vm.data.aaa。

## React与vue.js的对比

https://juejin.cn/post/6844903974437388295

https://cn.vuejs.org/v2/guide/comparison.html

https://zhuanlan.zhihu.com/p/100228073

### 相同点

- 都是用了Virtual DOM。
- 都提供了响应式和组件化的视图组件。
- 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关库。

### vue

- 响应式+vdom

- 响应式，实现数据的双向绑定

- vue保留了html、css、js分离的写法，模板就是普通的html。

- 不够动态，语法限制。优点就是优化空间大

  因为已经定义好了类似v-for,v-if语法
  
- Vue中，组件的依赖是在渲染的过程中自动追踪的，所以系统能准确知晓哪个组件确实需要被重新渲染。

### react

- 没有响应式，只有vdom，计算diff.

- 数据是单向数据流，所以需要状态管理器**useState**。
- react是没有模板的，直接就是一个渲染函数，它中间返回的就是一个虚拟DOM树，React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即'all in js'。JSX实际就是一套使用XML语法，用于让我们更简单地去描述树状结构的语法糖。
- 动态的，因为全部都是用js编写，可以根据开发者进行编写。但是不利于优化，每个开发者编写代码都有自己的风格。
- React中，当某组件的状态发生改变时，它会以该组件为根，重新渲染整个组件子树

### 模块化和组件化

**模块化**：从 **代码** 的角度，去分析问题，把我们编程时候的业务逻辑，分割到不同的模块中来进行开发，这样能够**方便代码的重用**；

**组件化**：从 **UI** 的角度，去分析问题，把一个页面，拆分为一些互不相干的小组件，随着我们项目的开发，我们手里的组件会越来越多，最后，我们如果要实现一个页面，可能直接把现有的组件拿过来进行拼接，就能快速得到一个完整的页面， 这样方**便了UI元素的重用**；**组件是元素的集合体**；

Vue是如何实现组件化的：.vue 组件模板文件，浏览器不识别这样的.vue文件，所以，在运行前，会把 .vue 预先编译成真正的组件；

 + template： UI结构
 + script： 业务逻辑和数据
 + style： UI的样式

React如何实现组件化：React的组件，并没有把一个组件 拆分为 三部分（结构、样式、业务逻辑），而是全部使用JS来实现一个组件的；（也就是说：结构、样式、业务逻辑是混合在JS里面一起编写出来的）

### 开发团队方面

+ React是由FaceBook前端官方团队进行维护和更新的；因此，React的维护开发团队，技术实力比较雄厚；
+ Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个小团队进行相关的维护和开发；

### 移动APP开发体验方面

+ Vue，结合 Weex 这门技术，提供了 迁移到 移动端App开发的体验（Weex，目前只是一个 小的玩具， 并没有很成功的 大案例；）
+ React，结合 ReactNative，也提供了无缝迁移到 移动App的开发体验（RN用的最多，也是最火最流行的）；

## vue

### vue渐进式

在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统（components）、客户端路由（vue-router）、大规模状态管理（vuex）来构建一个完整的框架。Vue从设计角度来讲，虽然能够涵盖所有这些内容，但是你并不需要一上手就把所有东西全用上，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。声明式渲染和组建系统是Vue的核心库所包含内容，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是**Vue的使用方式**，同时也体现了Vue的设计的理念。

### Vue的双向绑定数据的原理

https://cn.vuejs.org/v2/guide/reactivity.html

- `vue.js` 则是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调

```js
const data = {};
const input = document.getElementById('input');
Object.defineProperty(data, 'text', {
  set(value) {
    input.value = value;
    this.value = value;
  }
});
input.onChange = function(e) {
  data.text = e.target.value;
}
```

### v-if vs v-show

1.手段：v-if是通过控制dom节点的存在与否来控制元素的显隐；v-show是通过设置DOM元素的display样式，block为显示，none为隐藏；

2.编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；

3.编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译（编译被缓存？编译被缓存后，然后再切换的时候进行局部卸载); v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；

4.性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；

`v-if` 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

`v-if` 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

相比之下，`v-show` 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

一般来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

## SPA、SSR、CSR

https://zhuanlan.zhihu.com/p/299598903

https://zhuanlan.zhihu.com/p/138356519

### 一、SPA

single page web application，单页Web应用，就是只有一张Web页面的应用，**与后台仅仅是数据的交互，不会再请求其它页面**。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。

典型编写SPA的前端框架：React、Angular、Vue。

- 概念：
  - 网站的效果都是显示在`一个静态页面`中的
  - 在页面切换时，其实并没有从一个页面中跳转到另一个页面中，只是通过 `js` 动态的将内容进行了修改
  - 在网站的源代码中是看不到任何数据的

**特点：**

- 优点：
  - 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
  - 基于上面一点，SPA 相对对服务器压力小；
  - 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；
- 缺点：
  - 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
  - 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；（vue-router 已经解决了这个问题）
  - SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。
    - 因为单页应用的所有内容都在 index.html 中，页面的切换是通过 js 动态切换的
    - 由于所有的内容切换都是通过 js 动态切换的，所以在页面的源代码中是看不到任何的数据的
    - 由于源代码中看不到任何数据，这是非常不利于 SEO 的，所以我们说 SPA 在 SEO 上有其天然的弱势。
    - vue 中的 SSR 就可以用来解决这个问题。

### 二、SSR

Server Side Rendering，服务器端渲染，传统的渲染方式，由服务端把渲染的完整的页面吐给客户端。这样减少了一次客户端到服务端的一次http请求，加快相应速度，一般用于首屏的性能优化。

典型服务器端渲染的例子就是jsp、asp、php等各种后台模板生成的页面，前端会直接拿到整张页面，不用自己过多的去拼接DOM。

<img src="https://pic1.zhimg.com/80/v2-b4c8866154ac2158d887e04e1e73c2f8_720w.jpg" alt="img" style="zoom:50%;" />

<img src="https://pic3.zhimg.com/80/v2-26e5fd8c489d700be758d43eba801f26_720w.jpg" alt="img" style="zoom:50%;" />

**渲染流程**：

- 阶段一：浏览器请求url --> 服务器路由分析、执行渲染 --> 服务器返回index.html(实时渲染的内容，字符串) --> 浏览器渲染
- 阶段二：浏览器请求bundle.js --> 服务器返回bundle.js --> 浏览器路由分析、生成虚拟DOM --> 比较DOM变化、绑定事件 --> 二次渲染

尽管服务器渲染第一阶段的流程图很长，但是因为服务器渲染速度很快，因此实际耗时与客户端渲染几乎相同。
第一阶段结束时，服务器端返回渲染结果，用户即可看到首屏。而对于客户端渲染，需要等待一次脚本下载时间，以及在客户端的渲染时间。由于客户端的硬件以及网络条件的差异，这两段时间开销可能十分显著。
客户渲染与服务器渲染第二阶段基本一致。所不同的是，服务器渲染流程中，在客户端生成vdom后，并不会重新渲染，而是比较现有dom的checksum来决定是否重新渲染。

**原理**：基于`Virtual DOM`实现了客户端与服务端的同构渲染。

- 在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；
- 在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。

### 三、CSR

客户端渲染(Client Side Render)。渲染过程全部交给浏览器进行处理，服务器不参与任何渲染。页面初始加载的HTML文档中无内容，需要下载执行JS文件，由浏览器动态生成页面，并通过JS进行页面交互事件与状态管理。

<img src="https://pic4.zhimg.com/80/v2-6a8fe007fcf263214074f72ea3971b87_720w.jpg" alt="img" style="zoom:67%;" />

**渲染流程**：浏览器请求url --> 服务器返回index.html(空body、白屏) --> 再次请求bundle.js、路由分析 --> 浏览器渲染

bundle.js体积越大，会导致浏览器白屏时间越长。

### 四、SSR与CSR对比

CSR与SSR的区别简而言之，就是数据拼接HTML字符串这件事放在服务端还是客户端。

![img](https://pic2.zhimg.com/80/v2-e12ce3a06497fcffaa51d3a720b46649_720w.jpg)

## 前端架构 JAMStack

https://segmentfault.com/a/1190000022434868

http://blog.yixao.net/tech/14278.html

JAMStack中的JAM其实是三个词的缩写，它们分别是JavaScript, APIs以及Markdown。而Stack用中文的说法就是技术栈（Tech Stack），也就是我们在构建应用的时候具体使用到的技术的集合。

JAMStack 指的是一套用于**构建现代网站的技术栈**

**JavaScript**

在JAMStack的概念中，JavaScript指的是在客户端（client）实现动态网页效果的JavaScript，它既可以是React和Vue这种Web框架，也可以是原生的JavaScript。它主要负责网页动态的内容。

**APIs**

这里的API和我们平时开发调用的API是一样的。JAMStack的Web应用会通过JavaScript给后端API发送AJAX请求或者GraphQL query，后端API会以某种格式（一般是JSON）返回数据给前端来实现一些用户交互。

**Markdown**

[Mardown](https://zhuanlan.zhihu.com/p/134662152/markdown_百度百科)是一种轻量级的标记语言。在JAMStack的世界中，Markdown类型的文件通常是用来作为生成静态HTML文件的数据源。有用过[hexo](https://zhuanlan.zhihu.com/p/134662152/Hexo)写博客的同学对这个概念肯定不会陌生，因为hexo的原理就是将我们编写的Markdown文件根据我们指定的主题或者模板生成一些静态的HTML然后托管在github pages或者其它类似的静态网站服务器来供别人访问的。

除了Markdown文件之外，JAMStack的静态数据源还可以是其它的东西，例如我们后面说到的[Gatsby](https://www.gatsbyjs.org/)（JAMStack的一种实现）就允许通过插件的方式使用SQL直接读取数据库的内容来生成静态页面。

**1. 使用网站生成器预渲染整个网站**

整个网站在部署前，会被**网站生成器（SSG, Static Site Generators）**构建和优化为一系列的静态页面和静态资源，这样整个网站可以被托管在 CDN 上，加载速度得到最大程度地优化，安全性也得到保障。

**2. 使用 Headless CMS（无头 CMS）管理动态内容**

如果想要网站承载动态内容，那么可以接入各种 Headless CMS（无头 CMS），这些 CMS 系统会对外提供 API，网站生成器可以调用这些 API 拉取数据，**将动态数据渲染成为静态页面**。

**3. 使用 HTTP API 增强网站的功能**

在登录注册、评论框等需要后端支持的能力上，Jamstack 网站通常会使用微服务提供的 HTTP API，或者一些第三方的 BaaS（后端即服务）能力。

除了以上三个主要特点以外，Jamstack 的网站通常还会有下面的特性：

- 全站托管于 CDN 上
- 原子化发布（每次发布都是一次全量、原子性的发布）
- 灵活的文件缓存策略
- 基于 Git 的全自动构建、部署流程

### 优势

**1. 相比于纯静态网站**

纯静态的网站很难承载动态的内容，内容改动通常都是要直接修改页面的代码，这**对于内容管理人员（很可能是非技术人员）来说非常不友好**。

而 Jamstack 的网站，通常会使用无头 CMS 来将内容管理抽离出去，内容管理人员可以直接在这些 CMS 系统的 UI 界面上进行内容修改，然后触发整个网站的重新预渲染，以及部署。

**2. 相比于传统动态网站**

这里的“传统动态网站”指的是用 PHP、Ruby On Rails、JSP 甚至更古老的 CGI 构建的网站，以及基于这些技术产生的建站工具比如 WordPress、Drupal 等等。

这些传统网站的劣势在于，它们在运行时都需要一个实时在线的服务端，这些服务端负责处理请求、渲染页面，这就很大程度上降低了**服务的可伸缩性和稳定性**（想象一下，你迁移扩容一个在线的 WordPress 网站有多么麻烦）。

Jamstack 由于是直接使用 CDN 分发静态的页面，完全不需要渲染页面的服务，网站的伸缩性、稳定性可以得到最大的保障。

**3. 相比于单页应用（SPA）**

大概五年前，随着各种前端框架的成熟，越来越多的业务逻辑迁移到了前端处理，这也就诞生了 SPA 的概念，也就是整个网站的 UI 层，由浏览器端来完全接管。得益于 HTML5 和现代浏览器的一系列特性，这样的做法可以保证最好的用户体验。

但是 SPA 最大的问题在于它**对 SEO 不友好**，因为 SPA 的页面内容都是靠浏览器异步获取、渲染的，虽然 Google 为首的大多数搜索引擎渐渐地支持爬取 SPA 的内容，但是这依然是一个隐患。另外，由于 SPA 需要异步加载数据，首屏内容需要在在加载、运行 JS 之后才能看到，也给用户打开网站的体验带来影响。

而 Jamstack 的页面本质上都是托管在 CDN 上的静态页面，搜索引擎可以直接爬取这些静态内容，首屏与静态网站一样，可以直接展示内容，而不需要等到加载运行 JS 之后。

**4. 相比于 SSR 应用**

目前市面上的几大前端框架都支持了服务器端渲染，也就是 SSR 的概念，这些 SSR 技术也成为了 Jamstack 的基础之一。但是典型的 SSR 应用和传统动态网站一样，都是需要一个在线的服务来渲染页面，同样**会有运维和安全性上的风险**。

Jamstack 从技术角度上讲，可以认为是 SSR 技术的进阶，也就是提前用 SSR 预渲染大部分页面，然后将这些页面部署在 CDN 上，随后根据网站的数据变化，重复预渲染、部署即可。

当然，Jamstack 也不是万金油，不可能完美适应所有场景，Jamstack 最适合一些**内容更新不太频繁的网站**（比如新闻、电商、文档）。它不适合 Feeds 流、聊天室、论坛、个性化推荐这样高度动态化的网站，以及邮箱、编辑器这样偏重型的 Web 应用。

<<<<<<< HEAD
# 框架模拟

## 虚拟DOM

https://mp.weixin.qq.com/s/V_YWbswXoea-Em-l_K97sw

# 框架源码

## vue

https://mp.weixin.qq.com/s/V_YWbswXoea-Em-l_K97sw

了解Vue设计理念及手写实现https://www.kaikeba.com/open/item?lpsc=216875

《Vue3响应式原理剖析》http://t.kuick.cn/ZSMD

《Vue源码剖析之整体流程》http://t.kuick.cn/ZSMf

vue-router前端路由原理剖析：https://t.kaikeba.com/85FV

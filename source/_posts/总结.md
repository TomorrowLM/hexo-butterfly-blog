---
slug: 总结
title: 总结
description: 关于一些实战常用的html,css,es5的总结
keywords: html css es5 jq
category: 总结
tags: [总结]
author: liming
date: 25-September-2020
sticky: 1
swiper_index: 3
swiper_desc: 关于一些实战常用的html,css,es5的总结！
cover: https://i0.hippopx.com/photos/457/88/1021/microphone-boy-studio-screaming-preview.jpg
---

# html

## SEO

- 合理的`title`、`description`、`keywords`：搜索对着三项的权重逐个减小，`title`值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面`title`要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description`有所不同；`keywords`列举出重要关键词即可
- 语义化的`HTML`代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
- 重要内容`HTML`代码放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容不要用`js`输出：爬虫不会执行js获取内容
- 少用`iframe`：搜索引擎不会抓取`iframe`中的内容
- 非装饰性图片必须加`alt`
- 提高网站速度：网站速度是搜索引擎排序的一个重要指标

## html标签

文本加粗标签   <strong></strong> <b></b>> 工作里尽量使用strong

文本倾斜标签	<em></em>> 	<i></i>>	工作里尽量使用em

删除线标签	<del></del>>	<s></s>>	工作里尽量使用del

下划线标签	<ins></ins>>	<u></u>	  工作里尽量使用ins

 <sup>上标</sup>  <sub>下标</sub>

超链接a:属性target,'_self'在自身页面打开，'_blank'打开一个新页面

 <base target="_blank">  让所有的超链接都在新窗口打开

锚链接：<p id="sd"></p>	<a href="#sd">回到顶部</a>

关键字：<mate name="keyword" content="">

网页描述:<mate name="description" content="">

网页重定向：<mate http-equiv="refresh" content="5;http://www.baidu.com">

设置icon图标：<link rel="icon" href="xxx.ico">

img:`title`当鼠标滑动到元素上的时候显示,`alt`是`<img>`的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片


## 表格

    <table>
        <caption>23</caption>
        <thead>
            <th>1</th>
            <th>2</th>
            <th></th>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td>1</td>
                <td>1</td>
            </tr>
        </tbody>
    </table>

cellspacing：表示各单元格之间的空隙

cellpadding：表示单元格内容与单元格边界之间的距离

border-collapse:collapse;边框合并  

colspan=”2” 合并同一行上的单元格

rowspan=”2” 合并同一列上的单元格

```
table    { display: table }
tr       { display: table-row }
thead    { display: table-header-group }
tbody    { display: table-row-group }
tfoot    { display: table-footer-group }
col      { display: table-column }
colgroup { display: table-column-group }
td, th   { display: table-cell }
caption  { display: table-caption }
HTML Table是指使用原生的<table>标签，而CSS Table是指用CSS属性模仿HTML 表格的模型。
display:table最常见的例子了。对于动态高度的元素，有了它，就可以实现真正的垂直（居中）对齐。
```

## 表单

<fieldset></fieldset>  对表单信息分组

<legend>分组</legend>   表单信息分组名称

<optgroup label=""></optgroup>  对下拉列表select进行分组。Label=”” 分组名称。

```
  <fieldset>

​    <legend>信息分组名称</legend>

​    <select name="" id="">

​      <optgroup label="1">

​        <option value="1">1</option>

​        <option value="1">1</option>

​      </optgroup>

​    </select>

  </fieldset>
```

**表单元素属性**

- value 用于大部分表单元素的内容获取(option除外)
- type 可以获取input标签的类型(输入框或复选框等)
- disabled 禁用属性
- checked 复选框选中属性
- selected 下拉菜单选中属性

## **iframe**

实际应用中，iframe可以当作一个子模块，像vue单一应用那样，选择菜单栏的选项，就切换页面相应的子模块。而使用原生的话，选择菜单栏的选项，就**请求**相应的iframe模块。

> 如何知道是iframe模块？
>
> 右键点击，出现重新加载框架，点击重新加载框架，就局部加载该iframe模块

![iframe](C:\Users\17355\Desktop\doc\document\img\总结\iframe.png)

**注意如果要在iframe子页面获取父页面元素和window对象**,因为iframe不存在公共的模块

```js
$(window.parent.document).find('selector').attr('XXX')
```

【iframe】同一个页面两个iframe，相互访问内部内容

```
1.页面b.html访问页面a.html中的laydateIn1
window.parent.$(".panel-body")[0].contentWindow.$("#laydateIn1")

2.页面a.html访问页面b.html中的c_stock
window.parent.$(".panel-body")[1].contentWindow.$("#c_stock").val()

3.重新加载iframe
window.parent.$("iframe")[0].contentWindow.location.reload(true);
```

## html5标签

```html
<!-- 数据列表 -->
<input type="text" list="input_list">
  <datalist id="input_list">
    <option value="laoma"></option>
    <option value="lisi"></option>
</datalist>
  
<!--点击展示详细信息-->
<details>
    <summary>HTML 5</summary>
    <h1>This slide deck teaches you everything you need to know about HTML 5.</h1>
</details>

<!--小窗口-->
<iframe src="https://www.baidu.com" frameborder="0"></iframe>

<!--进度条-->
<progress>working...</progress>
<meter min="0" max="100" low="40" high="90" optimum="100" value="91">A+</meter>
```

```html
<form action="#" method="">
    <input type="text">
    <input type="image" src="toy.png">
    <input type="submit">
    <!-- file text password radio checkbox button image submit reset select button -->
    <input type="date">
    <input type="color">
    <input type="range" min="0" max="10" step="1" value="2">
    <hr>
    <input type="text" required>
    <input type="email" value="some@email.com">
    <input type="date" min="2010-08-14" max="2011-08-14" value="2010-08-14">
    <input type="range" min="0" max="50" value="10">
    <input type="search" results="10" placeholder="Search...">
    <input type="tel" placeholder="(555) 555-5555" pattern="^\(?\d{3}\)?[-\s]\d{3}[-\s]\d{4}.*?$">
    <input type="color" placeholder="e.g. #bbbbbb">
    <input type="number" step="1" min="-5" max="10" value="0">
  </form>
```

## tips

**标签语义化**：尽可能少的使用无语义的标签div和span；

**Charset  编码**：

Ascll	Ansi	Unicode  Gbk 	Gb2312	Big5	Utf-8  通用字符集

# css

## class命名规范

https://www.cnblogs.com/yyzyou/p/7920023.html

### 整体结构

头：header

页面主体：main

内容：content/container

侧栏：sidebar

栏目：column

页面外围控制整体布局宽度：wrapper

方向：left right center top bottom

内部： in

尾：footer

版权：copyright

### 菜单和导航

导航：nav

　　主导航：mainbav

　　子导航：subnav

　　顶导航：topnav

　　边导航：sidebar

　　左导航：leftsidebar

　　右导航：rightsidebar

菜单：menu

　　子菜单：submenu

​	   下拉菜单:dropmenv

标签页：tab

### title

| 文章列表：list  | 提示信息：msg | 小技巧：tips |
| --------------- | :-----------: | ------------ |
| 栏目标题：title |  字体：font   | 注释：note   |
| 文本：text      | 摘要: summary |              |
|                 |               |              |

### 动词

| 加入：joinus   | 指南：guild | 服务：service |
| -------------- | ----------- | ------------- |
| 注册：regsiter | 投票：vote  | 滚动：scroll  |
| 下载：download |             |               |
|                |             |               |

### 形容词

| 当前的: current |      |      |
| --------------- | ---- | ---- |
|                 |      |      |
|                 |      |      |
|                 |      |      |

### 功能

|   登录条：loginbar   |    广告：banner    |   功能区：shop    |
| :------------------: | :----------------: | :---------------: |
|      按钮：btn       |     图标: icon     |     线：line      |
|      热点：hot       |     新闻：news     | 合作伙伴：partner |
| 友情链接：friendlink |  版权：copyright   |    标签:label     |
|      图片：pic       |   首页：homepage   |    模态：modal    |
|      名片：card      | 通知：notification |  平台：platform   |
|    优惠券：coupon    |                    |                   |

样式文件命名
　　主要的:master.css
　　布局版面:layout.css
　　专栏:columns.css
　　文字:font.css
　　打印样式:print.css
　　主题:themes.css

## 行内元素和块元素

https://blog.csdn.net/Jwhahaha/article/details/102483938

### 块级元素

可以设置宽高，独自占据一行高度（float浮动除外），一般可以作为其他容器使用，可容纳块级元素和行内元素。块级元素有以下特点：

- 每个块级元素都是独自占一行。 
- 元素的高度、宽度、行高和边距都是可以设置的。　　 
- 元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）,**高度由内容撑开**

```
h1~h6:标题标签，用于标记网页中的大标题，依次从大到小
p：用于标记网页中的段落性文字，默认占满横向区域
div：划分，分隔，作用是就是将页面划分为不同的区域，不设置宽高时，高度有内容撑开，宽度和父级元素一样宽
section：区段，是用来定义文档的某个区域，章节
nav：标签定义导航链接的部分，提示：如果文档中有“前后”按钮，则应该把它放到nav元素中。
header：标签定义文档的页眉
footer：标签定义文档或节的页脚，页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等
pre：格式标签，被包围在pre元素中的文本通常会保留空格和换行符，而文本也会呈现为等宽字体。
address： 标签定义文档或文章的作者/拥有者的联系信息，元素中的文本通常呈现为斜体，大多数浏览器会在 address 元素前后添加折行
audio：音频使用，背景音乐播放，属性autoplay自动播放，loop循环播放，src要播放的音频，controls为音频提供播放控件，比如播放按钮。preload规定是否在页面加载后载入音频，如果设置了 autoplay 属性，则忽略该属性。
/ 表格标签 /
table：用于显示一个表格，不能设置宽高，宽高被内容撑开，设置宽度而内部的td没有宽度时，td会按照内容长度的比例拉伸
thead：表头，用于显示一列的名称，一般省略不写，浏览器在解析时会自动添加
tbody：表主体，一般省略不写，浏览器在解析时会自动添加
tr：表示一行
th：表头中的第一个单元格
td：表示主体中的单元格，有属性rowspan合并单元格，合并行。colspan合并列
/ 有序列表，无序列表 /
ul：无序列表
ol：有序列表
li：列表项
dl：定义列表，用于描述类表中的项目（dt（dd））
```

### **行内元素 inline**

行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的宽和高就是内容撑开的宽高。。行内元素有以下特点： 

- 每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。 
- 行内元素的高度、宽度、行高不可设置。 
- 元素的宽度就是它包含的文字或图片的宽度，不可改变。

- **行内元素不能设置宽高，和竖直方向的margin、padding ,但左右可以**

常见行内元素有以下：

```
span：是超文本标记语言（HTML）的行内标签，被用来组合文档中的行内元素，span没有固定的格式表现，当对它应用样式时，它会产生视觉上的变化

a：标记网页中的超链接，点击可以打开或者跳转到另一个网页，也可以链接到一个要下载的文件
有属性：href：要链接到的资源地址，target:打开的链接方式，值_blank:表示新打开一个窗口打开目标地址
strong：标记页面中的粗体文本，语义化标签，除了文本加粗之外，还有强调的预期，表示标签中的内容是页面中需要重点关注的内容

b：标记网页中的粗体文本，仅仅将文本加粗，标签中的内容不再强调
s：删除线，仅仅是删除的效果
del：具有删除语义，delete删除
em：强调文本，斜体展示
sup：上标
sub：下标
```

### **行内块级元素 inline-block**

行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。比如input、img就是行内块级元素，它可以设置高宽以及一行多个。具体特点如下：

- 和其他行内或行内块级元素元素放置在同一行上；
- 元素的高度、宽度、行高以及顶和底边距都可设置。

```
img：用于标记网页中的图像 ，有属性src:图片资源路径 ，alt:提示信息 当图片加载失败 ，以指定文本形式代替图片显示
button：按钮
input：输入框，有属性type输入框类型，有属性值（text表示文本输入框，file文件选择器，password密码输入框，email邮箱输入框，number数字输入框，button按钮）。placeholder占位字符，用于提示输入框应该输入的内容。value表示输入框中的内容。name和后台服务器交互时，必须携带name属性，发送请求时的参数名。

单选 type=“radio” 表示一个单选选项处于同一组单选框只能选中一个值，将多个radio的name属性值设置为相同的值
type="checkbox"复选框

label:和input标签绑定到一块使用，有属性for，属性值就是input输入框的id值。checked属性为标签选中状态
select:下拉列表
option:下拉选项
```

## float和position

### float

- 设置元素浮动后，对应的元素会脱离文档流，该元素的 `display` 值自动变成 `block`

- float 可以用来让文字环绕图片而已。

- float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。

- 假如某个div元素A是浮动的，如果A元素**上一个元素也是浮动的**，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素**上一个元素是标准流中的元素**，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。https://blog.csdn.net/qq_36595013/article/details/81810219

  <img src="https://img-blog.csdn.net/20180818160910520?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

  假设上图中的div2浮动，那么它将脱离标准流，但div1、div3、div4仍然在标准流当中，所以div3会自动向上移动，占据div2的位置，重新组成一个流。

  <img src="https://img-blog.csdn.net/20180818161114199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

  把div2和div3都加上左浮动,由于div2、div3浮动，它们不再属于标准流，因此div4会自动上移，与div1组成一个“新”标准流，而浮动是漂浮在标准流之上，因此div2又挡住了div4。

- **清除浮动:清除浮动不是不用浮动，清除浮动产生的不利影响。**

  ```
  clear :none| left |right  | both
  none :允许两边都可以有浮动对象
  both :不允许有浮动对象
  left :不允许左边有浮动对象
  ```

- 作用

  ```css
  1.CSS浮动塌陷，父级元素不设置高度时，高度由随内容增加自适应高度。当父级元素内部的子元素全部都设置浮动float之后，子元素会脱离标准流，不占位，父级元素检测不到子元素的高度，父级元素高度为0。由于父级元素没有高度，下面的元素会顶上去，造成页面的塌陷。
  （1）父元素使用overflow:hidden来清除浮动，最好加上zoom:1;
  （2）父级div定义height
  （3）在父元素后面使用伪类：after和zoom
  .box:after{
  display:block;
  content:"";
  height:0;
  clear:both;
  }
  （2）结尾处加空div标签clear:both
  （2）对父元素设置display:table；使父元素形成BFC（块格式化上下文）
  			BFC三个特性:防止上下margin重叠，防止浮动元素重叠，防止浮动塌陷
  
  2.父级元素内部有子元素，如果给子元素添加margin-top样式，那么父级元素也会跟着下来，造成外边距塌陷。
  给父级元素添加overflow:hidden
  ```

### position

- **position:absolute**
  - 会让元素以display:inline-block的方式显示,可以设置长宽，默认宽度并不占满父元素。
  - **Z-index 仅能在定位元素上奏效（例如 position:absolute;）！** 
  - 脱离文档流

- **position:relative**

  - 相对定位，相对于原来该元素在普通流中的位置重新定位，依旧在普通流中占据位置，没有脱离普通流，只是视觉上发生变化

    ```css
    background-color: green;
        position: relative;
        top: 50px;
        left: 100px;
    ```

    ![img](https://upload-images.jianshu.io/upload_images/5627750-ec360e4418779b3c.png?imageMogr2/auto-orient/strip|imageView2/2/w/535/format/webp)



- **Position:fixed**
  - 固定定位之后，不占据原来的位置（脱标）
  - 元素使用固定定位之后，会转化为行内块


不同点：position相应的块级元素会覆盖下面的内容（文字），而float只会覆盖块级元素，里面的文字会脱离

## BFC

- https://zhuanlan.zhihu.com/p/25321647

  https://www.jianshu.com/p/4d1dbb041bb2

  BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。

  **触发条件 (以下任意一条)**

  - body 根元素
  - 浮动元素：float 除 none 以外的值
  - 绝对定位元素：position (absolute、fixed)
  - display 为 inline-block、table-cells、flex
  - overflow 除了 visible 以外的值 (hidden、auto、scroll)

  **BFC 特性及应用**

  **1. 同一个 BFC 下外边距会发生折叠**

  ```html
  <head>
  div{
      width: 100px;
      height: 100px;
      background: lightblue;
      margin: 100px;
  }
  </head>
  <body>
      <div></div>
      <div></div>
  </body>
  ```

  <img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img" style="zoom:33%;" />

  从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。

  **2. BFC 可以包含浮动的元素（清除浮动）**

  我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子

  ```html
  <div style="border: 1px solid #000;">
      <div style="width: 100px;height: 100px;background: #eee;float: left;"></div>
  </div>
  ```

  <img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img" style="zoom:33%;" />

  由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。

  ```html
  <div style="border: 1px solid #000;overflow: hidden">
      <div style="width: 100px;height: 100px;background: #eee;float: left;"></div>
  </div>
  ```

  <img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img" style="zoom:33%;" />

  **3. BFC 可以阻止元素被浮动元素覆盖**

  先来看一个文字环绕效果：

  ```html
  <div style="height: 100px;width: 100px;float: left;background: lightblue">我是一个左浮动的元素</div>
  <div style="width: 200px; height: 200px;background: #eee">我是一个没有设置浮动, 
  也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;</div>
  ```

  <img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img" style="zoom:33%;" />

  这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 **overflow: hidden**，就会变成：

  <img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img" style="zoom:33%;" />

  这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。

**开发中的应用**

- 阻止`margin`重叠
- 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 `div`都位于同一个 `BFC` 区域之中)
- 自适应两栏布局
- 可以阻止元素被浮动元素覆盖

## 字体

- **font-family**:"Courier New", Courier, monospace, "Times New Roman", Times, serif, Arial, Helvetica, sans-serif, Verdana

- **font-variant :** **normal** | **small-caps**  设置字母字体 

  **normal :** 正常的字体 	**small-caps :** 小型的大写字母字体 这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。

- **text-transform :** **none** | **capitalize**  | **uppercase** | **lowercase** 

  **capitalize :** 　将每个单词的第一个字母转换成大写，其余无转换发生
  **uppercase :**  转换成大写
  **lowercase :** 　转换成小写

- **text-decoration:** none  |   underline   |     line-through

- **text-indent :** *length* 检索或设置对象中的文本的缩进。

- **letter-spacing :** **normal** | *length* （length允许为负值,px）检索或设置对象中的文字之间的间隔。

- **text-size-adjust**：auto | none | percentage 检索或设置移动端页面中对象文本的大小调整。

  auto：文本大小根据设备尺寸进行调整。

  none：文本大小不会根据设备尺寸进行调整。

  percentage用百分比来指定文本大小在设备尺寸不同的情况下如何调整。

- **direction**: rtl把文本方向设置为“从右向左”；
  ltr 	默认。文本方向从左到右。
  rtl 	文本方向从右到左。
  inherit 	规定应该从父元素继承 direction 属性的值。

- **line-height :** **normal** | *length*  | inherit  	行高 **行高是指文本行基线间的垂直距离** 

  https://blog.csdn.net/a2013126370/article/details/82786681

  *length :* 　百分比数字 | 由浮点数字和单位标识符组成的长度值，允许为负值。其百分比取值是基于字体的高度尺寸。1em=字体的大小

![img](https://img-blog.csdn.net/20180920105701124?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDEzMTI2Mzcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	**line-height=font-size+行间距**

> 如果一个标签没有定义 `height` 属性，那么其最终表现的高度是由 `line-height` 决定的

> 一个容器没有设置高度，那么撑开容器高度的是 `line-height` 而不是容器内的文字内容

> 把 `line-height` 值设置为 `height` 一样大小的值可以实现单行文字的垂直居中

- **vertical-align :** middle|*length* 

  该属性定义display属性值为`inline`、`inline-block`、`inline-table`、`table-cell`子元素**相对父元素/相对整行/其它单元格的基线**垂直对齐。允许指定负长度值和百分比值。 

  - vertical-align不可继承，必须对**子元素**单独设置。


- https://blog.csdn.net/qq_37210523/article/details/103145240

  - white-space

  ![img](https://img-blog.csdnimg.cn/2019111916525132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz,size_16,color_FFFFFF,t_70)

  ```css
  white-space: normal;  /*连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 */
  white-space: nowrap;  /* 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。*/
  white-space: pre;  /* 连续的空白符会被保留。在遇到换行符或者<br>元素时才会换行。*/
  white-space: pre-wrap; /* 连续的空白符会被保留。在遇到换行符或者<br>元素，或者需要为了填充line盒子时才会换行。*/
  white-space: pre-line;  /* 连续的空白符会被合并。在遇到换行符或者<br>元素，或者需要为了填充line盒子时会换行。*/
   
  white-space: break-spaces;
  /**
      与 pre-wrap的行为相同，除了：
      任何保留的空白序列总是占用空间，包括在行尾。
      每个保留的空格字符后都存在换行机会，包括空格字符之间。
      这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容大小和最大内容大小）。
  */
  white-space: inherit;
  white-space: initial;
  white-space: unset;
  ```

  - **word-break**

  ```css
  word-break：指定了怎样在单词内断行
  normal	只在允许的断字点换行（浏览器保持默认处理）。
  keep-all中文自动换行了，而英文使用默认换行方式 --->break-all
  break-word 允许正常的不能被分割的长单词强制分割换行
  //因为word-break的break-word未列入标准，才会一般使用overflow-wrap的break-word值
  overflow-wrap(==word-wrap) 是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。
  break-all表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。
  ```

  **总结**

  white-space，控制空白字符的显示，同时还能控制是否自动换行。它有五个值：normal | nowrap | pre | pre-wrap | pre-line
  word-break，控制单词如何被拆分换行。它有三个值：normal | break-all | keep-all
  word-wrap（overflow-wrap）控制长度超过一行的单词是否被拆分换行，是word-break的补充，它有两个值：normal | break-word

- **text-overflow :** **clip** | **ellipsis** 

  **clip :** 　不显示省略标记（...），而是简单的裁切 
  **ellipsis :** 　当对象内文本溢出时显示省略标记（...）  

- 文本缩略

  ```css
  section:nth-of-type(4) p {
      width: 200px;
      border: 1px solid #ccc;
      /*强制不换行 只在一行缩略  white-space: nowrap;*/
      overflow: hidden;
      /* 防止文本溢出 */
      text-overflow: ellipsis;
      /* 产生.....的效果 */
      display: -webkit-box;
      /*-webkit-line-clamp:n;第n行缩略*/
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
  }
  ```

- overflow: hidden;若第二行文字出现，因为间隔过小。可设置多行文字的间隔，line-height。

## 连写

- font：font-style font-weight font-size/line-height font-family;

  文本属性连写文字大小和字体为必写项。

- border：color  style(solid实线dotted 点线dashed 虚线)   width

  没有顺序要求，线型为必写项。

- Padding: 20px;  上右下左内边距都是20px

  Padding: 20px 30px;  上下20px  左右30px

  Padding: 20px 30px 40px;  上内边距为20px 左右内边距为30px  下内边距为40

  Padding: 20px 30px  40px 50px;  上20px 右30px 下40px 左 50px

## 图像

### 裁剪

**clip :** **auto** | **rect (** *number  number number number* **)**依据上-右-下-左的顺序剪切图像。必须将[position](c_position.html)的值设为absolute，此属性方可使用。

clip-path  裁切一个圆角 inset(<top> <right> <bottom> <left> round <top-radius> <right-radius><bottom-radius> <left-radius>) 

### object-fit 

https://www.runoob.com/cssref/pr-object-fit.html

object-fit 属性指定元素的内容应该如何去适应指定容器的高度与宽度。

object-fit 一般用于 img 和 video 标签，一般可以对这些元素进行保留原始比例的剪切、缩放或者直接进行拉伸等。

| 值         | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| fill       | 默认，不保证保持原有的比例，内容拉伸填充整个内容容器。       |
| contain    | 保持原有尺寸比例。内容被缩放。                               |
| cover      | 保持原有尺寸比例。但部分内容可能被剪切。                     |
| none       | 保留原有元素内容的长度和宽度，也就是说内容不会被重置。       |
| scale-down | 保持原有尺寸比例。内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。 |
| initial    | 设置为默认值，[关于 *initial*](https://www.runoob.com/cssref/css-initial.html) |
| inherit    | 从该元素的父元素继承属性。 [关于 *inherit*](https://www.runoob.com/cssref/css-inherit.html) |

## 布局

### 元素的水平居中

- 元素为行内元素，设置父元素`text-align:center`

- 如果子元素宽度固定，可以设置左右`margin`为`auto`;

- 绝对定位和移动: `absolute + transform`

  ```
  .parent_box{
              width: 400px;
              height: 200px;
              position: relative;
          }
          .child_box{
              width: 200px;
              height: 100px;
              position: absolute;
              top: 0;
              left: 50%;
              transform: translate( -50%,0);
          }
  ```

- 使用`flex-box`布局，指定`justify-content`属性为center

- ```
  display:block;
  margin:auto;
  ```

  

### 元素的垂直居中

- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`

- 使用`flex`布局，设置为`align-item：center`

- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`

- 绝对定位和移动: `absolute + transform`

  ```
  .parent_box{
              width: 400px;
              height: 200px;
              position: relative;
          }
          .child_box{
              width: 200px;
              height: 100px;
              position: absolute;
              left: 0;
              top: 50%;
              transform: translate( 0，-50%);
          }
  ```

- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值

- 文本垂直居中设置`line-height`为`height`值


### 垂直水平居中

```css
/** 1 **/
.wraper {
  position: relative;
  .box {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100px;
    height: 100px;
    margin: -50px 0 0 -50px;
  }
}

/** 2 **/
.wraper {
  position: relative;
  .box {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
}

/** 3 **/
.wraper {
  .box {
    display: flex;
    justify-content:center;
    align-items: center;
    height: 100px;
  }
}

/** 4 **/
.wraper {
  display: table;
  .box {
    display: table-cell;
    vertical-align: middle;
  }
}
```

**如何垂直居中一个`<img>`**

```
#container     /**<img>的容器设置如下**/
{
    display:table-cell;
    text-align:center;
    vertical-align:middle;
}
```



## 选择器

### 优先级

1. 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。

2. 作为style属性写在元素内的样式 优先级1000

3. id选择器                                        优先级100

4. 类选择器和伪类和属性 				优先级10

5. 标签选择器和伪元素                     优先级1

6. 通配符选择器                                优先级0

7. 浏览器自定义或继承                    没有优先级

   **总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性**

 1.如果是两种相同优先级 为同一个元素 同一个属性设置 的话，是哪个写在代码靠后 最终就按那个的样式

 2.交集/后代选择器的优先级 所有优先级 加起来 运算 然后比较

 3.并集的话 就是各算各的。

### 属性选择器

```css
/* 存在title属性的<a> 元素 */
a[title]
/* 存在href属性并且属性值匹配"https://example.org"的<a> 元素 */
a[href="https://example.org"]
/* 存在href属性并且属性值包含"example"的<a> 元素 */
a[href*="example"]
/* 存在href属性并且属性值结尾是".org"的<a> 元素 */
a[href$=".org"] 
/* 存在class属性并且属性值包含以空格分隔的"logo"的<a>元素 */
a[class~="logo"]
```

### 组合选择器

相邻兄弟选择器 A + B
普通兄弟选择器 A ~ B
子选择器 A > B
后代选择器 A B

交集 
A.B{
} 
并集 
A, B｛
｝ 

### 伪类选择器

```
a:link{属性:值;}       链接默认状态	 
a:visited{属性:值;}     链接访问之后的状态 
a:hover{属性:值;}      鼠标放到链接上显示的状态  	a:active{属性:值;}      链接激活的状态
a:focus{属性:值；}     获取焦点
```

- `p:first-of-type` 选择属于其父元素的首个`<p>`元素的每个`<p>` 元素。
- `p:last-of-type` 选择属于其父元素的最后 `<p>` 元素的每个`<p>` 元素。
- `p:only-of-type` 选择属于其父元素唯一的 `<p>`元素的每个 `<p>` 元素。
- `p:only-child` 选择属于其父元素的唯一子元素的每个 `<p>` 元素。
- `p:nth-child(2)` 选择属于其父元素的第二个子元素的每个 `<p>` 元素。
- `p:nth-of-type(n)` 选择E的父元素下的第n个E元素
- `:after` 在元素之前添加内容,也可以用来做清除浮动。
- `:before` 在元素之后添加内容。
- `:enabled` 已启用的表单元素。
- `:disabled` 已禁用的表单元素。
- `:checked` 单选框或复选框被选中。
- `:empty` 选中没有任何子节点的E元素；

### 伪元素选择器

```
伪元素特性
减少 dom 节点数,但不利于不利于 SEO
它不存在于文档中，所以 js 无法操作它
它属于主元素本身，因此当伪元素被点击的时候触发的是主元素的 click 事件
```

- E::selection 可改变选中文本的样式


- E::placeholder 可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholder，具体参考手册进行对比。


- E:after、E:before 在旧版本里是伪类，在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待。

  ```css
  块级元素才能有:before, :after，譬如 img 就不能设置，亦即某些元素是没有:before, :after 的
  伪类元素的display是默认值inline
  
  （1）各种图标
  利用这两个伪类，可以实现需要简单的图标
  （2）attr()
  通过attr()调用当前元素的属性，比如将图片alt提示文字或者链接的href地址显示出来。
  a::after{
      content:  attr(href) ;
  }
  element.setAttribute("data-age",age);
  element.dataset["age"]
  <a href="http://www.cnblogs.com/starof">starof</a>
  （3）引用媒体文件
  a::before{
      content: url("https://www.baidu.com/img/baidu_jgylogo3.gif");
  }
  （4）清除浮动
  .cf:before,
  .cf:after {
      content: " ";
      display: table; 
  }
  .cf:after {
      clear: both;
  }		
  ```

## tips

- Scrollbar滚动条设置，cursor鼠标指针，zoom图像放大倍数


- ```
  visibility:hidden; 隐藏元素  隐藏之后还占据原来的位置。
  opacity=0，该元素隐藏起来了，但不会改变页面布局,还占据原来的位置
  display:none;隐藏元素  隐藏之后不占据原来的位置。
  ```

  

  ```
  透明度
  background-color: rgba(0, 0, 0, 0.3);
  opacity: 0.3;
  transparent是颜色的一种，这种颜色叫透明色。
  ```

- placeholder（如果是在手机客户端webview 只使用－webkit内核方式即可。）

  ```
  
  input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {
      color: #666;
      font-size: 16px;
    }
    
    input:-moz-placeholder, textarea:-moz-placeholder {
      color: #666;
      font-size: 16px;
    }
    
    input::-moz-placeholder, textarea::-moz-placeholder {
      color: #666;
      font-size: 16px;
    }
    
    input:-ms-input-placeholder, textarea:-ms-input-placeholder {
      color: #666;
      font-size: 16px;
    }
  ```


# css3

## 盒模型

https://www.imooc.com/article/68238

<img src="https://img.html.cn/upload/image/445/883/226/1575271471430989.jpg" alt="1.jpg" style="zoom:50%;" />

标准盒子模型

```
盒子实际内容（content）的width/height=我们设置的width/height;
盒子总宽度/高度=width/height+padding+border+margin。
```

IE盒子模型

```
content宽度+内边距padding+边框border宽度=我们设置的width(height也是如此)
盒子总宽度/高度=width/height + margin = content宽度/高度 + padding + border + margin
```

**box-sizing 常用的属性有哪些？分别有什么作用**

- `box-sizing: content-box;` 默认的标准(W3C)盒模型元素效果
- `box-sizing: border-box;` 触发怪异(IE)盒模型元素的效果
- `box-sizing: inherit;` 继承父元素 `box-sizing` 属性的值

## 阴影

文本阴影：text-shadow 

color  length  lenth opacity  [ inset(阴影向内) ] 

颜色 水平偏移量  垂直偏移量  模糊度  （缩展量）

边框阴影 ：border-shadow

box-shadow：[inset(阴影向内)]  水平偏移量  垂直偏移量  模糊度  （缩展量）  颜色

## 边框圆角box-radius

 四个属性值，分别表示左上角、右上角、右下角、左下角的圆角大小（**顺时针方向**） 

 三个属性值，第一个值表示左上角，第二个值表示右上角和左下角（对角），第三个值表示右下角。 

 两个属性值，第一个值表示左上角和右下角，第二个值表示右上角和左下角 

 斜杠二组值：第一组值表示水平半径，第二组值表示垂直半径，每组值也可以同时设置1到4个值，规则与上面相同。 border-radius:100px/40px;

**outline :**[ **outline-color** ](c_outlinecolor.html)||[**outline-style** ](c_outlinestyle.html)||[ **outline-width** ](c_outlinewidth.html)

设置或检索对象外的线条轮廓。outline画在[border](c_border.html)外面，并且不一定是矩形

## 边框图像

```
border-image-source: url(images/border.png);
border-image-slice: 27;上、右、下、左侧边缘裁剪27像素，图像被分割为九个区域：四个角、四条边以及一个中间区域。
border-image-width: 10px;指定图像边界的宽度：
border-image-repeat: round/stretch/repeat;
```

## 背景

**background:color url  repeat position  attachment**

设置背景颜色会填充content,padding。

连写的时候没有顺序要求，url为必写项  

- **background-position:left top**

- **background-attachment :** **scroll** | **fixed**  

  **scroll :** 　背景图像是随对象内容滚动
  **fixed :** 　背景图像固定 

- **background-clip**：padding-box/content-box/border-box;  修改背景颜色区域/规定背景的绘制区域。

- **background-origin:** border-box;修改背景图片所在区域

- **background-position:**center center;图片水平垂直居中

```
background-size
cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。
contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。

```

## 渐变

```
background-image：linear-gradient();radial-gradient()
repeating-linear-gradient   repeating-radial-gradient
```

## 伸缩布局

```
display: flex; 会浮动
justify-content: space-between;两端对齐布局（伸缩布局）
```

```
flex-direction: column;决定主轴的方向(即子元素的排列方向)
调整主轴方向（默认为水平方向）包括row、column、row-reverse、column-reverse
```

```
justify-content（水平方向）定义了子元素在主轴上的对齐方式
主轴方向对齐，可以调整元素在主轴方向上的对齐方式，包括flex-start、flex-end、center、space-around(多与空间放两边)、space-between(多与空间放中间)几种方式  
```

```
align-items（垂直方向）定义子元素在侧轴上如何对齐
调整侧轴方向对齐方式，包括flex-start、flex-end、center、baseline、stretch
```

```
 flex-wrap 
 控制是否换行，包括wrap、nowrap （不换行）
```

```
align-content 定义了多根轴线的对齐方式, 如果子元素只有一根轴线,该属性不起作用
可对应用flex-wrap: wrap后产生的换行进行控制，包括flex-start、flex-end、center、space-between、space-around、stretch 
```

```
flex 
控制子元素伸缩比例 
```

```
align-self 侧轴上单个项目对齐方式
单独对某一个子元素设置 flex-start、flex-end、center、baseline、stretch 
```

```
flex-grow(用在子盒子上)属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

flex-shrink(flex元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值)属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
```

order **定义子元素的排列顺序, 数值越小 排列越靠前 默认为0** 

## 多列布局

```
/*设置分成几列*/-webkit-column-count: 4;
/*当列宽*列数乘积大于盒子总宽，会自动调整列数*/
-webkit-column-width: 400px;
/*调整列之间的宽度*/
-webkit-column-gap: 60px;
-webkit-column-rule: 2px dashed #CCC;

//标题单独置一列
/*all代表所有列*/
-webkit-column-span: all;
```



```
设置分成几列-webkit-column-count: 3;
当列宽*列数乘积大于盒子总宽，会自动调整列数-webkit-column-width: 200px;
调整列之间的宽度-webkit-column-gap: 60px;
-webkit-column-rule: 2px dotted #CCC;分割线设置
```

## 响应式

### 单位

https://blog.csdn.net/liwusen/article/details/80834546

#### 像素px

像素是网页布局的基础，**一个像素表示计算机屏幕所能显示的最小区域**，像素分为：**css像素和物理像素**。

**css像素**：我们在js或者css代码中使用的px单位

**物理像素(设备像素)**：只与设备或者说硬件有关，同样尺寸的屏幕，**设备的密度越高，物理像素也就越多**。

**像素比(DRP)**：表示一个CSS像素占用几个物理像素。

```
1 CSS像素 = 物理像素／分辨率
```

```
//有一个750px * 1134px的视觉稿
//pc端的布局视口通常情况下为980px
PC端： 1 CSS像素 = 物理像素／分辨率 = 750 ／ 980 =0.76 px
//移动端以iphone6为例，分辨率为375 * 667
iphone6：1 CSS像素 = 物理像素 ／分辨率 = 750 ／ 375 = 2 px
//在PC端，一个CSS像素可以用0.76个物理像素来表示，而iphone6中 一个CSS像素表示了2个物理像素。
```

还有一个因素也会引起css中px的变化，那就是**用户缩放**。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。(1px 的宽度在 devicePixelRatio 等于 1.5 的设备上要放大 1.5 倍来显示，同时设备又不可能显示半个像素，只能取整处理) 

在移动端浏览器中以及某些桌面浏览器中，window对象有一个**devicePixelRatio**(设备像素比)属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 **devicePixelRatio = 物理像素 / 独立像素**。css中的**px就可以看做是设备的独立像素**，所以通过devicePixelRatio，我们可以知道该设备上**一个css像素代表多少个物理像素**。

#### 视口

**视口针对移动设备，对PC没用**

(1) 布局视口（layout viewport）
布局视口定义了pc网页在移动端的默认布局行为，因为通常pc的分辨率较大，布局视口默认为980px。也就是说在不设置网页的viewport的情况下，pc端的网页默认会以布局视口为基准，在移动端进行展示。因此我们可以明显看出来，默认为布局视口时，根植于pc端的网页在移动端展示很模糊。

<img src="https://www.runoob.com/wp-content/uploads/2018/07/1532326331-2895-201407.png" alt="img" style="zoom:50%;" />

(2) 视觉视口（visual viewport）
视觉视口表示浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。视觉视口的定义，就像拿着一个放大镜分别从不同距离观察同一个物体，视觉视口仅仅类似于放大镜中显示的内容，因此视觉视口不会影响布局视口的宽度和高度。

<img src="https://www.runoob.com/wp-content/uploads/2018/07/1532326332-9414-201407.png" alt="img" style="zoom:50%;" />

(3) 理想视口（ideal viewport）

理想视口或者应该全称为“理想的布局视口”，在移动设备中就是指设备的分辨率。换句话说，理想视口或者说分辨率就是给定设备物理像素的情况下，最佳的“布局视口”。

**应用**

移动设备默认的viewport是layout viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">

该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。

| width         | 设置***layout viewport*** 的宽度，为一个正整数，或字符串"width-device" |
| ------------- | ------------------------------------------------------------ |
| initial-scale | 设置页面的初始缩放值，为一个数字，可以带小数                 |
| minimum-scale | 允许用户的最小缩放值，为一个数字，可以带小数                 |
| maximum-scale | 允许用户的最大缩放值，为一个数字，可以带小数                 |
| height        | 设置***layout viewport*** 的高度，这个属性对我们并不重要，很少使用 |
| user-scalable | 是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes代表允许 |

#### rem

相对于根元素html的font-size值的大小，此单位若要用于屏幕自适应，可与vw配合使用设置根元素的字体大小。375px的网页的设计稿。此时，1vw=3.75px；4vw=15px；8vw=30px；

#### 百分比%


1. 子元素**width**或**height**的百分比是**父元素width或height的百分比**
2. **top**、**bottom**的百分比是相对于(默认定位)**父元素的height**
3. **left**、**right**的百分比是相对于(默认定位)**父元素的width**
4. **padding**、**margin**不论是垂直方向或者是水平方向，都相对于直接**父元素的width**
5. **border-radius**、**translate**、**background-size**的百分比，则是相对于**自身的width**

**两个缺点：**

（1）计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。
（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。

### 自适应

https://www.cnblogs.com/chenyoumei/p/10510321.html

- 查看设计图，确定页面布局，组件的复用等

- 尽可能的添加多的div来包含元素，并设置对应的classauto

- 外层盒子使用flex进行布局，不设置绝对宽高px(使用rem或者%布局)，高度由里面的内容撑开（**撑不开就用margin、padding**）。**最外层盒子**设置为设计图的宽度（一般我是设置为19.2rem），并使用

  `box-sizing:border-box以及margin：auto`

- 内层盒子使用rem布局。

- **Tips**

  - float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。

  - 图片的自适应（fluid image）

  ```
  img { width: auto; max-width: 100%; }
  ```

- 自适应exportExcel

  - yd ui 移动端

    https://blog.csdn.net/weixin_44823323/article/details/99640765

    https://www.jianshu.com/p/b00cd3506782

    ~~自适应不是指你缩放**页面大小**(ctrl+鼠标滚动条)，是指你浏览器大小变化自适应~~。
  
    一般不加自适应，缩放页面，会发现`$(document).width()`会根据缩放变大变小，但是**元素宽高不会变**，相应元素就会**感觉**变大变小。加入自适应（**自适应会根据页面大小来改变px，元素宽高会变**），缩放页面，相应元素**感觉**不会改变。
  
    **缩放页面大小有三种情况：**
  
    1. 改变浏览器宽高
    2. ctrl+鼠标滚动条，改变页面大小
    3. window中显示设置中的缩放与布局
  
    > 像素比就是第二种和第三种情况
  
    ```css
    (function (doc, win) {
            var docEl = doc.documentElement,
                resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
                recalc = function () {
                    var clientWidth = docEl.clientWidth;
                    if (!clientWidth) return;
                    if(clientWidth>=640){
                        docEl.style.fontSize = '100px';
                    }else{
                        docEl.style.fontSize = 100 * (clientWidth / 640) + 'px';
                    }
                };
    
            if (!doc.addEventListener) return;
            win.addEventListener(resizeEvt, recalc, false);
            doc.addEventListener('DOMContentLoaded', recalc, false);
        })(document, window);
    ```
  
  - 媒体查询

## 动画

http://www.animate.net.cn/1853.html

### 过渡transition

第一种叫过渡（transition）动画，就是从初始状态过渡到结束状态这个过程中所产生的动画。所谓的状态就是指大小、位置、颜色、变形（transform）等等这些属性。css过渡只能定义首和尾两个状态，所以是最简单的一种动画。

**参数**

- property – 什么属性将用动画表现，例如, opacity。
- duration –  过渡的时间 
- transition-delay – 设置过渡延时
- timing-function  – 过渡的速度
  - 匀速linear  逐渐降速ease 加速ease-in 降速ease-out  先加速后减速ease-in-out

```html
transform 和 transition 属性实现简单旋转效果的例子：

<div style="transition: transform 3s ease-in" 
  onclick="this.style.transform='rotate(360deg)'">
点击这个方块，能让它旋转起来。
</div>
```

**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       **

### 关键帧动画

第二种叫做关键帧（keyframes）动画。不同于第一种的过渡动画只能定义首尾两个状态，关键帧动画可以定义多个状态，或者用关键帧来说的话，过渡动画只能定义第一帧和最后一帧这两个关键帧，而关键帧动画则可以定义任意多的关键帧，因而能实现更复杂的动画效果。

关键帧动画的定义方式也比较特殊，它使用了一个关键字 @keyframes 来定义动画。具体格式为：

```css
@keyframes 动画名称{
   时间点 {元素状态}
   时间点 {元素状态}
   …
}
```

**参数**

- animation-name:动画名称
- animation-duration: 动画完成一个周期所花费的秒，默认为0
- animation-timing-function: 动画的速度，默认ease
- animation-delay：动画延时，默认为0
- animation-iteration-count: 动画播放次数，默认为1，infinite无限次
- animation-direction：动画是否再下一个周期逆向播放
- animation-play-state：动画是否正在运行或暂停，默认是running，paused
- animation-fill-mode：动画时间之外的状态	

![QQ截图20131102123530](http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/5821d8e8b8bb59a5387d17dd3100ad21.png)

 这段代码定义了一个名为demo,且有5个关键帧的动画。0% ，10% 等这些表示的是时间点，是相对于整个动画的持续时间来说的，时间点之后的花括号里则是元素的状态属性集合，描述了这个元素在这个时间点的状态，动画发生时，就是从第一个状态到第二个状态进行过渡，然后从第二个状态到第三个状态进行过渡，直到最后一个状态。一般来说，0%和100%这两个关键帧是必须要定义的。

![QQ截图20131102123530](http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/6e21739e7cb9ee141063b0bceb541fa2.png)

注意，为了达到最佳的浏览器兼容效果，在实际书写代码的时候，还必须加上各大浏览器的私有前缀

![QQ截图20131102123530](http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/5e08c5fe40dbf1178ed6283aba8f5843.png)

### 转化transform

CSS**`transform`**属性允许你旋转，缩放，倾斜或平移给定元素。

示例：https://www.vps5.com/example?pid=2959

- transform: rotate(360deg);旋转   

- transform: skew(45deg);倾斜      

- transform: scale(1.5);盒子扩大1.5倍

  ```
  如何实现小于12px的字体效果
  transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block;
  
  transform: scale(0.7);
  ```

- transform: translate(400px) 向左移动400px	translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%

### **3D**

**3D 转换方法**

| 函数                                                         | 描述                                      |
| :----------------------------------------------------------- | :---------------------------------------- |
| matrix3d(*n*,*n*,*n*,*n*,*n*,*n*, *n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*) | 定义 3D 转换，使用 16 个值的 4x4 矩阵。   |
| translate3d(*x*,*y*,*z*)                                     | 定义 3D 转化。                            |
| translateX(*x*)                                              | 定义 3D 转化，仅使用用于 X 轴的值。       |
| scale3d(*x*,*y*,*z*)                                         | 定义 3D 缩放转换。                        |
| scaleX(*x*)                                                  | 定义 3D 缩放转换，通过给定一个 X 轴的值。 |
| rotate3d(*x*,*y*,*z*,*angle*)                                | 定义 3D 旋转。                            |
| rotateX(*angle*)                                             | 定义沿 X 轴的 3D 旋转。                   |

**3D 转换属性**

- [transform](https://www.w3school.com.cn/cssref/pr_transform.asp)：向元素应用 2D 或 3D 转换

- [transform-origin](https://www.w3school.com.cn/cssref/pr_transform-origin.asp)：变形的原点，允许你改变被转换元素的位置。默认情况，变形的原点在元素的中心点，或者是元素X轴和Y轴的50%处。

  示例：https://www.w3school.com.cn/example/css3/demo_css3_transform-origin.html

- [transform-style](https://www.w3school.com.cn/cssref/pr_transform-style.asp)：规定**被嵌套元素**如何在 3D 空间中显示。

  设置transform-style的值为flat，则该元素的所有**子元素**都将被平展到该元素的2D平面中呈现

  设置transform-style的值为preserve-3d，它表示不执行平展操作，他的所有子元素位于3D空间中

  示例：https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_transform-style

- [perspective](https://www.w3school.com.cn/cssref/pr_perspective.asp)：定义 3D 元素的景深，当为元素定义 perspective 属性时，其**子元素**会获得透视效果，而不是元素本身（透视效果是写在父亲身上，而不是元素本身）。

  用来设置用户和元素3D空间Z平面之间的距离。值越小，用户与3D空间Z平面距离越近，视觉效果更令人印象深刻；反之，值越大，用户与3D空间Z平面距离越远，视觉效果就很小。

  示例：https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_perspective1

- [perspective-origin](https://www.w3school.com.cn/cssref/pr_perspective-origin.asp)：perspective属性的源点角度

- [backface-visibility](https://www.w3school.com.cn/cssref/pr_backface-visibility.asp)：定义元素在不面对屏幕时是否可见。

## 媒体查询

```
@media screen and (max-width:600px) {   
body {      background-color: blue;   }}
@media screen and (min-width:900px) {  
body {      background-color: red;   }}

```

# sass

**css预处理器sass**

## 变量

```
　　$blue : #1875e7;　

　　div {
　　　color : $blue;
　　}
```

如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。

```
　$side : left;

　　.rounded {
　　　　border-#{$side}-radius: 5px;
　　}
```

## **计算功能**

SASS允许在代码中使用算式：

```
　　body {
　　　　margin: (14px/2);
　　　　top: 50px + 100px;
　　　　right: $var * 10%;
　　}
```

## **嵌套**

SASS允许选择器嵌套。比如，下面的CSS代码：

```
div h1 {
　　　　color : red;
}
```

可以写成：

```
　　div {
　　　　hi {
　　　　　　color:red;
　　　　}
　　}
```

属性也可以嵌套，比如border-color属性，可以写成：

```
　　p {
　　　　border: {
　　　　　　color: red;
　　　　}
　　}
```

在嵌套的代码块内，可以**使用&引用父元素**。比如a:hover伪类，可以写成：

```
　　a {
　　　　&:hover { color: #ffb3ff; }
　　}
```

**注释**

SASS共有两种注释风格。

标准的CSS注释 /* comment */ ，会保留到编译后的文件。

单行注释 // comment，只保留在SASS源文件中，编译后被省略。

在/*后面加一个感叹号，表示这是"重要注释"。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。

```
/*!
　　　　重要注释！
*/
```

## **代码的重用**

### **继承**

SASS允许一个选择器，继承另一个选择器。比如，现有class1：

```
　　.class1 {
　　　　border: 1px solid #ddd;
　　}
```

class2要继承class1，就要使用@extend命令：

```
　　.class2 {
　　　　@extend .class1;
　　　　font-size:120%;
　　}
```

### **Mixin**

Mixin有点像C语言的宏（macro），是可以重用的代码块。

使用@mixin命令，定义一个代码块。

```
@mixin left {
　　　　float: left;
　　　　margin-left: 10px;
　　}
```

使用@include命令，调用这个mixin。

```
div {
　　　　@include left;
　　}
```

mixin的强大之处，在于可以指定参数和缺省值。

```
　　@mixin left($value: 10px) {
　　　　float: left;
　　　　margin-right: $value;
　　}
```

使用的时候，根据需要加入参数：

```
　　div {
　　　　@include left(20px);
　　}
```

# js

## 通识

### 命名

```
变量的命名规则和规范：由字母、数字、下划线、$符号组成，不能以数字开头
驼峰命名法。首字母小写，后面单词的首字母需要大写
```

### **数值判断转换**

- NaN：not a number 该属性用于指示某个值不是数字。 

  - NaN 与任何值都不相等，包括他本身

- isNaN: is not a number判断是否是数字，若是数字返回false

- isFinite(number ) 函数用于检查其参数是否是无穷大。

  **提示：** 如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。

```
undefined表示一个声明了没有初始化的变量，变量只声明的时候值默认是undefined
null表示一个空，变量的值如果想为null，必须手动设置
```

```
布尔类型的隐式转换：转换为true   非空字符串  非0数字  true 任何对象
				转换成false  空字符串  0  false  null  undefined
```

转换成字符串类型：

- toString() String() 拼接字符串方式

**转换成数值类型：**

- 1.Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN 

- 2.parseInt() 

- 3.parseFloat()

### **堆栈**

**栈：**

- 存储基础数据类型

- 栈会开辟一个内存

- 按值访问

- 存储的值大小固定

- 由系统自动分配内存空间

- 空间小，运行效率高

- 先进后出，后进先出

- 栈中的DOM，ajax，setTimeout会依次进入到队列中,当栈中代码执行完毕后，再将队列中的事件放到执行栈中依次执行。

- 微任务和宏任务

  **栈先进后出，队列先进先出**

**堆:**

- 存储引用数据类型
- 堆共用同一个内存
- 按引用访问
- 存储的值大小不定，可动态调整
- 主要用来存放对象
- 空间大，但是运行效率相对较低
- 无序存储，可根据引用直接获取

## 获取

### 位置获取

#### 获取鼠标当前位置（事件对象）

- offsetX、offsetY：  鼠标的当前位置 相对于 目标节点的内填充边顶部、内填充边左部的位置。内填充边意思是不包含border，但包含padding，类似于padding-box。

- clientX、clientY： 鼠标当前位置 相对于 **视口**顶部、浏览器可视区域左部 的位置；

- pageY、pageX：     鼠标当前位置 相对于 **页面/文档**顶部、**页面/文档**左部的位置；

- screenY、screenX：鼠标当前位置 相对于 **屏幕**顶部、屏幕左部的位置；

  **他们均是鼠标事件的一级属性 ，如e.clientY**

![图片描述](https://segmentfault.com/img/bVXWPA?w=1043&h=552)



![img](https://upload-images.jianshu.io/upload_images/1811036-510a2fbcd5bb2d17.png?imageMogr2/auto-orient/strip|imageView2/2/w/625/format/webp)



Element.getBoundingClientRect()   获取元素相对于**视口**的位置 

top、bottom、left、right：分别是该元素的元素框（盒模型）上下左右位置距视口的距离。

![img](https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp)

`window.scrollTo(options)`方法,`options`是一个对象，有三个属性：
`top`，`left` 
`behavior` 类型String,表示滚动行为,支持参数 `smooth`(平滑滚动),`instant`(瞬间滚动),默认值auto（等同于`instant`）

#### 获取元素当前位置

```
document.getElementsByClassName("scroll")[0].clientHeight
```

- clientHeight：内容+padding（上下）

  clientWidth：内容+padding（左右）

- offsetTop：从边框border（不包含）距离父元素的高度距离

  offsetLeft：从边框border（不包含）距离父元素的宽度距离

  offsetHeight：内容+padding+border

  offset Width：内容+padding+border

- scrollleft/top 读取或设置元素滚动条到元素左边的距离。

   scrollwidth/height 总的宽/高（显示+隐藏的）

#### 获取浏览器宽高

```js
window.outerWidth/Height返回一个窗口的外部高度，包括所有界面元素（如工具栏）
window.innerWidth/Height获取浏览器显示区域（可视区域）的高度
JQ
获取浏览器显示区域（可视区域）的高度 ：   
$(window).height()=window.innerHeight;   
获取浏览器显示区域（可视区域）的宽度 ：
$(window).width()=window.innerWidth
```

```js
JQ
获取页面的文档高度(包括滚动出去的宽高)   
$(document).height();   
获取页面的文档宽度 ：
$(document).width(); 
```

```js
获取滚动条到顶部的垂直高度 (即网页被卷上去的高度)  
$(document).scrollTop();   
获取滚动条到左边的垂直宽度 ：
$(document).scrollLeft(); 
```

### 属性获取

- js获取css属性值

  - jquery方法

  ```
  //jquery方法
  const jq_width = $('.box').css('width');
  const jq_lineHeight = $('.box').css('line-height');
  console.log(jq_width,jq_lineHeight);//200px 150px
  ```

  - 然后我们再用js原生方法去获取

  ```js
  // 原生style.css方法
  const box = document.querySelector('.box');
  const js_width = box.style.width;
  const js_lineHeight = box.style.lineHeight;
  console.log(js_width,js_lineHeight);//   50px
  //在这里我们会发现style.css方法只能获取到写在标签上的属性 style = "line-height:150px" 不能获取写在<style>``</style>中的css属性
  ```

  - 使用`window.getComputedStyle`这个方法获取所有经过浏览器计算过的样式

- elementNode.getAttribute(name)：方法通过名称获取属性的值。

  elementNode.setAttribute(name, value)：方法创建或改变某个新属性。

  elementNode.removeAttribute(name)：方法通过名称删除属性的值。


### 节点元素获取

getElementsBy方法都是伪数组arguments

判断当前的子节点是否是元素节点	if (node.nodeType === 1)

parentNode	父元素		childNodes  所有子节点	children    所有的子元素

lastChild    获取最后一个子节点	lastElementChild     获取最后一个子元素

nextSibling  下一个兄弟节点		nextElementSibling	下一个兄弟元素

previousSibling   上一个兄弟节点	 previousElementSibling    上一个兄弟元素

## 数据类型

### 字符串

**不会改变原来的字符串**

#### charAt

charAt(index)

```
获取指定位置处字符 myString.charAt(1)
```

charCodeAt()  	//获取指定位置处字符的ASCII码

#### indexOf

indexOf('',[index] )   	//返回指定内容在元字符串中的位置，只找第一个匹配的,若没有则返回-1是，indexOf('a',2);从位置2开始找到a的位置
lastIndexOf() 	//从后往前找，只找第一个匹配的

#### concat

拼接字符串，等效于+，+更常用

#### slice

提取字符串的一部分，并返回新的字符串

str.slice(start, end) 

end 参数可选，start可取正值，也可取负值。

取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符，如果end省略则截取到字符串末尾）
取负值时表示从索引为 length+start 位置截取到end所在位置的字符

```
ar str = "It is our choices that show what we truly are, far more than our abilities.";
console.log(str.slice(0,-30)); // It is our choices that show what we truly are
console.log(str.slice(-30)); // , far more than our abilities.
```

#### substring

str.slice(start, end)
取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符，如果end省略则截取到字符串末尾）
取负值时表示从索引为 length+start 位置截取到end所在位置的字符

#### substr

返回字符串指定位置开始的指定数量的字符。

substr(fromIndex,length)   		

start 表示开始截取字符的位置，可取正值或负值。取正值时表示start位置的索引，取负值时表示 length+start位置的索引。

length 表示截取的字符长度。

#### trim

trim()去除空白   
只能去除字符串前后的空白，字符之间的空格不能去掉

#### **toLocaleUpperCase**

toLocaleLowerCase() 方法返回调用该方法的字符串被转换成小写的值，转换规则根据本地化的大小写映射toLocaleUpperCase() 方法则是转换成大写的值。

语法：*str.toLocaleLowerCase()*, *str.toLocaleUpperCase()*

```
console.log('ABCDEFG'.toLocaleLowerCase()); // abcdefg
console.log('abcdefg'.toLocaleUpperCase()); // ABCDEFG
```

#### split

split()字符转换为数组 split()还可以结合正则表达式

```js
var str='a,b,c,d';
var arr=str.split(',');//以逗号为分割成数组
arr.join('');
```

#### includes(ES6)

includes() 方法基于**ECMAScript 2015（ES6）规范**，它用来判断一个字符串是否属于另一个字符。如果是，则返回true，否则返回false。

语法：*str.includes(subString [, position])*

subString 表示要搜索的字符串，position 表示从当前字符串的哪个位置开始搜索字符串，默认值为0。

```js
var str = "Practice makes perfect.";
console.log(str.includes("perfect")); // true
console.log(str.includes("perfect",100)); 
```

#### endsWith(ES6)

endsWith() 方法基于**ECMAScript 2015（ES6）规范**，它基本与 contains() 功能相同，不同的是，它用来判断一个字符串是否是原字符串的结尾。若是则返回true，否则返回false。

语法：*str.endsWith(substring [, position])*

与contains 方法不同，position 参数的默认值为字符串长度。

```js
var str = "Learn and live.";
console.log(str.endsWith("live.")); // true
console.log(str.endsWith("Learn",5)); 
```

startsWith() 方法基于**ECMAScript 2015（ES6）规范**，它用来判断当前字符串是否是以给定字符串开始的，若是则返回true，否则返回false。

语法：*str.startsWith(subString [, position])*

```
var str = "Where there is a will, there is a way.";
console.log(str.startsWith("Where")); // true
console.log(str.startsWith("there",6)); 
```

### 数组

#### 会改变原来数组的有：

##### pop()

删除数组的最后一个元素并返回删除的元素。

##### push()

向数组的末尾添加一个或更多元素，并返回新的长度。

##### shift()

删除并返回数组的第一个元素。

##### unshift()

向数组的开头添加一个或更多元素，并返回新的长度。reverse()---反转数组的元素顺序。

##### reverse()	

翻转数组

##### sort() 	

*arr.sort([comparefn])*

- comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序

- 如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素：
  - 若 comparefn(a, b) < 0，那么a 将排到 b 前面；
  - 若 comparefn(a, b) = 0，那么a 和 b 相对位置不变；
  - 若 comparefn(a, b) > 0，那么a , b 将调换位置；

```js
//即使是数组sort也是根据字符，从小到大排序
//采用冒泡排序
sort(fn(a,b){
// 升序
return a - b;
// 倒序
return b - a;
})
fn（a,b）{return <0||>0},返回小于0升序，大于0降序。

```

```
var a = [2,3,1,0].sort(function(a,b){
    console.log(a,b)
    return a-b
})
:3 2
:1 3 
:1 2 
:0 2
:0 1
```

**sort()方法的比较逻辑为：**
前一半的数组进行比较，并排好序，后一半数组再与前面排序好的数组的中间一个值比较（二分法，判断是与前面还是后面的数组比较，更快），并排序

##### splice()

用于插入、删除或替换数组的元素。

```js
arr.splice(start,deleteCount[, item1[, item2[, …]]])

var array = ["one", "two", "four"];
// splice(position, numberOfItemsToRemove, item)
// 拼接函数(索引位置, 要删除元素的数量, 元素)
array.splice(2, 0, "three"); // 
array; //["one", "two", "three", "four"]

var array = ["apple","boy"];
var splices = array.splice(1,1);
console.log(array); // ["apple"]
console.log(splices); // ["boy"] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素
```

数组指定位置插入元素

```
Array.prototype.insert = function (index, item) {
this.splice(index, 0, item);
};
var nums = ["one", "two", "four"];
nums.insert(2, 'three'); // 注意数组索引, [0,1,2..]
array // ["one", "two", "three", "four"]
```



#### 不会改变原来数组的有：

##### concat() 

将传入的数组或者元素与原数组合并，组成一个新的数组并返回。

语法：***arr.concat(value1, value2, …, valueN)***

```
var array = [1, 2, 3];
var array2 = array.concat(4,[5,6],[7,8,9]);
console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(array); // [1, 2, 3], 可见原数组并未被修改
```

若concat方法中不传入参数，那么将基于原数组**浅复制**生成一个一模一样的新数组（指向新的地址空间）。

```js
var array = [{a: 1}];
var array3 = array.concat();
console.log(array3); // [{a: 1}]
console.log(array3 === array); // false
console.log(array[0] === array3[0]); // true，新旧数组第一个元素依旧共用一个同一个对象的引用
```

##### join() 

将数组中的所有元素连接成一个字符串。

语法：*arr.join([separator = ‘,’])* separator可选，缺省默认为逗号。

```
var array = ['We', 'are', 'Chinese'];
console.log(array.join()); // "We,are,Chinese"
console.log(array.join('+')); // "We+are+Chinese"
console.log(array.join('')); // "WeareChinese"
```

##### slice() 

将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。

语法：*arr.slice([start[, end]])*

参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。

如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。

slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。

```
var array = ["one", "two", "three","four", "five"];
console.log(array.slice()); // ["one", "two", "three","four", "five"]
console.log(array.slice(2,3)); // ["three"]
123
```

**浅复制** 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象。下面来说明slice为什么是浅复制。

```
var array = [{color:"yellow"}, 2, 3];
var array2 = array.slice(0,1);
console.log(array2); // [{color:"yellow"}]
array[0]["color"] = "blue";
console.log(array2); // [{color:"bule"}]
12345
```

由于slice是浅复制，复制到的对象只是一个引用，改变原数组array的值，array2也随之改变。

##### toString()

##### toLocaleString()

##### indexOf

indexOf(arr[i],[index] )   	//从位置index查找arr[i]在数组中的位置，只找第一个匹配的,若没有则返回-1

##### lastindexOf

## 遍历

### 数组

**迭代方法 不会修改原数组**

every()、filter()、forEach()、map()、some()

#### forEach()

指定数组的每项元素都执行一次传入的函数，返回值为undefined。

语法：**arr.forEach(fn, thisArg)**

fn 表示在数组每一项上执行的函数，接受三个参数：

- value 当前正在被处理的元素的值
- index 当前元素的数组索引
- array 数组本身

thisArg 可选，用来当做fn函数内的this对象。

```js
var array = [1, 3, 5];
var obj = {name:'cc'};
var sReturn = array.forEach(function(value, index, array){
  array[index] = value * value;
  console.log(this.name); // cc被打印了三次
},obj);
console.log(array); // [1, 9, 25], 可见原数组改变了
console.log(sReturn); // undefined, 可见返回值为undefined
```

#### map()

使用传入函数处理每个元素，并返回函数的返回值组成的新数组。

语法：**arr.map(fn, thisArg)**

参数介绍同 forEach 方法的参数介绍。

#### every()

数组的每一项执行的函数都满足条件就返回true

#### some()

对数组的每一项运行给定函数，如果该函数对任一项返回true，则返回true。

#### filter()

执行函数过滤掉不符和条件的数组元素，返回复合条件的数组元素

语法：**arr.filter(fn, thisArg)**

```
var array = [18, 9, 10, 35, 80];
var array2 = array.filter(function(value, index, array){
  return value > 20;
});
console.log(array2); // [35, 80]
```

#### reduce()

reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。

语法：**arr.reduce(fn, initialValue)**

fn 表示在数组每一项上执行的函数，接受四个参数：

- previousValue 上一次调用回调返回的值，或者是提供的初始值
- value 数组中当前被处理元素的值
- index 当前元素在数组中的索引
- array 数组自身

initialValue 指定第一次调用 fn 的第一个参数。

#### entries() 

方法基于**ECMAScript 2015（ES6）规范**，返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。

语法：**arr.entries()**

```
var array = ["a", "b", "c"];
var iterator = array.entries();
console.log(iterator.next()); //{ value: [ 0, 'a' ], done: false } 
console.log(iterator.next().value); // [0, "a"]
console.log(iterator.next().value); // [1, "b"]
console.log(iterator.next().value); // [2, "c"]
console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined
```

#### keys

keys() 方法基于ECMAScript 2015（ES6）规范，返回一个数组索引的迭代器。（浏览器实际实现可能会有调整）

语法：**arr.keys()**

```js
var array = ["abc", "xyz"];
var iterator = array.keys();
console.log(iterator.next()); // Object {value: 0, done: false}
console.log(iterator.next()); // Object {value: 1, done: false}
console.log(iterator.next()); // Object {value: undefined, done: false}
```

#### values()

values() 方法基于**ECMAScript 2015（ES6）规范**，返回一个数组迭代器对象，该对象包含数组中每个索引的值。其用法基本与上述 entries 方法一致。

语法：**arr.values()**

遗憾的是，现在没有浏览器实现了该方法，因此下面将就着看看吧。

```js
var array = ["abc", "xyz"];
var iterator = array.values();
console.log(iterator.next().value);//abc
console.log(iterator.next().value);//xyz
```

#### for

 **for...in循环**

精准的迭代，可以迭代对象的元素。也可以迭代数组。

【注意】使用`for ... in`，迭代的是元素（keys），对于数组来说，则为下标（0,1,2...,length-1）

```text
for(var key in arr) {
    //执行相关操作
}
```

 **for...of循环（ES6支持）**

```text
for(let item of arr) {
    //执行相关操作
}
```

和`for...in`不同的是，`for...of`迭代出来的是值（value），对于数组来说，则是一个元素值。

### 对象

#### for...in 

**for...in遍历**

```js
var book = {
    name: "hello",
    id: "2",
    author: "ztyzz",
    time: "2018.2.30"

};
for(var el in book) {
    console.log(book[el]);
}
```

**for ... of遍历**

此方法，**不能遍历普通对象**(因为能够被for...of正常遍历的，都需要实现一个遍历器Iterator。而数组、字符串、Set、Map结构，早就内置好了Iterator（迭代器），它们的原型中都有一个Symbol.iterator方法，而Object对象并没有实现这个接口，使得它无法被for...of遍历。)，需要和`Object.keys()`搭配使用，先获取对象的所有key的数组 然后遍历：

```text
var book = {
    name: "hello",
    id: "2",
    author: "ztyzz",
    time: "2018.2.30"

};
for(var key of Object.keys(book)) {
    console.log(book[key]);
}
```

【注意】`Object.values()`返回对象所有的键值组成的数组，但是由于无法获取到key值，功能会比较残缺。

同时，由于`Object.keys()`返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).所以我们可以使用forEach()等上面的方法，来进行数组的遍历，再通过对象的访问来进行值的访问。

## 函数库

### Math

```js
Math.PI						// 圆周率
Math.random()				// 生成随机数
Math.floor()/Math.ceil()	 // 向下取整/向上取整
Math.round()				// 取整，四舍五入
Math.abs()					// 绝对值
Math.max()/Math.min()		 // 求最大和最小值                                                                                                           
Math.sin()Math.cos()		 // 正弦/余弦
Math.power()/Math.sqrt()	 // 求指数次幂/求平方根
```

### Date

#### **new Date()**创建新的日期对象

1. 用整数初始化日期对象

   new Date(yyyy,mth,dd,hh,mm,ss); 
   new Date(yyyy,mth,dd); 

   注意：

   - 您不能省略月份。如果只提供一个参数，则将其视为毫秒。
   - 一位和两位数年份将被解释为 19xx 年：

   ```
   yyyy:四位数表示的年份
   mth:用整数表示月份，从（１月）0到１１（１２月）
   dd:表示一个 月中的第几天，从1到31
   hh:小时数，从0（午夜）到23（晚11点）
   mm: 分钟数，从0到59的整数
   ss:秒数，从0到59的整数
   ```

2. 用字符串初始化日期对象

   new Date("2017/06/06"); 

   new Date(“2017-08-08”); 

   new Date("month dd,yyyy hh:mm:ss");  

   new Date("month dd,yyyy");

3. 用毫秒时间戳初始化日期对象

   new Date(ms);

   ```
   JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。
   零时间是 1970 年 1 月 1 日 00:00:00 UTC。
   ```

   

#### 获取日期方法

| 方法              | 描述                                 |
| :---------------- | :----------------------------------- |
| getDate()         | 以数值返回天（1-31）                 |
| getDay()          | 以数值获取周名（0-6）                |
| getFullYear()     | 获取四位的年（yyyy）                 |
| getHours()        | 获取小时（0-23）                     |
| getMilliseconds() | 获取毫秒（0-999）                    |
| getMinutes()      | 获取分（0-59）                       |
| getMonth()        | 获取月（0-11）                       |
| getSeconds()      | 获取秒（0-59）                       |
| getTime()         | 获取时间（从 1970 年 1 月 1 日至今） |

```
date.getFullYear()//获取完整的年份(4位,1970-????)
date.getMonth() //获取当前月份(0-11,0代表1月)
date.getDate()//获取几号   - 0 - 31 比如25
date.getDay()//获取星期几 - 比如星期3的3
date.getHours()//获取小时
date.getTime()// 获取相对于1970-01-01的毫秒值
```

#### 日期设置方法

设置方法用于设置日期的某个部分。下面是最常用的方法（按照字母顺序排序）：

| 方法              | 描述                                         |
| :---------------- | :------------------------------------------- |
| setDate()         | 以数值（1-31）设置日                         |
| setFullYear()     | 设置年（可选月和日）                         |
| setHours()        | 设置小时（0-23）                             |
| setMilliseconds() | 设置毫秒（0-999）                            |
| setMinutes()      | 设置分（0-59）                               |
| setMonth()        | 设置月（0-11）                               |
| setSeconds()      | 设置秒（0-59）                               |
| setTime()         | 设置时间（从 1970 年 1 月 1 日至今的毫秒数） |

#### **时间戳转化为日期的方式**

```
// Mon May 28 2018
console.log(newDate.toDateString());
 
// Mon, 28 May 2018 15:24:12 GMT
console.log(newDate.toGMTString());
 
// 2018-05-28T15:24:12.000Z
console.log(newDate.toISOString());
 
// 2018-05-28T15:24:12.000Z
console.log(newDate.toJSON());

// 2018/5/28
console.log(newDate.toLocaleDateString());
 
// 2018/5/28 下午11:24:12
console.log(newDate.toLocaleString());
 
// 下午11:24:12
console.log(newDate.toLocaleTimeString());
 
// Mon May 28 2018 23:24:12 GMT+0800 (中国标准时间)
console.log(newDate.toString());
 
// 23:24:12 GMT+0800 (中国标准时间)
console.log(newDate.toTimeString());
 
// Mon, 28 May 2018 15:24:12 GMT
console.log(newDate.toUTCString());
```

## 构造函数

### 背景

**（1）对象是单个实物的抽象。**

一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。

**（2）对象是一个容器，封装了属性（property）和方法（method）。**

属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为`animal`对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。

JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。

```js
function Person(name) {    
      this.name = name  
}  
var p1 = new Person('咚咚')  
console.log("p1:",p1);  
console.log("p1.__proto__ === Person.prototype:");
console.log("Person.prototype:",Person.prototype);
```

![img](https://user-gold-cdn.xitu.io/2020/3/15/170dd61fa1c7f710?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**new 命令的原理**

使用`new`命令时，它后面的函数依次执行下面的步骤。

1. 创建一个空对象，作为将要返回的对象实例。
2. 将这个空对象的原型，指向构造函数的`prototype`属性。
3. 将这个空对象赋值给函数内部的`this`关键字。
4. 开始执行构造函数内部的代码。

### 原型链

<img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img" style="zoom:67%;" />

所有对象都有自己的原型对象（prototype）。原型对象的所有属性和方法，都能被实例对象共享。

一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……

如果一层层地上溯，所有对象的原型最终都可以上溯到`Object.prototype`，即`Object`构造函数的`prototype`属性。也就是说，所有对象都继承了`Object.prototype`的属性。这就是所有对象都有`valueOf`和`toString`方法的原因，因为这是从`Object.prototype`继承的。

<img src="https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom: 67%;" />

那么，`Object.prototype`对象有没有它的原型呢？回答是`Object.prototype`的原型是`null`。`null`没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是`null`。

```js
Object.getPrototypeOf(Object.prototype)
// null
Object.prototype.__proto__ === null
```

#### _proto_

当一个实例对象被创建时，这个构造函数 将会把它的属性prototype赋给实例对象的内部属性__proto__。**proto是指向构造函数原型对象的指针。**

#### constructor 

`prototype`对象有一个`constructor`属性，默认指向`prototype`对象所在的构造函数。

```js
function P() {}
P.prototype.constructor === P // true
```

由于`constructor`属性定义在`prototype`对象上面，意味着可以被所有实例对象继承。

```js
function P() {}
var p = new P();

p.constructor === P // true
p.constructor === P.prototype.constructor // true
p.hasOwnProperty('constructor') // false
```

上面代码中，`p`是构造函数`P`的实例对象，但是`p`自身没有`constructor`属性，该属性其实是读取原型链上面的`P.prototype.constructor`属性。

#### instanceof

判断是否是数组 /判断某个对象是否是某个构造函数的实例 

### 继承

https://blog.csdn.net/qq_42926373/article/details/83149347

#### 属性继承

不能继承父级的原型

```javascript
function Person (name, age) {
  this.type = 'human'
  this.name = name
  this.age = age
}

function Student (name, age) {
  // 借用构造函数继承属性成员 
  Person.call(this, name, age)
}

var s1 = Student('张三', 18)
console.log(s1.type, s1.name, s1.age) // => human 张三 18
```

#### 原型方法继承

不能继承父级的构造函数

```js
Teacher.prototype = Object.create(Person.prototype)
Teacher.prototype.constructor = Teacher
```

**一旦我们修改构造函数的原型对象，为了防止引用出现问题，同时也要修改原型对象的constructor属性。**

#### 组合继承

```javascript
function Person (name, age) {
  this.type = 'human'
  this.name = name
  this.age = age
}

Person.prototype.sayName = function () {
  console.log('hello ' + this.name)
}

function Student (name, age) {
  Person.call(this, name, age)
}

// 利用原型的特性实现继承
Student.prototype = new Person()
// 若不指明原型对象，会指向person
//console.log(Student.prototype.constructor);
Student.prototype.constructor = Student;
var s1 = Student('张三', 18)

console.log(s1.type) // => human

s1.sayName() // => hello 张三
```

## this指向

### 指向对象

https://www.cnblogs.com/dongcanliang/p/7054176.html

- 在全局作用域下 this对象指向的是window对象

- 在函数作用域下 

  - 在非严格模式下: this的指向依旧是window对象
  - 在严格模式下:this的指向是undefined

- 超时调用（`setTimeout`回调）的代码都是在全局作用域环境中执行的

- 构造函数调用， 此时 this指向实例对象

- 在对象里面this的指向是当前该对象

  **特殊情况**

  - ```js
    var obj = {
        name(){
            console.log(this) //obj
           function fn(){
               console.log(this) //window
           }
           fn()
        }
    }
    obj.name()
    ```

    如何让函数里的那个函数fn也能使用当前obj这个对象了

    1. 将this赋值给that
    2. 使用箭头函数

  - ```js
    var o = {
      prop: 37,
      f: function() {
        return this.prop;
      }
    };
    console.log(o.f());  //37
    var a = o.f;
    console.log(a()):  //undefined
    ```

- 箭头函数不绑定this。箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this，**所以不会在调用时指向其执行环境的（变量）对象**

  - **注意：因为箭头函数内部的`this`是指向外层代码块的`this`的，所以我们可以通过改变外层代码块的`this`的指向从而改变箭头函数中`this`的指向**

### call、apply、bind

```js
1.1 作用
他们的作用都是改变函数内部的this。
这三个函数都是Function原型中的方法（所有的函数都是Function的实例），也就是说只有函数才可以直接调用这些方法。

1.2 三者区别
参数： 三个函数的第一个参数都是需要绑定的 this。
call/apply 修改完this指向后，会立即调用前面的函数，但是 bind 只是修改this指向，并不会调用
call/bind： 可以有n个参数，从第二个参数开始的所有参数都是原函数的参数。
apply：只有两个参数，并且第二个参数必须为数组，数组中的所有元素一一对应原函数的参数。 
    call 语法：  foo.call(this, arg1,arg2, ... ,argn );
    apply 语法： foo.apply(this, [ arg1,arg2, ... ,argn ] );
    bind 语法：  foo.bind(this, arg1,arg2, ... ,argn);

1.3调用：
call,apply： 调用后立即执行原函数。
bind： 调用后返回已经绑定好this的函数。

1.4场景
处理伪数组 (最常用)
继承
取数组最大最小值
合并数组
```

## 事件流

### 阶段

> `W3C`中定义事件的发生经历三个阶段：捕获阶段（`capturing`）、目标阶段（`targetin`）、冒泡阶段（`bubbling`）

- 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发
- 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发
- `DOM`事件流：同时支持两种事件模型：捕获型事件和冒泡型事件
- 阻止冒泡：在`W3c`中，使用`stopPropagation()`方法；在IE下设置`cancelBubble = true`
- 阻止捕获：阻止事件的默认行为，例如`click - <a>`后的跳转。在`W3c`中，使用`preventDefault()`方法，在`IE`下设置`window.event.returnValue = false`

### 监听事件

```xml
.addEventListener('click', fn, false);//false(默认)是事件冒泡，true是事件捕获
```

```
e.stopPropagation();阻止事件冒泡  e.preventDefault()阻止事件默认行为。
```

```
在jQuery中使用return false时，相当于同时使用event.preventDefault和event.stopPropagation，它会阻止冒泡也会阻止默认行为。 但是使用原生js写时，return false只会阻止默认行为。
```

### 事件对象event

- `target`是事件触发的真实元素
- `currentTarget`是事件绑定的元素
- 事件处理函数中的`this`指向是中为`currentTarget`。
- `currentTarget`和`target`，有时候是同一个元素，有时候不是同一个元素 （因为事件冒泡）
  - 当事件是子元素触发时，`currentTarget`为绑定事件的元素，`target`为子元素
    - 若绑定父元素，点击子元素冒泡触发事件，e.target指向子元素           
  - 当事件是元素自身触发时，`currentTarget`和`target`为同一个元素。

e.type点击对象的事件类型

```js
$("a").click(function(event) {
    alert(event.type); // "click"
  }); 
```

## html5

`HTML5` 现在已经不是 `SGML` 的子集，主要是关于图像，位置，存储，多任务等功能的增加

- 新增选择器 `document.querySelector`、`document.querySelectorAll`
- 拖拽释放(`Drag and drop`) API
- 媒体播放的 `video` 和 `audio`
- 本地存储 `localStorage` 和 `sessionStorage`
- 离线应用 `manifest`
- 桌面通知 `Notifications`
- 语意化标签 `article`、`footer`、`header`、`nav`、`section`
- 增强表单控件 `calendar`、`date`、`time`、`email`、`url`、`search`
- 地理位置 `Geolocation`
- 多任务 `webworker`
- 全双工通信协议 `websocket`
- 历史管理 `history`
- 跨域资源共享(CORS) `Access-Control-Allow-Origin`
- 页面可见性改变事件 `visibilitychange`
- 跨窗口通信 `PostMessage`
- `Form Data` 对象
- 绘画 `canvas`

### Error

#### 原生错误类型

##### SyntaxError 对象

`SyntaxError`对象是解析代码时发生的语法错误。

```
// 变量名错误
var 1a;
// Uncaught SyntaxError: Invalid or unexpected token

// 缺少括号
console.log 'hello');
// Uncaught SyntaxError: Unexpected string
```

##### ReferenceError 对象

`ReferenceError`对象是引用一个不存在的变量时发生的错误。

##### RangeError 对象

`RangeError`对象是一个值超出有效范围时发生的错误。

##### TypeError 对象

`TypeError`对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用`new`命令，就会抛出这种错误，因为`new`命令的参数应该是一个构造函数。

```
new 123
// Uncaught TypeError: number is not a func

var obj = {};
obj.unknownMethod()
// Uncaught TypeError: obj.unknownMethod is not a function
```

上面代码的第二种情况，调用对象不存在的方法，也会抛出`TypeError`错误，因为`obj.unknownMethod`的值是`undefined`，而不是一个函数。

##### URIError 对象

`URIError`对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。

##### 总结

以上这6种派生错误，连同原始的`Error`对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。

```js
var err1 = new Error('出错了！');
var err2 = new RangeError('出错了，变量超出有效范围！');
var err3 = new TypeError('出错了，变量类型无效！');

err1.message // "出错了！"
err2.message // "出错了，变量超出有效范围！"
err3.message // "出错了，变量类型无效！"
```

#### 自定义错误

```js
function UserError(message) {
  this.message = message || '默认信息';
  this.name = 'UserError';
}

UserError.prototype = new Error();
UserError.prototype.constructor = UserError;
```

上面代码自定义一个错误对象`UserError`，让它继承`Error`对象。然后，就可以生成这种自定义类型的错误了。

```js
new UserError('这是自定义的错误！');
```

#### throw 语句

```js
if (x <= 0) {
  throw new Error('x 必须为正数');
}
// Uncaught ReferenceError: x is not defined
```

上面代码中，`throw`抛出的是一个`UserError`实例。

`throw`也可以抛出自定义错误。

```
function UserError(message) {
  this.message = message || '默认信息';
  this.name = 'UserError';
}

throw new UserError('出错了！');
// Uncaught UserError {message: "出错了！", name: "UserError"}
```

上面代码中，`throw`抛出的是一个`UserError`实例。

`throw`**可以抛出任何类型的值**

```
// 抛出一个字符串
throw 'Error！';
// Uncaught Error！

// 抛出一个数值
throw 42;
// Uncaught 42

// 抛出一个布尔值
throw true;
// Uncaught true
```

#### try...catch 结构

一旦发生错误，程序就中止执行了。JavaScript 提供了`try...catch`结构，允许对错误进行处理，选择是否往下执行。

```js
try {
  throw new Error('出错了!');
} catch (e) {
  console.log(e.name + ": " + e.message);
  console.log(e.stack);
}
```

`try`代码块抛出错误（上例用的是`throw`语句），JavaScript 引擎就立即把代码的执行，转到`catch`代码块，或者说错误被`catch`代码块捕获了。

#### finally 代码块

`try...catch`结构允许在最后添加一个`finally`代码块，表示不管是否出现错误，都必需在最后运行的语句。

### 事件

#### onload

- onload

```javascript
window.onload = function () {
  // 当页面加载完成执行
  // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行
}
```

- onunload

```javascript
window.onunload = function () {
  // 当用户退出页面时执行
}
```



### window对象

#### 剪切板

- Clipboard.JS：Selection 与 execCommand API

  运行`ClipboardJS.isSupported()`来检查是否支持`clipboard.js`

  点击按钮两次才执行

  https://juejin.cn/post/6906635620752293902#heading-0

- 图像写入剪切板

  https://juejin.cn/post/6909237803050074126#heading-0

- base64,file和Blob的转换

  https://juejin.cn/post/6844903862873112583

- 阮一峰：剪贴板操作 Clipboard API 教程

  http://www.ruanyifeng.com/blog/2021/01/clipboard-api.html

##### 文字

```html
<input id="foo" type="text" value="大家好，我是阿宝哥">
<button class="btn" data-clipboard-action="copy" data-clipboard-target="#foo">复制</button>

<script>
  var clipboard = new ClipboardJS('.btn');

  clipboard.on('success', function(e) {
    console.log(e);
  });
    
  clipboard.on('error', function(e) {
    console.log(e);
  });
</script>

```

除了 `input` 元素之外，复制的目标还可以是 `div` 或 `textarea` 元素。在以上示例中，我们复制的目标是通过 **[data-\* 属性](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FGuide%2FHTML%2FUsing_data_attributes)** 来指定。此外，我们也可以在实例化 clipboard 对象时，设置复制的目标：

```javascript
// https://github.com/zenorocha/clipboard.js/blob/master/demo/function-target.html
let clipboard = new ClipboardJS('.btn', {
  target: function() {
    return document.querySelector('div');
  }
});
复制代码
```

如果需要设置复制的文本，我们也可以在实例化 clipboard 对象时，设置复制的文本：

```javascript
// https://github.com/zenorocha/clipboard.js/blob/master/demo/function-text.html
let clipboard = new ClipboardJS('.btn', {
  text: function() {
    return '大家好，我是阿宝哥';
  }
});
```

##### 图像

```js
//将base64转换为blob对象
//https://juejin.cn/post/6844903862873112583
function dataURLtoFile(dataurl, filename) {
  var arr = dataurl.split(",");
  var mime = arr[0].match(/:(.*?);/)[1];
  var bstr = atob(arr[1]);
  var n = bstr.length;
  var u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  //转换成file对象
  //return new File([u8arr], filename, { type: mime });
  //转换成成blob对象
  return new Blob([u8arr], { type: mime });
}
var imageBlob = dataURLtoFile(src);
const item = new ClipboardItem({
    [imageBlob.type]: imageBlob,
});
//检测浏览器是否支持clipboard-write
async function askWritePermission() {
    try {
      const { state } = await navigator.permissions.query({
        name: "clipboard-write",
      });
      return state === "granted";
    } catch (error) {
      return false;
    }
  }
if (askWritePermission()) {
    navigator.clipboard.write([item]);
    alert("成功复制到剪切板");
  } else {
    alert("不支持复制");
  }
```

**Chrome 浏览器规定，navigator.clipboard只有 HTTPS 协议的页面才能使用这个 API。不过，开发环境（`localhost`）允许使用非加密协议。**

##### blob对象

https://developer.mozilla.org/zh-CN/docs/Web/API/Blob

https://zhuanlan.zhihu.com/p/97768916

`Blob` 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取

![plain-type-blob](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/2/172734410d77d17b~tplv-t2oaga2asx-watermark.awebp)

如你所见，myBlob 对象含有两个属性：size 和 type。其中 size 属性用于表示数据的大小（以字节为单位），type 是 MIME 类型的字符串。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 File 接口基于 Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。

`Blob` 由一个可选的字符串 `type`（通常是 MIME 类型）和 `blobParts` 组成：

![blob-structure](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/2/172734410c51dbed~tplv-t2oaga2asx-watermark.awebp)

Blob 构造函数的语法为：

```
var aBlob = new Blob(blobParts, options);
```

blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。

options：一个可选的对象，包含以下两个属性：

- type —— 默认值为 `""`，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。
- endings —— 默认值为 `"transparent"`，用于指定包含行结束符 `\n` 的字符串如何被写入。 它是以下两个值中的一个： `"native"`，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 `"transparent"`，代表会保持 blob 中保存的结束符不变。

##### file对象

https://developer.mozilla.org/zh-CN/docs/Web/API/File

File 对象是来自用户在一个 <input> 元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象

**File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中**

### History对象

### Location对象

### File对象

**在web应用程序中使用文件**

https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications#example.3a_using_object_urls_to_display_images

#### 表单FormData对象

每一个控件都会生成一个键值对，所有的键值对都会提交到服务器。提交的数据格式跟`<form>`元素的`method`属性有关。只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。

点击`submit`控件，就可以提交表单。

```
<form>
  <input type="submit" value="提交">
</form>
```

表单里面的`<button>`元素如果没有用`type`属性指定类型，那么默认就是`submit`控件。

```
<form>
  <button>提交</button>
</form>
```

除了点击`submit`控件提交表单，还可以用表单元素的`submit()`方法，通过脚本提交表单。

```
formElement.submit();
```

**表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程**

FormData 首先是一个构造函数，用来生成实例。

```
var formdata = new FormData(form);

// 获取某个控件的值
formData.get('username') // ""

// 设置某个控件的值
formData.set('username', '张三');

formData.get('username') // "张三"
```

#### FormData 实例方法

- `FormData.get(key)`：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。
- `FormData.getAll(key)`：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。
- `FormData.set(key, value)`：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。
- `FormData.delete(key)`：删除一个键值对，参数为键名。
- `FormData.append(key, value)`：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。
- `FormData.has(key)`：返回一个布尔值，表示是否具有该键名的键值对。
- `FormData.keys()`：返回一个遍历器对象，用于`for...of`循环遍历所有的键名。
- `FormData.values()`：返回一个遍历器对象，用于`for...of`循环遍历所有的键值。
- `FormData.entries()`：返回一个遍历器对象，用于`for...of`循环遍历所有的键值对。如果直接用`for...of`循环遍历 FormData 实例，默认就会调用这个方法。

#### 自动校验

表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。

```
<!-- 必填 -->
<input required>

<!-- 必须符合正则表达式 -->
<input pattern="banana|cherry">

<!-- 字符串长度必须为6个字符 -->
<input minlength="6" maxlength="6">

<!-- 数值必须在1到10之间 -->
<input type="number" min="1" max="10">

<!-- 必须填入 Email 地址 -->
<input type="email">

<!-- 必须填入 URL -->
<input type="URL">
```

如果一个控件通过验证，它就会匹配`:valid`的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配`:invalid`的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。

### WEB存储

本地存储使用的是 cookie。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能.

- localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。

  ```
  // 存储 localStorage.sitename = "菜鸟教程"; 
  // 查找 document.getElementById("result").innerHTML =localStorage.sitename;
  //移除 localStorage 中的 "sitename" :
  localStorage.removeItem("sitename");
  ```

  ```
  不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：
  
  - 保存数据：localStorage.setItem(key,value);
  - 读取数据：localStorage.getItem(key);
  - 删除单个数据：localStorage.removeItem(key);
  - 删除所有数据：localStorage.clear();
  - 得到某个索引的key：localStorage.key(index);
  
  ```

- sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。

### Tips

设置属性（setAttribute）,属性名为'data-'开头的，可以使用dataset来获取值

```
setAttribute('data-age', value);      dataset['age']
```

```js
属性length,返回类的数量
classList.item(index)返回元素中索引值对应的类名。索引值从 0 开始。
classList.remove/add/toggle('active')
classList.contains('active')判断当前ClassList中有没有active
classList.toggle('active', '');toggle函数的第二个参数true为添加 false删除
```


# jquery

## 核心

- $([selector,[context]])

  $()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个  context 中查找。

  ##### jQuery 代码:

  ```js
  $("input:radio", document.forms[0]);
  //在文档的第一个表单中，查找所有的单选按钮(即: type 值为 radio 的 input 元素)。
  ```

- ```js
  //DOM文档载入完成后执行的函数
  $(function(){
    // 文档就绪
  });
  ```

- ## this

```js
当你用的是jquery时，就用$(this)，如果是JS，就用this
jquery对象$(this)[0]等同于JS里的元素this
console.log($(this)[0]==this) //true

JS里的元素只要包上$()就是jquery对象了，而jquery的对象只要加上[0]或者.get(0)，就是js元素了
$(this).get(0)与$(this)[0]等价。
console.log($(this)[0]==$(this).get(0)) //true
```

- each(callback),每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素


```
$("img").each(function(i){
   this.src = "test" + i + ".jpg";
 });
//this是js的this
```

- size()/length当前匹配的元素个数

- get(index)取得其中一个匹配的元素

  ##### HTML 代码:

  ```
  <img src="test1.jpg"/> <img src="test2.jpg"/>
  ```

  ##### jQuery 代码:

  ```
  $("img").get(0);
  ```

- index(一个DOM选择器/ jQuery 选择器)

  搜索匹配的元素，并返回相应元素的索引值，从0开始计数。

```html
<ul>
  <li id="foo">foo</li>
  <li id="bar">bar</li>
  <li id="baz">baz</li>
</ul>
$('li').index(document.getElementById('bar')); //1，传递一个DOM对象，返回这个对象在原先集合中的索引位置
$('#bar').index('li'); //1，传递一个选择器，返回#bar在所有li中的索引位置
$('#bar').index(); //1，不传递参数，返回这个元素在同辈中的索引位置。
```

## 属性

- attr(name|key,value)返回或设置被选元素的属性值。removeAttr

  ```js
  $("img").attr({ src: "test.jpg", alt: "Test Image" });//为所有图像设置src和alt属性。
  $("img").attr("src","test.jpg");//为所有图像设置src属性。
  ```

- removeAttr(name)从每一个匹配的元素中删除一个属性

  ```js
  $("img").removeAttr("src");
  //将文档中图像的src属性删除
  ```

- addClass(class|fn)为每个匹配的元素添加指定的类名。removeClass

  ```js
  $('ul li:last').addClass(function(index,class) {
    return 'item-' + $(this).index();
  });//给li加上不同的class
  ```

- toggleClass(class|fn)如果存在（不存在）就删除（添加）一个类。

  ```js
    var count = 0;
    $("p").click(function(){
        $(this).toggleClass("highlight", count++ % 3 == 0);
    });//每点击三下加上一次 'highlight' 类
  ```

- html()

  ```js
  //返回p元素的内容。取得第一个匹配元素的html内容。
  $('p').html();
  //设置所有 p 元素的内容
  $("p").html("Hello <b>world</b>!");
  ```

- text()

  ```js
  //返回p元素的文本内容。
  $('p').text();
  //设置所有 p 元素的文本内容
  $("p").text("Hello world!");
  ```

- val()

## css

- css

  ```js
  //取得第一个段落的color样式属性的值。
  $("p").css("color");
  //将所有段落的字体颜色设为红色并且背景为蓝色。
  $("p").css({ "color": "#ff0011", "background": "blue" });
  //将所有段落字体设为红色
  $("p").css("color","red");
  ```

- height()

  ```js
  //获取第一段的高
  $("p").height();
  //把所有段落的高设为 20:
  $("p").height(20);
  //以 10 像素的幅度增加 p 元素的高度
   $("button").click(function(){
      $("p").height(function(n,c){
       //n,c索引位置和元素旧的高度值
      return c+10;
      });
    });
  ```

## 选择器

### 层级

- prev + next匹配所有紧接在 prev 元素后的 next 元素

  ```js
  //匹配所有跟在 label 后面的 input 元素
  <form>
    <label>Name:</label>
    <input name="name" />
    <fieldset>
        <label>Newsletter:</label>
        <input name="newsletter" />
   </fieldset>
  </form>
  <input name="none" />
      
  $("label + input")
  [ <input name="name" />, <input name="newsletter" /> ]
  ```

- prev ~ siblings匹配 prev 元素之后的所有 siblings 元素

  ```js
  <form>
    <label>Name:</label>
    <input name="name" />
    <fieldset>
        <label>Newsletter:</label>
        <input name="newsletter" />
   </fieldset>
  </form>
  <input name="none" />
  
  $("form ~ input")
  [ <input name="none" /> ]
  ```

### 基本

- :first获取第一个元素-->last

  ```js
  $('li:first');
  ```

- :not去除所有与给定选择器匹配的元素

  ```js
  //查找所有未选中的 input 元素
  <input name="apple" />
  <input name="flower" checked="checked" />
  $("input:not(:checked)")
  ```

- :even()匹配所有索引值为偶数的元素，从 0 开始计数-->:odd()

- :eq()匹配一个给定索引值的元素,从 0 开始计数

- :gt()匹配所有大于给定索引值的元素,从 0 开始计数-->:It()

### 可见性

### 属性

### 子元素

### 表单

## 文档处理

### 内部插入

- append()向每个匹配的元素内部追加内容。

- appendTo()把所有匹配的元素追加到另一个指定的元素元素集合中。

  ```js
  <p>I would like to say: </p>
  <div></div><div></div>
  $("p").appendTo("div");
  <div><p>I would like to say: </p></div>
  <div><p>I would like to say: </p></div>
  ```

- prepend()向每个匹配的元素内部前置内容。-->prependTo()

### 外部插入

- after()在每个匹配的元素之后插入内容。-->before
- insertAfter-->insertBefore

### 替换

- replaceWith(content|fn)将所有匹配的元素替换成指定的HTML或DOM元素。

### 删除

- empty()删除匹配的元素集合中所有的子节点。
- remove()从DOM中删除所有匹配的元素。

## 筛选

is(expr|obj|ele|fn)根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。

map(fn)将一组元素转换成其他数组（不论是否是元素数组）用这个函数来建立一个列表，不论是值、属性还是CSS样式，

```
$("p").append( $("input").map(function(){
  return $(this).val();
}).get().join(", ") );get()jQuery转DOM对象

$.map(arr|obj,callback)将一个数组中的元素转换到另一个数组中。array:待转换数组。将原数组中每个元素加 4 转换为一个新数组。
$.map( [0,1,2], function(n){
  return n + 4;
});
```

children(expr),取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。expr用以过滤子元素的表达式

find(expr|obj|ele),搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。与$("p span")相同。

next(expr),取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。

nextAll(expr),查找当前元素之后所有的同辈元素。

prev(expr)取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合。

siblings(expr)取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选。

## 事件

```
1.one(type,[data],fn)  为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。在每个对象上，这个事件处理函数只会被执行一次。 其他规则与bind()函数相同(bind()的事件函数只能针对已经存在的元素进行事件的设置)。

**type:**添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。
**data:**作为event.data属性值传递给事件对象的额外数据对象
**fn:**每当事件触发时执行的函数。

2.live(type,[data],fn) 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的 
3.on(events,[selector],[data],fn)  在选择元素上绑定一个或多个事件的事件处理函数。
事件委托即事件冒泡
// 在body元素上绑定click事件处理函数handler，如果这个click事件是由其后代的P元素触发的，就执行handlerp
$(document.body).on("click", "p", handler);
e.stopPaptration();//为了不让点击p 使得他们的父级的事件也触发了，就阻止冒泡
```

trigger(type,[data])在每一个匹配的元素上触发某类事件。

hover([over,]out)

over:鼠标移到元素上要触发的函数

out:鼠标移出元素要触发的函数

toggle([speed],[easing],[fn])用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。

```
$("td").toggle(
  function () {
    $(this).addClass("selected");
  },
  function () {
    $(this).removeClass("selected");
  }
);//对表格的切换一个类
$('td).toggle();//对表格切换显示/隐藏
```

change([data],fn)当元素的值发生改变时，会发生 change 事件。

unload([[data],fn])在当用户离开页面时，会发生 unload 事件。

会发出 unload 事件：

- 点击某个离开页面的链接  
- 在地址栏中键入了新的 URL  
- 使用前进或后退按钮  
- 关闭浏览器  
- 重新加载页面 

# ES6

## 异步操作

### 背景

**js语言执行环境是单线程**

JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，**单个脚本**只能在一个线程上运行（称为主线程），其他线程都是在后台配合。

JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。

如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“**事件循环**”机制（Event Loop）。

```
JS中的异步操作：
1、定时器都是异步操作
2、事件绑定都是异步操作
3、AJAX中一般我们都采取异步操作（也可以同步）
4、回调函数可以理解为异步（不是严谨的异步操作）
剩下的都是同步处理
```

**同步任务和异步任务**

同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。

异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。

- 宏任务：包括整体代码script，setTimeout，setInterval
- 微任务：Promise.then(非new Promise)，process.nextTick(node中)

### 1.回调函数

一个函数作为参数传递到另一个函数中

```js
function f1(callback){
	setTimeout(function(){
	callback()//f1的任务
	},1000)
}
f1(f2);
```

优缺点:简单,容易部署,但不利于代码的阅读和维护,各部分之间高度耦合

**注意:回调并不一定是异步**

### 2.事件监听

异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生

监听函数:on,bind,listen,addEventListener

监听方法:onclick...

### 3发布/订阅

事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”[发布/订阅模式](https://en.wikipedia.org/wiki/Publish-subscribe_pattern)”（publish-subscribe pattern），又称“[观察者模式](https://en.wikipedia.org/wiki/Observer_pattern)”（observer pattern）。

首先，`f2`向信号中心`jQuery`订阅`done`信号。

```
jQuery.subscribe('done', f2);
```

然后，`f1`进行如下改写。

```
function f1() {
  setTimeout(function () {
    // ...
    jQuery.publish('done');
  }, 1000);
}
```

上面代码中，`jQuery.publish('done')`的意思是，`f1`执行完成后，向信号中心`jQuery`发布`done`信号，从而引发`f2`的执行。

`f2`完成执行后，可以取消订阅（unsubscribe）。

```
jQuery.unsubscribe('done', f2);	
```

### 4.promise

- **名称**
   译为“承诺”，这也就表达了将来会执行的操作，代表异步操作；

- **状态**
   一共有三种状态，分别为`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。

- **特点**
   (1)只有异步操作可以决定当前处于的状态，并且任何其他操作无法改变这个状态；
   (2)一旦状态改变，就不会在变。状态改变的过程只可能是：从`pending`变为`fulfilled`和从`pending`变为`rejected`。如果状态发生上述变化后，此时状态就不会在改变了，这时就称为`resolved`（已定型）

- **基本用法**

  Promise 对象是由关键字 new 及其构造函数来创建的。

  ```js
  const promise = new Promise((resolve, reject) => {
      // do something here ...
      if (success) {
          resolve(value); // fulfilled
      } else {
          reject(error); // rejected
      }
  });
  ```

  该构造函数接收两个函数作为参数，分别是`resolve`和`reject`。
   当异步操作执行成功后，会将异步操作结果作为参数传入`resolve`函数并执行，此时 `Promise`对象状态从`pending`变为`fulfilled`；
   失败则会将异步操作的错误作为参数传入`reject`函数并执行，此时 `Promise`对象状态从`pending`变为`rejected`；

```js
let a = new Promise(function(resolve,reject){
    if(1){
        console.log(4)
        resolve(1)
    }
})
setTimeout(function(){
    console.log(5)
},1000)
console.log(2)
a.then(function(calue){
    console.log(calue)
})
console.log(3)

//42315
```

```js
var a = new Promise((resolve,reject)=>{
    reject(1)
})
a.catch((i)=>{
    console.log(i)
    return new Promise((resolve,reject)=>{
        reject(2)
    })
}).then((i)=>{
    console.log(i)
})
// 1
//返回新的promise，那么下一级.then()会在新的promise状态改变之后执行
```

- 返回新的promise，那么下一级.then()会在新的promise状态改变之后执行
- 没有return，相当于return Promise.resolve(undefined);
- return非Promise的数据data，相当于return Promise.resolve(data);

### 5.async/await

定义：使异步函数以同步函数的形式书写(Generator函数语法糖)

原理：将`Generator函数`和自动执行器`spawn`包装在一个函数里

形式：将`Generator函数`的`*`替换成`async`，将`yield`替换成`await`

声明

- 函数：`async function Func() {}`
- 函数表达式：`const func = async function() {}`
- 箭头函数：`const func = async() => {}`
- 对象方法：`const obj = { async func() {} }`
- 类方法：`class Cla { async Func() {} }`

**async函数的返回值总是一个Promise**

无论async函数有无await操作，其总是返回一个Promise。因此，其后面可以直接调用then方法，函数内部return返回的值，会成为then回调函数的参数。函数内部抛出的错误，会被then的第二个函数或catch方法捕获到

1. 没有显式return，相当于return Promise.resolve(undefined);
2. return非Promise的数据data，相当于return Promise.resolve(data);
3. return Promise, 会得到Promise对象本身

 **await操作符的值**

```
[rv] = await expression（expression可以是任何值，通常是一个promise）
```

expression是Promise，rv等于Promise兑现的值，若Promise被拒绝，则抛出异常，由catch捕获
expression是非Promise，会立即被转换为resolve的Promise，rv等于expression

```js
let a =async function(){
    let b = await l();
    console.log(b)
    let c = await h();
    console.log(c)
    return 2
}
function l(){
    console.log(1)
    return 3
}
function h(){
    console.log(5)
    return 6
}
a().then(function(v){
    console.log(v)
})
    console.log(a)//[λ: a]
//1,[λ: a],3,5,6,2
```

**tips**

返回的Promise对象必须等到内部所有`await命令Promise对象`执行完才会发生状态改变，除非遇到`return语句`或`抛出错误`

任何一个`await命令Promise对象`变为`rejected状态`，整个`Async函数`都会中断执行

希望即使前一个异步操作失败也不要中断后面的异步操作

- 将`await命令Promise对象`放到`try-catch`中
- `await命令Promise对象`跟一个`catch()`

`await命令Promise对象`可能变为`rejected状态`，最好把其放到`try-catch`中

多个`await命令Promise对象`若不存在继发关系，最好让它们同时触发

```js
//变量分别接收Promise
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise();
let bar = await barPromise();
//使用Promise.all
let [foo,bar] = await Promise.all([getFoo(),getBar()]);


```

`await命令`只能用在`Async函数`之中，否则会报错

数组使用`forEach()`执行`async/await`会失效，可使用`for-of`和`Promise.all()`代替

可保留运行堆栈，函数上下文随着`Async函数`的执行而存在，执行完成就消失

# 底层API

## MutationObserver

https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/MutationObserver

当父元素中的元素有删减，会调用该函数。

eg：点击按钮，table中添加tr，调用该函数，可以为tr中的input设置disabled

tip: 添加合理的判断条件，否则会执行死循环